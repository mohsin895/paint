
if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); + function (t) {
    "use strict";
    var e = t.fn.jquery.split(" ")[0].split(".");
    if (e[0] < 2 && e[1] < 9 || 1 == e[0] && 9 == e[1] && e[2] < 1) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var i = t(this),
                n = i.data("bs.alert");
            n || i.data("bs.alert", n = new o(this)), "string" == typeof e && n[e].call(i)
        })
    }
    var i = '[data-dismiss="alert"]',
        o = function (e) {
            t(e).on("click", i, this.close)
        };
    o.VERSION = "3.3.5", o.TRANSITION_DURATION = 150, o.prototype.close = function (e) {
        function i() {
            a.detach().trigger("closed.bs.alert").remove()
        }
        var n = t(this),
            s = n.attr("data-target");
        s || (s = n.attr("href"), s = s && s.replace(/.*(?=#[^\s]*$)/, ""));
        var a = t(s);
        e && e.preventDefault(), a.length || (a = n.closest(".alert")), a.trigger(e = t.Event("close.bs.alert")), e.isDefaultPrevented() || (a.removeClass("in"), t.support.transition && a.hasClass("fade") ? a.one("bsTransitionEnd", i).emulateTransitionEnd(o.TRANSITION_DURATION) : i())
    };
    var n = t.fn.alert;
    t.fn.alert = e, t.fn.alert.Constructor = o, t.fn.alert.noConflict = function () {
        return t.fn.alert = n, this
    }, t(document).on("click.bs.alert.data-api", i, o.prototype.close)
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var o = t(this),
                n = o.data("bs.button"),
                s = "object" == typeof e && e;
            n || o.data("bs.button", n = new i(this, s)), "toggle" == e ? n.toggle() : e && n.setState(e)
        })
    }
    var i = function (e, o) {
        this.$element = t(e), this.options = t.extend({}, i.DEFAULTS, o), this.isLoading = !1
    };
    i.VERSION = "3.3.5", i.DEFAULTS = {
        loadingText: "loading..."
    }, i.prototype.setState = function (e) {
        var i = "disabled",
            o = this.$element,
            n = o.is("input") ? "val" : "html",
            s = o.data();
        e += "Text", null == s.resetText && o.data("resetText", o[n]()), setTimeout(t.proxy(function () {
            o[n](null == s[e] ? this.options[e] : s[e]), "loadingText" == e ? (this.isLoading = !0, o.addClass(i).attr(i, i)) : this.isLoading && (this.isLoading = !1, o.removeClass(i).removeAttr(i))
        }, this), 0)
    }, i.prototype.toggle = function () {
        var t = !0,
            e = this.$element.closest('[data-toggle="buttons"]');
        if (e.length) {
            var i = this.$element.find("input");
            "radio" == i.prop("type") ? (i.prop("checked") && (t = !1), e.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == i.prop("type") && (i.prop("checked") !== this.$element.hasClass("active") && (t = !1), this.$element.toggleClass("active")), i.prop("checked", this.$element.hasClass("active")), t && i.trigger("change")
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
    };
    var o = t.fn.button;
    t.fn.button = e, t.fn.button.Constructor = i, t.fn.button.noConflict = function () {
        return t.fn.button = o, this
    }, t(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (i) {
        var o = t(i.target);
        o.hasClass("btn") || (o = o.closest(".btn")), e.call(o, "toggle"), t(i.target).is('input[type="radio"]') || t(i.target).is('input[type="checkbox"]') || i.preventDefault()
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (e) {
        t(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type))
    })
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var o = t(this),
                n = o.data("bs.carousel"),
                s = t.extend({}, i.DEFAULTS, o.data(), "object" == typeof e && e),
                a = "string" == typeof e ? e : s.slide;
            n || o.data("bs.carousel", n = new i(this, s)), "number" == typeof e ? n.to(e) : a ? n[a]() : s.interval && n.pause().cycle()
        })
    }
    var i = function (e, i) {
        this.$element = t(e), this.$indicators = this.$element.find(".carousel-indicators"), this.options = i, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", t.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", t.proxy(this.pause, this)).on("mouseleave.bs.carousel", t.proxy(this.cycle, this))
    };
    i.VERSION = "3.3.5", i.TRANSITION_DURATION = 600, i.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, i.prototype.keydown = function (t) {
        if (!/input|textarea/i.test(t.target.tagName)) {
            switch (t.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                default:
                    return
            }
            t.preventDefault()
        }
    }, i.prototype.cycle = function (e) {
        return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(t.proxy(this.next, this), this.options.interval)), this
    }, i.prototype.getItemIndex = function (t) {
        return this.$items = t.parent().children(".item"), this.$items.index(t || this.$active)
    }, i.prototype.getItemForDirection = function (t, e) {
        var i = this.getItemIndex(e),
            o = "prev" == t && 0 === i || "next" == t && i == this.$items.length - 1;
        if (o && !this.options.wrap) return e;
        var n = "prev" == t ? -1 : 1,
            s = (i + n) % this.$items.length;
        return this.$items.eq(s)
    }, i.prototype.to = function (t) {
        var e = this,
            i = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        return t > this.$items.length - 1 || 0 > t ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () {
            e.to(t)
        }) : i == t ? this.pause().cycle() : this.slide(t > i ? "next" : "prev", this.$items.eq(t))
    }, i.prototype.pause = function (e) {
        return e || (this.paused = !0), this.$element.find(".next, .prev").length && t.support.transition && (this.$element.trigger(t.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this
    }, i.prototype.next = function () {
        return this.sliding ? void 0 : this.slide("next")
    }, i.prototype.prev = function () {
        return this.sliding ? void 0 : this.slide("prev")
    }, i.prototype.slide = function (e, o) {
        var n = this.$element.find(".item.active"),
            s = o || this.getItemForDirection(e, n),
            a = this.interval,
            r = "next" == e ? "left" : "right",
            l = this;
        if (s.hasClass("active")) return this.sliding = !1;
        var h = s[0],
            d = t.Event("slide.bs.carousel", {
                relatedTarget: h,
                direction: r
            });
        if (this.$element.trigger(d), !d.isDefaultPrevented()) {
            if (this.sliding = !0, a && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var p = t(this.$indicators.children()[this.getItemIndex(s)]);
                p && p.addClass("active")
            }
            var c = t.Event("slid.bs.carousel", {
                relatedTarget: h,
                direction: r
            });
            return t.support.transition && this.$element.hasClass("slide") ? (s.addClass(e), s[0].offsetWidth, n.addClass(r), s.addClass(r), n.one("bsTransitionEnd", function () {
                s.removeClass([e, r].join(" ")).addClass("active"), n.removeClass(["active", r].join(" ")), l.sliding = !1, setTimeout(function () {
                    l.$element.trigger(c)
                }, 0)
            }).emulateTransitionEnd(i.TRANSITION_DURATION)) : (n.removeClass("active"), s.addClass("active"), this.sliding = !1, this.$element.trigger(c)), a && this.cycle(), this
        }
    };
    var o = t.fn.carousel;
    t.fn.carousel = e, t.fn.carousel.Constructor = i, t.fn.carousel.noConflict = function () {
        return t.fn.carousel = o, this
    };
    var n = function (i) {
        var o, n = t(this),
            s = t(n.attr("data-target") || (o = n.attr("href")) && o.replace(/.*(?=#[^\s]+$)/, ""));
        if (s.hasClass("carousel")) {
            var a = t.extend({}, s.data(), n.data()),
                r = n.attr("data-slide-to");
            r && (a.interval = !1), e.call(s, a), r && s.data("bs.carousel").to(r), i.preventDefault()
        }
    };
    t(document).on("click.bs.carousel.data-api", "[data-slide]", n).on("click.bs.carousel.data-api", "[data-slide-to]", n), t(window).on("load", function () {
        t('[data-ride="carousel"]').each(function () {
            var i = t(this);
            e.call(i, i.data())
        })
    })
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        var i = e.attr("data-target");
        i || (i = e.attr("href"), i = i && /#[A-Za-z]/.test(i) && i.replace(/.*(?=#[^\s]*$)/, ""));
        var o = i && t(i);
        return o && o.length ? o : e.parent()
    }

    function i(i) {
        i && 3 === i.which || (t(n).remove(), t(s).each(function () {
            var o = t(this),
                n = e(o),
                s = {
                    relatedTarget: this
                };
            n.hasClass("open") && (i && "click" == i.type && /input|textarea/i.test(i.target.tagName) && t.contains(n[0], i.target) || (n.trigger(i = t.Event("hide.bs.dropdown", s)), i.isDefaultPrevented() || (o.attr("aria-expanded", "false"), n.removeClass("open").trigger("hidden.bs.dropdown", s))))
        }))
    }

    function o(e) {
        return this.each(function () {
            var i = t(this),
                o = i.data("bs.dropdown");
            o || i.data("bs.dropdown", o = new a(this)), "string" == typeof e && o[e].call(i)
        })
    }
    var n = ".dropdown-backdrop",
        s = '[data-toggle="dropdown"]',
        a = function (e) {
            t(e).on("click.bs.dropdown", this.toggle)
        };
    a.VERSION = "3.3.5", a.prototype.toggle = function (o) {
        var n = t(this);
        if (!n.is(".disabled, :disabled")) {
            var s = e(n),
                a = s.hasClass("open");
            if (i(), !a) {
                "ontouchstart" in document.documentElement && !s.closest(".navbar-nav").length && t(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(t(this)).on("click", i);
                var r = {
                    relatedTarget: this
                };
                if (s.trigger(o = t.Event("show.bs.dropdown", r)), o.isDefaultPrevented()) return;
                n.trigger("focus").attr("aria-expanded", "true"), s.toggleClass("open").trigger("shown.bs.dropdown", r)
            }
            return !1
        }
    }, a.prototype.keydown = function (i) {
        if (/(38|40|27|32)/.test(i.which) && !/input|textarea/i.test(i.target.tagName)) {
            var o = t(this);
            if (i.preventDefault(), i.stopPropagation(), !o.is(".disabled, :disabled")) {
                var n = e(o),
                    a = n.hasClass("open");
                if (!a && 27 != i.which || a && 27 == i.which) return 27 == i.which && n.find(s).trigger("focus"), o.trigger("click");
                var r = " li:not(.disabled):visible a",
                    l = n.find(".dropdown-menu" + r);
                if (l.length) {
                    var h = l.index(i.target);
                    38 == i.which && h > 0 && h--, 40 == i.which && h < l.length - 1 && h++, ~h || (h = 0), l.eq(h).trigger("focus")
                }
            }
        }
    };
    var r = t.fn.dropdown;
    t.fn.dropdown = o, t.fn.dropdown.Constructor = a, t.fn.dropdown.noConflict = function () {
        return t.fn.dropdown = r, this
    }, t(document).on("click.bs.dropdown.data-api", i).on("click.bs.dropdown.data-api", ".dropdown form", function (t) {
        t.stopPropagation()
    }).on("click.bs.dropdown.data-api", s, a.prototype.toggle).on("keydown.bs.dropdown.data-api", s, a.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", a.prototype.keydown)
}(jQuery), + function (t) {
    "use strict";

    function e(e, o) {
        return this.each(function () {
            var n = t(this),
                s = n.data("bs.modal"),
                a = t.extend({}, i.DEFAULTS, n.data(), "object" == typeof e && e);
            s || n.data("bs.modal", s = new i(this, a)), "string" == typeof e ? s[e](o) : a.show && s.show(o)
        })
    }
    var i = function (e, i) {
        this.options = i, this.$body = t(document.body), this.$element = t(e), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, t.proxy(function () {
            this.$element.trigger("loaded.bs.modal")
        }, this))
    };
    i.VERSION = "3.3.5", i.TRANSITION_DURATION = 300, i.BACKDROP_TRANSITION_DURATION = 150, i.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, i.prototype.toggle = function (t) {
        return this.isShown ? this.hide() : this.show(t)
    }, i.prototype.show = function (e) {
        var o = this,
            n = t.Event("show.bs.modal", {
                relatedTarget: e
            });
        this.$element.trigger(n), this.isShown || n.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', t.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {
            o.$element.one("mouseup.dismiss.bs.modal", function (e) {
                t(e.target).is(o.$element) && (o.ignoreBackdropClick = !0)
            })
        }), this.backdrop(function () {
            var n = t.support.transition && o.$element.hasClass("fade");
            o.$element.parent().length || o.$element.appendTo(o.$body), o.$element.show().scrollTop(0), o.adjustDialog(), n && o.$element[0].offsetWidth, o.$element.addClass("in"), o.enforceFocus();
            var s = t.Event("shown.bs.modal", {
                relatedTarget: e
            });
            n ? o.$dialog.one("bsTransitionEnd", function () {
                o.$element.trigger("focus").trigger(s)
            }).emulateTransitionEnd(i.TRANSITION_DURATION) : o.$element.trigger("focus").trigger(s)
        }))
    }, i.prototype.hide = function (e) {
        e && e.preventDefault(), e = t.Event("hide.bs.modal"), this.$element.trigger(e), this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), t(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), t.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", t.proxy(this.hideModal, this)).emulateTransitionEnd(i.TRANSITION_DURATION) : this.hideModal())
    }, i.prototype.enforceFocus = function () {
        t(document).off("focusin.bs.modal").on("focusin.bs.modal", t.proxy(function (t) {
            this.$element[0] === t.target || this.$element.has(t.target).length || this.$element.trigger("focus")
        }, this))
    }, i.prototype.escape = function () {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", t.proxy(function (t) {
            27 == t.which && this.hide()
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    }, i.prototype.resize = function () {
        this.isShown ? t(window).on("resize.bs.modal", t.proxy(this.handleUpdate, this)) : t(window).off("resize.bs.modal")
    }, i.prototype.hideModal = function () {
        var t = this;
        this.$element.hide(), this.backdrop(function () {
            t.$body.removeClass("modal-open"), t.resetAdjustments(), t.resetScrollbar(), t.$element.trigger("hidden.bs.modal")
        })
    }, i.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
    }, i.prototype.backdrop = function (e) {
        var o = this,
            n = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var s = t.support.transition && n;
            if (this.$backdrop = t(document.createElement("div")).addClass("modal-backdrop " + n).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", t.proxy(function (t) {
                    return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(t.target === t.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
                }, this)), s && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !e) return;
            s ? this.$backdrop.one("bsTransitionEnd", e).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : e()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var a = function () {
                o.removeBackdrop(), e && e()
            };
            t.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", a).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : a()
        } else e && e()
    }, i.prototype.handleUpdate = function () {
        this.adjustDialog()
    }, i.prototype.adjustDialog = function () {
        var t = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && t ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !t ? this.scrollbarWidth : ""
        })
    }, i.prototype.resetAdjustments = function () {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        })
    }, i.prototype.checkScrollbar = function () {
        var t = window.innerWidth;
        if (!t) {
            var e = document.documentElement.getBoundingClientRect();
            t = e.right - Math.abs(e.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < t, this.scrollbarWidth = this.measureScrollbar()
    }, i.prototype.setScrollbar = function () {
        var t = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", t + this.scrollbarWidth)
    }, i.prototype.resetScrollbar = function () {
        this.$body.css("padding-right", this.originalBodyPad)
    }, i.prototype.measureScrollbar = function () {
        var t = document.createElement("div");
        t.className = "modal-scrollbar-measure", this.$body.append(t);
        var e = t.offsetWidth - t.clientWidth;
        return this.$body[0].removeChild(t), e
    };
    var o = t.fn.modal;
    t.fn.modal = e, t.fn.modal.Constructor = i, t.fn.modal.noConflict = function () {
        return t.fn.modal = o, this
    }, t(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (i) {
        var o = t(this),
            n = o.attr("href"),
            s = t(o.attr("data-target") || n && n.replace(/.*(?=#[^\s]+$)/, "")),
            a = s.data("bs.modal") ? "toggle" : t.extend({
                remote: !/#/.test(n) && n
            }, s.data(), o.data());
        o.is("a") && i.preventDefault(), s.one("show.bs.modal", function (t) {
            t.isDefaultPrevented() || s.one("hidden.bs.modal", function () {
                o.is(":visible") && o.trigger("focus")
            })
        }), e.call(s, a, this)
    })
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var o = t(this),
                n = o.data("bs.tooltip"),
                s = "object" == typeof e && e;
            (n || !/destroy|hide/.test(e)) && (n || o.data("bs.tooltip", n = new i(this, s)), "string" == typeof e && n[e]())
        })
    }
    var i = function (t, e) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", t, e)
    };
    i.VERSION = "3.3.5", i.TRANSITION_DURATION = 150, i.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        }
    }, i.prototype.init = function (e, i, o) {
        if (this.enabled = !0, this.type = e, this.$element = t(i), this.options = this.getOptions(o), this.$viewport = this.options.viewport && t(t.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = {
                click: !1,
                hover: !1,
                focus: !1
            }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var n = this.options.trigger.split(" "), s = n.length; s--;) {
            var a = n[s];
            if ("click" == a) this.$element.on("click." + this.type, this.options.selector, t.proxy(this.toggle, this));
            else if ("manual" != a) {
                var r = "hover" == a ? "mouseenter" : "focusin",
                    l = "hover" == a ? "mouseleave" : "focusout";
                this.$element.on(r + "." + this.type, this.options.selector, t.proxy(this.enter, this)), this.$element.on(l + "." + this.type, this.options.selector, t.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = t.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    }, i.prototype.getDefaults = function () {
        return i.DEFAULTS
    }, i.prototype.getOptions = function (e) {
        return e = t.extend({}, this.getDefaults(), this.$element.data(), e), e.delay && "number" == typeof e.delay && (e.delay = {
            show: e.delay,
            hide: e.delay
        }), e
    }, i.prototype.getDelegateOptions = function () {
        var e = {},
            i = this.getDefaults();
        return this._options && t.each(this._options, function (t, o) {
            i[t] != o && (e[t] = o)
        }), e
    }, i.prototype.enter = function (e) {
        var i = e instanceof this.constructor ? e : t(e.currentTarget).data("bs." + this.type);
        return i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i)), e instanceof t.Event && (i.inState["focusin" == e.type ? "focus" : "hover"] = !0), i.tip().hasClass("in") || "in" == i.hoverState ? void(i.hoverState = "in") : (clearTimeout(i.timeout), i.hoverState = "in", i.options.delay && i.options.delay.show ? void(i.timeout = setTimeout(function () {
            "in" == i.hoverState && i.show()
        }, i.options.delay.show)) : i.show())
    }, i.prototype.isInStateTrue = function () {
        for (var t in this.inState)
            if (this.inState[t]) return !0;
        return !1
    }, i.prototype.leave = function (e) {
        var i = e instanceof this.constructor ? e : t(e.currentTarget).data("bs." + this.type);
        return i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i)), e instanceof t.Event && (i.inState["focusout" == e.type ? "focus" : "hover"] = !1), i.isInStateTrue() ? void 0 : (clearTimeout(i.timeout), i.hoverState = "out", i.options.delay && i.options.delay.hide ? void(i.timeout = setTimeout(function () {
            "out" == i.hoverState && i.hide()
        }, i.options.delay.hide)) : i.hide())
    }, i.prototype.show = function () {
        var e = t.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var o = t.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !o) return;
            var n = this,
                s = this.tip(),
                a = this.getUID(this.type);
            this.setContent(), s.attr("id", a), this.$element.attr("aria-describedby", a), this.options.animation && s.addClass("fade");
            var r = "function" == typeof this.options.placement ? this.options.placement.call(this, s[0], this.$element[0]) : this.options.placement,
                l = /\s?auto?\s?/i,
                h = l.test(r);
            h && (r = r.replace(l, "") || "top"), s.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(r).data("bs." + this.type, this), this.options.container ? s.appendTo(this.options.container) : s.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);
            var d = this.getPosition(),
                p = s[0].offsetWidth,
                c = s[0].offsetHeight;
            if (h) {
                var f = r,
                    u = this.getPosition(this.$viewport);
                r = "bottom" == r && d.bottom + c > u.bottom ? "top" : "top" == r && d.top - c < u.top ? "bottom" : "right" == r && d.right + p > u.width ? "left" : "left" == r && d.left - p < u.left ? "right" : r, s.removeClass(f).addClass(r)
            }
            var g = this.getCalculatedOffset(r, d, p, c);
            this.applyPlacement(g, r);
            var m = function () {
                var t = n.hoverState;
                n.$element.trigger("shown.bs." + n.type), n.hoverState = null, "out" == t && n.leave(n)
            };
            t.support.transition && this.$tip.hasClass("fade") ? s.one("bsTransitionEnd", m).emulateTransitionEnd(i.TRANSITION_DURATION) : m()
        }
    }, i.prototype.applyPlacement = function (e, i) {
        var o = this.tip(),
            n = o[0].offsetWidth,
            s = o[0].offsetHeight,
            a = parseInt(o.css("margin-top"), 10),
            r = parseInt(o.css("margin-left"), 10);
        isNaN(a) && (a = 0), isNaN(r) && (r = 0), e.top += a, e.left += r, t.offset.setOffset(o[0], t.extend({
            using: function (t) {
                o.css({
                    top: Math.round(t.top),
                    left: Math.round(t.left)
                })
            }
        }, e), 0), o.addClass("in");
        var l = o[0].offsetWidth,
            h = o[0].offsetHeight;
        "top" == i && h != s && (e.top = e.top + s - h);
        var d = this.getViewportAdjustedDelta(i, e, l, h);
        d.left ? e.left += d.left : e.top += d.top;
        var p = /top|bottom/.test(i),
            c = p ? 2 * d.left - n + l : 2 * d.top - s + h,
            f = p ? "offsetWidth" : "offsetHeight";
        o.offset(e), this.replaceArrow(c, o[0][f], p)
    }, i.prototype.replaceArrow = function (t, e, i) {
        this.arrow().css(i ? "left" : "top", 50 * (1 - t / e) + "%").css(i ? "top" : "left", "")
    }, i.prototype.setContent = function () {
        var t = this.tip(),
            e = this.getTitle();
        t.find(".tooltip-inner")[this.options.html ? "html" : "text"](e), t.removeClass("fade in top bottom left right")
    }, i.prototype.hide = function (e) {
        function o() {
            "in" != n.hoverState && s.detach(), n.$element.removeAttr("aria-describedby").trigger("hidden.bs." + n.type), e && e()
        }
        var n = this,
            s = t(this.$tip),
            a = t.Event("hide.bs." + this.type);
        return this.$element.trigger(a), a.isDefaultPrevented() ? void 0 : (s.removeClass("in"), t.support.transition && s.hasClass("fade") ? s.one("bsTransitionEnd", o).emulateTransitionEnd(i.TRANSITION_DURATION) : o(), this.hoverState = null, this)
    }, i.prototype.fixTitle = function () {
        var t = this.$element;
        (t.attr("title") || "string" != typeof t.attr("data-original-title")) && t.attr("data-original-title", t.attr("title") || "").attr("title", "")
    }, i.prototype.hasContent = function () {
        return this.getTitle()
    }, i.prototype.getPosition = function (e) {
        e = e || this.$element;
        var i = e[0],
            o = "BODY" == i.tagName,
            n = i.getBoundingClientRect();
        null == n.width && (n = t.extend({}, n, {
            width: n.right - n.left,
            height: n.bottom - n.top
        }));
        var s = o ? {
                top: 0,
                left: 0
            } : e.offset(),
            a = {
                scroll: o ? document.documentElement.scrollTop || document.body.scrollTop : e.scrollTop()
            },
            r = o ? {
                width: t(window).width(),
                height: t(window).height()
            } : null;
        return t.extend({}, n, a, r, s)
    }, i.prototype.getCalculatedOffset = function (t, e, i, o) {
        return "bottom" == t ? {
            top: e.top + e.height,
            left: e.left + e.width / 2 - i / 2
        } : "top" == t ? {
            top: e.top - o,
            left: e.left + e.width / 2 - i / 2
        } : "left" == t ? {
            top: e.top + e.height / 2 - o / 2,
            left: e.left - i
        } : {
            top: e.top + e.height / 2 - o / 2,
            left: e.left + e.width
        }
    }, i.prototype.getViewportAdjustedDelta = function (t, e, i, o) {
        var n = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return n;
        var s = this.options.viewport && this.options.viewport.padding || 0,
            a = this.getPosition(this.$viewport);
        if (/right|left/.test(t)) {
            var r = e.top - s - a.scroll,
                l = e.top + s - a.scroll + o;
            r < a.top ? n.top = a.top - r : l > a.top + a.height && (n.top = a.top + a.height - l)
        } else {
            var h = e.left - s,
                d = e.left + s + i;
            h < a.left ? n.left = a.left - h : d > a.right && (n.left = a.left + a.width - d)
        }
        return n
    }, i.prototype.getTitle = function () {
        var t, e = this.$element,
            i = this.options;
        return t = e.attr("data-original-title") || ("function" == typeof i.title ? i.title.call(e[0]) : i.title)
    }, i.prototype.getUID = function (t) {
        do t += ~~(1e6 * Math.random()); while (document.getElementById(t));
        return t
    }, i.prototype.tip = function () {
        if (!this.$tip && (this.$tip = t(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip
    }, i.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }, i.prototype.enable = function () {
        this.enabled = !0
    }, i.prototype.disable = function () {
        this.enabled = !1
    }, i.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled
    }, i.prototype.toggle = function (e) {
        var i = this;
        e && (i = t(e.currentTarget).data("bs." + this.type), i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i))), e ? (i.inState.click = !i.inState.click, i.isInStateTrue() ? i.enter(i) : i.leave(i)) : i.tip().hasClass("in") ? i.leave(i) : i.enter(i)
    }, i.prototype.destroy = function () {
        var t = this;
        clearTimeout(this.timeout), this.hide(function () {
            t.$element.off("." + t.type).removeData("bs." + t.type), t.$tip && t.$tip.detach(), t.$tip = null, t.$arrow = null, t.$viewport = null
        })
    };
    var o = t.fn.tooltip;
    t.fn.tooltip = e, t.fn.tooltip.Constructor = i, t.fn.tooltip.noConflict = function () {
        return t.fn.tooltip = o, this
    }
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var o = t(this),
                n = o.data("bs.popover"),
                s = "object" == typeof e && e;
            (n || !/destroy|hide/.test(e)) && (n || o.data("bs.popover", n = new i(this, s)), "string" == typeof e && n[e]())
        })
    }
    var i = function (t, e) {
        this.init("popover", t, e)
    };
    if (!t.fn.tooltip) throw new Error("Popover requires tooltip.js");
    i.VERSION = "3.3.5", i.DEFAULTS = t.extend({}, t.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), i.prototype = t.extend({}, t.fn.tooltip.Constructor.prototype), i.prototype.constructor = i, i.prototype.getDefaults = function () {
        return i.DEFAULTS
    }, i.prototype.setContent = function () {
        var t = this.tip(),
            e = this.getTitle(),
            i = this.getContent();
        t.find(".popover-title")[this.options.html ? "html" : "text"](e), t.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof i ? "html" : "append" : "text"](i), t.removeClass("fade top bottom left right in"), t.find(".popover-title").html() || t.find(".popover-title").hide()
    }, i.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
    }, i.prototype.getContent = function () {
        var t = this.$element,
            e = this.options;
        return t.attr("data-content") || ("function" == typeof e.content ? e.content.call(t[0]) : e.content)
    }, i.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    };
    var o = t.fn.popover;
    t.fn.popover = e, t.fn.popover.Constructor = i, t.fn.popover.noConflict = function () {
        return t.fn.popover = o, this
    }
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var o = t(this),
                n = o.data("bs.tab");
            n || o.data("bs.tab", n = new i(this)), "string" == typeof e && n[e]()
        })
    }
    var i = function (e) {
        this.element = t(e)
    };
    i.VERSION = "3.3.5", i.TRANSITION_DURATION = 150, i.prototype.show = function () {
        var e = this.element,
            i = e.closest("ul:not(.dropdown-menu)"),
            o = e.data("target");
        if (o || (o = e.attr("href"), o = o && o.replace(/.*(?=#[^\s]*$)/, "")), !e.parent("li").hasClass("active")) {
            var n = i.find(".active:last a"),
                s = t.Event("hide.bs.tab", {
                    relatedTarget: e[0]
                }),
                a = t.Event("show.bs.tab", {
                    relatedTarget: n[0]
                });
            if (n.trigger(s), e.trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) {
                var r = t(o);
                this.activate(e.closest("li"), i), this.activate(r, r.parent(), function () {
                    n.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: e[0]
                    }), e.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: n[0]
                    })
                })
            }
        }
    }, i.prototype.activate = function (e, o, n) {
        function s() {
            a.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), e.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), r ? (e[0].offsetWidth, e.addClass("in")) : e.removeClass("fade"), e.parent(".dropdown-menu").length && e.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), n && n()
        }
        var a = o.find("> .active"),
            r = n && t.support.transition && (a.length && a.hasClass("fade") || !!o.find("> .fade").length);
        a.length && r ? a.one("bsTransitionEnd", s).emulateTransitionEnd(i.TRANSITION_DURATION) : s(), a.removeClass("in")
    };
    var o = t.fn.tab;
    t.fn.tab = e, t.fn.tab.Constructor = i, t.fn.tab.noConflict = function () {
        return t.fn.tab = o, this
    };
    var n = function (i) {
        i.preventDefault(), e.call(t(this), "show")
    };
    t(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', n).on("click.bs.tab.data-api", '[data-toggle="pill"]', n)
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var o = t(this),
                n = o.data("bs.affix"),
                s = "object" == typeof e && e;
            n || o.data("bs.affix", n = new i(this, s)), "string" == typeof e && n[e]()
        })
    }
    var i = function (e, o) {
        this.options = t.extend({}, i.DEFAULTS, o), this.$target = t(this.options.target).on("scroll.bs.affix.data-api", t.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", t.proxy(this.checkPositionWithEventLoop, this)), this.$element = t(e), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition()
    };
    i.VERSION = "3.3.5", i.RESET = "affix affix-top affix-bottom", i.DEFAULTS = {
        offset: 0,
        target: window
    }, i.prototype.getState = function (t, e, i, o) {
        var n = this.$target.scrollTop(),
            s = this.$element.offset(),
            a = this.$target.height();
        if (null != i && "top" == this.affixed) return i > n ? "top" : !1;
        if ("bottom" == this.affixed) return null != i ? n + this.unpin <= s.top ? !1 : "bottom" : t - o >= n + a ? !1 : "bottom";
        var r = null == this.affixed,
            l = r ? n : s.top,
            h = r ? a : e;
        return null != i && i >= n ? "top" : null != o && l + h >= t - o ? "bottom" : !1
    }, i.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(i.RESET).addClass("affix");
        var t = this.$target.scrollTop(),
            e = this.$element.offset();
        return this.pinnedOffset = e.top - t
    }, i.prototype.checkPositionWithEventLoop = function () {
        setTimeout(t.proxy(this.checkPosition, this), 1)
    }, i.prototype.checkPosition = function () {
        if (this.$element.is(":visible")) {
            var e = this.$element.height(),
                o = this.options.offset,
                n = o.top,
                s = o.bottom,
                a = Math.max(t(document).height(), t(document.body).height());
            "object" != typeof o && (s = n = o), "function" == typeof n && (n = o.top(this.$element)), "function" == typeof s && (s = o.bottom(this.$element));
            var r = this.getState(a, e, n, s);
            if (this.affixed != r) {
                null != this.unpin && this.$element.css("top", "");
                var l = "affix" + (r ? "-" + r : ""),
                    h = t.Event(l + ".bs.affix");
                if (this.$element.trigger(h), h.isDefaultPrevented()) return;
                this.affixed = r, this.unpin = "bottom" == r ? this.getPinnedOffset() : null, this.$element.removeClass(i.RESET).addClass(l).trigger(l.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == r && this.$element.offset({
                top: a - e - s
            })
        }
    };
    var o = t.fn.affix;
    t.fn.affix = e, t.fn.affix.Constructor = i, t.fn.affix.noConflict = function () {
        return t.fn.affix = o, this
    }, t(window).on("load", function () {
        t('[data-spy="affix"]').each(function () {
            var i = t(this),
                o = i.data();
            o.offset = o.offset || {}, null != o.offsetBottom && (o.offset.bottom = o.offsetBottom), null != o.offsetTop && (o.offset.top = o.offsetTop), e.call(i, o)
        })
    })
}(jQuery), + function (t) {
    "use strict";

    function e(e) {
        var i, o = e.attr("data-target") || (i = e.attr("href")) && i.replace(/.*(?=#[^\s]+$)/, "");
        return t(o)
    }

    function i(e) {
        return this.each(function () {
            var i = t(this),
                n = i.data("bs.collapse"),
                s = t.extend({}, o.DEFAULTS, i.data(), "object" == typeof e && e);
            !n && s.toggle && /show|hide/.test(e) && (s.toggle = !1), n || i.data("bs.collapse", n = new o(this, s)), "string" == typeof e && n[e]()
        })
    }
    var o = function (e, i) {
        this.$element = t(e), this.options = t.extend({}, o.DEFAULTS, i), this.$trigger = t('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle()
    };
    o.VERSION = "3.3.5", o.TRANSITION_DURATION = 350, o.DEFAULTS = {
        toggle: !0
    }, o.prototype.dimension = function () {
        var t = this.$element.hasClass("width");
        return t ? "width" : "height"
    }, o.prototype.show = function () {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var e, n = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(n && n.length && (e = n.data("bs.collapse"), e && e.transitioning))) {
                var s = t.Event("show.bs.collapse");
                if (this.$element.trigger(s), !s.isDefaultPrevented()) {
                    n && n.length && (i.call(n, "hide"), e || n.data("bs.collapse", null));
                    var a = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[a](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var r = function () {
                        this.$element.removeClass("collapsing").addClass("collapse in")[a](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse")
                    };
                    if (!t.support.transition) return r.call(this);
                    var l = t.camelCase(["scroll", a].join("-"));
                    this.$element.one("bsTransitionEnd", t.proxy(r, this)).emulateTransitionEnd(o.TRANSITION_DURATION)[a](this.$element[0][l]);
                }
            }
        }
    }, o.prototype.hide = function () {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var e = t.Event("hide.bs.collapse");
            if (this.$element.trigger(e), !e.isDefaultPrevented()) {
                var i = this.dimension();
                this.$element[i](this.$element[i]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var n = function () {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                };
                return t.support.transition ? void this.$element[i](0).one("bsTransitionEnd", t.proxy(n, this)).emulateTransitionEnd(o.TRANSITION_DURATION) : n.call(this)
            }
        }
    }, o.prototype.toggle = function () {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }, o.prototype.getParent = function () {
        return t(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(t.proxy(function (i, o) {
            var n = t(o);
            this.addAriaAndCollapsedClass(e(n), n)
        }, this)).end()
    }, o.prototype.addAriaAndCollapsedClass = function (t, e) {
        var i = t.hasClass("in");
        t.attr("aria-expanded", i), e.toggleClass("collapsed", !i).attr("aria-expanded", i)
    };
    var n = t.fn.collapse;
    t.fn.collapse = i, t.fn.collapse.Constructor = o, t.fn.collapse.noConflict = function () {
        return t.fn.collapse = n, this
    }, t(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (o) {
        var n = t(this);
        n.attr("data-target") || o.preventDefault();
        var s = e(n),
            a = s.data("bs.collapse"),
            r = a ? "toggle" : n.data();
        i.call(s, r)
    })
}(jQuery), + function (t) {
    "use strict";

    function e(i, o) {
        this.$body = t(document.body), this.$scrollElement = t(t(i).is(document.body) ? window : i), this.options = t.extend({}, e.DEFAULTS, o), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", t.proxy(this.process, this)), this.refresh(), this.process()
    }

    function i(i) {
        return this.each(function () {
            var o = t(this),
                n = o.data("bs.scrollspy"),
                s = "object" == typeof i && i;
            n || o.data("bs.scrollspy", n = new e(this, s)), "string" == typeof i && n[i]()
        })
    }
    e.VERSION = "3.3.5", e.DEFAULTS = {
        offset: 10
    }, e.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }, e.prototype.refresh = function () {
        var e = this,
            i = "offset",
            o = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), t.isWindow(this.$scrollElement[0]) || (i = "position", o = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {
            var e = t(this),
                n = e.data("target") || e.attr("href"),
                s = /^#./.test(n) && t(n);
            return s && s.length && s.is(":visible") && [
                [s[i]().top + o, n]
            ] || null
        }).sort(function (t, e) {
            return t[0] - e[0]
        }).each(function () {
            e.offsets.push(this[0]), e.targets.push(this[1])
        })
    }, e.prototype.process = function () {
        var t, e = this.$scrollElement.scrollTop() + this.options.offset,
            i = this.getScrollHeight(),
            o = this.options.offset + i - this.$scrollElement.height(),
            n = this.offsets,
            s = this.targets,
            a = this.activeTarget;
        if (this.scrollHeight != i && this.refresh(), e >= o) return a != (t = s[s.length - 1]) && this.activate(t);
        if (a && e < n[0]) return this.activeTarget = null, this.clear();
        for (t = n.length; t--;) a != s[t] && e >= n[t] && (void 0 === n[t + 1] || e < n[t + 1]) && this.activate(s[t])
    }, e.prototype.activate = function (e) {
        this.activeTarget = e, this.clear();
        var i = this.selector + '[data-target="' + e + '"],' + this.selector + '[href="' + e + '"]',
            o = t(i).parents("li").addClass("active");
        o.parent(".dropdown-menu").length && (o = o.closest("li.dropdown").addClass("active")), o.trigger("activate.bs.scrollspy")
    }, e.prototype.clear = function () {
        t(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    };
    var o = t.fn.scrollspy;
    t.fn.scrollspy = i, t.fn.scrollspy.Constructor = e, t.fn.scrollspy.noConflict = function () {
        return t.fn.scrollspy = o, this
    }, t(window).on("load.bs.scrollspy.data-api", function () {
        t('[data-spy="scroll"]').each(function () {
            var e = t(this);
            i.call(e, e.data())
        })
    })
}(jQuery), + function (t) {
    "use strict";

    function e() {
        var t = document.createElement("bootstrap"),
            e = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd otransitionend",
                transition: "transitionend"
            };
        for (var i in e)
            if (void 0 !== t.style[i]) return {
                end: e[i]
            };
        return !1
    }
    t.fn.emulateTransitionEnd = function (e) {
        var i = !1,
            o = this;
        t(this).one("bsTransitionEnd", function () {
            i = !0
        });
        var n = function () {
            i || t(o).trigger(t.support.transition.end)
        };
        return setTimeout(n, e), this
    }, t(function () {
        t.support.transition = e(), t.support.transition && (t.event.special.bsTransitionEnd = {
            bindType: t.support.transition.end,
            delegateType: t.support.transition.end,
            handle: function (e) {
                return t(e.target).is(this) ? e.handleObj.handler.apply(this, arguments) : void 0
            }
        })
    })
}(jQuery);
! function (a, b, c, d) {
    function e(b, c) {
        b.owlCarousel = {
            name: "Owl Carousel",
            author: "Bartosz Wojciechowski",
            version: "2.0.0-beta.2.1"
        }, this.options = a.extend({}, m, c), this._options = a.extend({}, m, this.options), this.itemData = a.extend({}, n), this.dom = a.extend({}, o), this.width = a.extend({}, p), this.num = a.extend({}, q), this.pos = a.extend({}, r), this.drag = a.extend({}, s), this.speed = a.extend({}, t), this.state = a.extend({}, u), this.e = a.extend({}, v), this.dom.el = b, this.dom.$el = a(b), this.plugins = {};
        for (var d in e.Plugins) this.plugins[d] = new e.Plugins[d](this);
        this.suppressedEvents = {}, this.init()
    }

    function f(a) {
        var b, d, e = c.createElement("div"),
            f = a;
        for (b in f)
            if (d = f[b], "undefined" != typeof e.style[d]) return e = null, [d, b];
        return [!1]
    }

    function g() {
        return f(["transition", "WebkitTransition", "MozTransition", "OTransition"])[1]
    }

    function h() {
        return f(["transform", "WebkitTransform", "MozTransform", "OTransform", "msTransform"])[0]
    }

    function j() {
        return f(["perspective", "webkitPerspective", "MozPerspective", "OPerspective", "MsPerspective"])[0]
    }

    function k() {
        return "ontouchstart" in b || !!navigator.msMaxTouchPoints
    }

    function l() {
        return b.navigator.msPointerEnabled
    }
    var m = {
            items: 3,
            loop: !1,
            center: !1,
            mouseDrag: !0,
            touchDrag: !0,
            pullDrag: !0,
            freeDrag: !1,
            margin: 0,
            stagePadding: 0,
            merge: !1,
            mergeFit: !0,
            autoWidth: !1,
            startPosition: 0,
            URLhashListener: !1,
            nav: !1,
            navRewind: !0,
            navText: ["prev", "next"],
            slideBy: 1,
            dots: !0,
            dotsEach: !1,
            dotData: !1,
            smartSpeed: 250,
            fluidSpeed: !1,
            navSpeed: !1,
            dotsSpeed: !1,
            dragEndSpeed: !1,
            responsive: {},
            responsiveRefreshRate: 200,
            responsiveBaseElement: b,
            responsiveClass: !1,
            fallbackEasing: "swing",
            info: !1,
            nestedItemSelector: !1,
            itemElement: "div",
            stageElement: "div",
            navElement: "div",
            navContainer: !1,
            dotsContainer: !1,
            themeClass: "owl-theme",
            baseClass: "owl-carousel",
            itemClass: "owl-item",
            centerClass: "center",
            activeClass: "active",
            navContainerClass: "owl-nav",
            navClass: ["owl-prev", "owl-next"],
            controlsClass: "owl-controls",
            dotClass: "owl-dot",
            dotsClass: "owl-dots"
        },
        n = {
            index: !1,
            indexAbs: !1,
            posLeft: !1,
            clone: !1,
            active: !1,
            loaded: !1,
            lazyLoad: !1,
            current: !1,
            width: !1,
            center: !1,
            page: !1,
            hasVideo: !1,
            playVideo: !1
        },
        o = {
            el: null,
            $el: null,
            stage: null,
            $stage: null,
            oStage: null,
            $oStage: null,
            $items: null,
            $oItems: null,
            $cItems: null,
            $cc: null,
            $navPrev: null,
            $navNext: null,
            $page: null,
            $nav: null,
            $content: null
        },
        p = {
            el: 0,
            stage: 0,
            item: 0,
            prevWindow: 0,
            cloneLast: 0
        },
        q = {
            items: 0,
            oItems: 0,
            cItems: 0,
            active: 0,
            merged: [],
            nav: [],
            allPages: 0
        },
        r = {
            start: 0,
            max: 0,
            maxValue: 0,
            prev: 0,
            current: 0,
            currentAbs: 0,
            currentPage: 0,
            stage: 0,
            items: [],
            lsCurrent: 0
        },
        s = {
            start: 0,
            startX: 0,
            startY: 0,
            current: 0,
            currentX: 0,
            currentY: 0,
            offsetX: 0,
            offsetY: 0,
            distance: null,
            startTime: 0,
            endTime: 0,
            updatedX: 0,
            targetEl: null
        },
        t = {
            onDragEnd: 300,
            nav: 300,
            css2speed: 0
        },
        u = {
            isTouch: !1,
            isScrolling: !1,
            isSwiping: !1,
            direction: !1,
            inMotion: !1
        },
        v = {
            _onDragStart: null,
            _onDragMove: null,
            _onDragEnd: null,
            _transitionEnd: null,
            _resizer: null,
            _responsiveCall: null,
            _goToLoop: null,
            _checkVisibile: null
        };
    e.Plugins = {}, e.prototype.init = function () {
        if (this.trigger("initialize"), this.dom.$el.hasClass(this.options.baseClass) || this.dom.$el.addClass(this.options.baseClass), this.dom.$el.hasClass(this.options.themeClass) || this.dom.$el.addClass(this.options.themeClass), this.options.rtl && this.dom.$el.addClass("owl-rtl"), this.browserSupport(), this.sortOptions(), this.setResponsiveOptions(), this.options.autoWidth && this.state.imagesLoaded !== !0) {
            var a = this.dom.$el.find("img"),
                b = this.options.nestedItemSelector ? "." + this.options.nestedItemSelector : d,
                c = this.dom.$el.children(b).width();
            if (a.length && 0 >= c) return this.preloadAutoWidthImages(a), !1
        }
        this.width.prevWindow = this.windowWidth(), this.createStage(), this.fetchContent(), this.eventsCall(), this.addTriggerableEvents(), this.internalEvents(), this.dom.$el.addClass("owl-loading"), this.refresh(!0), this.dom.$el.removeClass("owl-loading").addClass("owl-loaded"), this.trigger("initialized")
    }, e.prototype.sortOptions = function () {
        var a = this.options.responsive;
        this.responsiveSorted = {};
        var b, c, d, e = [];
        for (b in a) e.push(b);
        for (e = e.sort(function (a, b) {
                return a - b
            }), c = 0; c < e.length; c++) d = e[c], this.responsiveSorted[d] = a[d]
    }, e.prototype.setResponsiveOptions = function () {
        if (this.options.responsive === !1) return !1; {
            var a, b, c, d, e = this.windowWidth();
            this.options.responsive
        }
        for (c in this._options) "responsive" !== c && (this.options[c] = this._options[c]);
        for (a in this.responsiveSorted)
            if (e >= a) {
                d = a;
                for (b in this.responsiveSorted[d]) this.options[b] = this.responsiveSorted[d][b]
            } this.num.breakpoint = d, this.options.responsiveClass && this.dom.$el.attr("class", function (a, b) {
            return b.replace(/\b owl-responsive-\S+/g, "")
        }).addClass("owl-responsive-" + d)
    }, e.prototype.optionsLogic = function () {
        this.dom.$el.toggleClass("owl-center", this.options.center), this.options.slideBy && "page" === this.options.slideBy ? this.options.slideBy = this.options.items : this.options.slideBy > this.options.items && (this.options.slideBy = this.options.items), this.options.loop && this.num.oItems < this.options.items && (this.options.loop = !1), this.num.oItems <= this.options.items && !this.options.center && (this.options.navRewind = !1), this.options.autoWidth && (this.options.stagePadding = !1, this.options.dotsEach = 1, this.options.merge = !1)
    }, e.prototype.createStage = function () {
        var b = c.createElement("div"),
            d = c.createElement(this.options.stageElement);
        b.className = "owl-stage-outer", d.className = "owl-stage", b.appendChild(d), this.dom.el.appendChild(b), this.dom.oStage = b, this.dom.$oStage = a(b), this.dom.stage = d, this.dom.$stage = a(d), b = null, d = null
    }, e.prototype.createItem = function () {
        var a = c.createElement(this.options.itemElement);
        return a.className = this.options.itemClass, a
    }, e.prototype.fetchContent = function (b) {
        this.dom.$content = b ? b instanceof jQuery ? b : a(b) : this.options.nestedItemSelector ? this.dom.$el.find("." + this.options.nestedItemSelector).not(".owl-stage-outer") : this.dom.$el.children().not(".owl-stage-outer"), this.num.oItems = this.dom.$content.length, 0 !== this.num.oItems && this.initStructure()
    }, e.prototype.initStructure = function () {
        this.createNormalStructure()
    }, e.prototype.createNormalStructure = function () {
        for (var a = 0; a < this.num.oItems; a++) {
            var b = this.fillItem(this.dom.$content, a);
            this.dom.$stage.append(b)
        }
        this.dom.$content = null
    }, e.prototype.createCustomStructure = function (b) {
        for (var c = 0; b > c; c++) {
            var d = this.createItem(),
                e = a(d);
            this.setData(e, !1), this.dom.$stage.append(e)
        }
    }, e.prototype.fillItem = function (b, c) {
        var d = this.createItem(),
            e = b[c] || b,
            f = this.traversContent(e);
        return this.setData(d, !1, f), a(d).append(e)
    }, e.prototype.traversContent = function (b) {
        var c, d, e = a(b);
        return this.options.dotData && (c = e.find("[data-dot]").andSelf().data("dot")), this.options.URLhashListener && (d = e.find("[data-hash]").andSelf().data("hash")), {
            dot: c || !1,
            hash: d || !1
        }
    }, e.prototype.setData = function (b, c, d) {
        var e = this.itemData;
        if (d) {
            var f = {
                dot: d.dot,
                hash: d.hash
            };
            e = a.extend({}, e, f)
        }
        c && (e = a.extend({}, e, c.data("owl-item"))), a(b).data("owl-item", e)
    }, e.prototype.updateLocalContent = function () {
        this.dom.$oItems = this.dom.$stage.find("." + this.options.itemClass).filter(function () {
            return a(this).data("owl-item").clone === !1
        }), this.num.oItems = this.dom.$oItems.length;
        for (var b = 0; b < this.num.oItems; b++) {
            var c = this.dom.$oItems.eq(b);
            c.data("owl-item").index = b
        }
    }, e.prototype.loopClone = function () {
        if (!this.options.loop || this.num.oItems < this.options.items) return !1;
        var b, c, d, e = this.options.items,
            f = this.num.oItems - 1;
        for (this.options.stagePadding && 1 === this.options.items && (e += 1), this.num.cItems = 2 * e, d = 0; e > d; d++) {
            var g = this.dom.$oItems.eq(d).clone(!0, !0),
                h = this.dom.$oItems.eq(f - d).clone(!0, !0);
            b = a(g[0]).addClass("cloned"), c = a(h[0]).addClass("cloned"), this.setData(b[0], g), this.setData(c[0], h), b.data("owl-item").clone = !0, c.data("owl-item").clone = !0, this.dom.$stage.append(b), this.dom.$stage.prepend(c), b = c = null
        }
        this.dom.$cItems = this.dom.$stage.find("." + this.options.itemClass).filter(function () {
            return a(this).data("owl-item").clone === !0
        })
    }, e.prototype.reClone = function () {
        null !== this.dom.$cItems && (this.dom.$cItems.remove(), this.dom.$cItems = null, this.num.cItems = 0), this.options.loop && this.loopClone()
    }, e.prototype.calculate = function () {
        var a, b, c, d = 0,
            e = 0;
        this.width.el = this.dom.$el.width() - 2 * this.options.stagePadding, this.width.view = this.dom.$el.width();
        var f = this.width.el - this.options.margin * (1 === this.options.items ? 0 : this.options.items - 1);
        for (this.width.el = this.width.el + this.options.margin, this.width.item = (f / this.options.items + this.options.margin).toFixed(3), this.dom.$items = this.dom.$stage.find(".owl-item"), this.num.items = this.dom.$items.length, this.options.autoWidth && this.dom.$items.css("width", ""), this.pos.items = [], this.num.merged = [], this.num.nav = [], c = this.options.rtl ? this.options.center ? -(this.width.el / 2) : 0 : this.options.center ? this.width.el / 2 : 0, this.width.mergeStage = 0, a = 0; a < this.num.items; a++) {
            if (this.options.merge) {
                var g = this.dom.$items.eq(a).find("[data-merge]").attr("data-merge") || 1;
                this.options.mergeFit && g > this.options.items && (g = this.options.items), this.num.merged.push(parseInt(g)), this.width.mergeStage += this.width.item * this.num.merged[a]
            } else this.num.merged.push(1);
            this.options.loop ? a >= this.num.cItems / 2 && a < this.num.cItems / 2 + this.num.oItems && this.num.nav.push(this.num.merged[a]) : this.num.nav.push(this.num.merged[a]);
            var h = this.width.item * this.num.merged[a];
            this.options.autoWidth && (h = this.dom.$items.eq(a).width() + this.options.margin, this.options.rtl ? this.dom.$items[a].style.marginLeft = this.options.margin + "px" : this.dom.$items[a].style.marginRight = this.options.margin + "px"), this.pos.items.push(c), this.dom.$items.eq(a).data("owl-item").posLeft = d, this.dom.$items.eq(a).data("owl-item").width = h, this.options.rtl ? (c += h, d += h) : (c -= h, d -= h), e -= Math.abs(h), this.options.center && (this.pos.items[a] = this.options.rtl ? this.pos.items[a] + h / 2 : this.pos.items[a] - h / 2)
        }
        this.width.stage = Math.abs(this.options.autoWidth ? this.options.center ? e : c : e);
        var i = this.num.oItems + this.num.cItems;
        for (b = 0; i > b; b++) this.dom.$items.eq(b).data("owl-item").indexAbs = b;
        this.setMinMax(), this.setSizes()
    }, e.prototype.setMinMax = function () {
        var a = this.dom.$oItems.eq(0).data("owl-item").indexAbs;
        if (this.pos.min = 0, this.pos.minValue = this.pos.items[a], this.options.loop || (this.pos.max = this.num.oItems - 1), this.options.loop && (this.pos.max = this.num.oItems + this.options.items), this.options.loop || this.options.center || (this.pos.max = this.num.oItems - this.options.items), this.options.loop && this.options.center && (this.pos.max = this.num.oItems + this.options.items), this.pos.maxValue = this.pos.items[this.pos.max], !this.options.loop && !this.options.center && this.options.autoWidth || this.options.merge && !this.options.center) {
            var b = this.options.rtl ? 1 : -1;
            for (i = 0; i < this.pos.items.length; i++) this.pos.items[i] * b < this.width.stage - this.width.el && (this.pos.max = i + 1);
            this.pos.maxValue = this.options.rtl ? this.width.stage - this.width.el : -(this.width.stage - this.width.el), this.pos.items[this.pos.max] = this.pos.maxValue
        }
        this.pos.loop = this.options.center ? this.pos.items[0] - this.pos.items[this.num.oItems] : -this.pos.items[this.num.oItems], this.num.oItems < this.options.items && !this.options.center && (this.pos.max = 0, this.pos.maxValue = this.pos.items[0])
    }, e.prototype.setSizes = function () {
        this.options.stagePadding !== !1 && (this.dom.oStage.style.paddingLeft = this.options.stagePadding + "px", this.dom.oStage.style.paddingRight = this.options.stagePadding + "px"), this.options.rtl ? b.setTimeout(function () {
            this.dom.stage.style.width = this.width.stage + "px"
        }.bind(this), 0) : this.dom.stage.style.width = this.width.stage + "px";
        for (var a = 0; a < this.num.items; a++) this.options.autoWidth || (this.dom.$items[a].style.width = this.width.item - this.options.margin + "px"), this.options.rtl ? this.dom.$items[a].style.marginLeft = this.options.margin + "px" : this.dom.$items[a].style.marginRight = this.options.margin + "px", 1 === this.num.merged[a] || this.options.autoWidth || (this.dom.$items[a].style.width = this.width.item * this.num.merged[a] - this.options.margin + "px");
        this.width.stagePrev = this.width.stage
    }, e.prototype.responsive = function () {
        if (!this.num.oItems) return !1;
        var a = this.isElWidthChanged();
        return a ? this.trigger("resize").isDefaultPrevented() ? !1 : (this.state.responsive = !0, this.refresh(), this.state.responsive = !1, void this.trigger("resized")) : !1
    }, e.prototype.refresh = function (a) {
        return this.trigger("refresh"), this.setResponsiveOptions(), this.updateLocalContent(), this.optionsLogic(), 0 === this.num.oItems ? (null !== this.dom.$page && this.dom.$page.hide(), !1) : (this.dom.$stage.addClass("owl-refresh"), this.reClone(), this.calculate(), this.dom.$stage.removeClass("owl-refresh"), this.initPosition(a), a || this.jumpTo(this.pos.current, !1), this.updateItemState(), this.rebuildDots(), this.updateControls(), this.state.orientation = b.orientation, this.watchVisibility(), void this.trigger("refreshed"))
    }, e.prototype.updateItemState = function () {
        this.trigger("update"), this.options.center && (this.dom.$items.eq(this.pos.currentAbs).addClass(this.options.centerClass).data("owl-item").center = !0), this.trigger("updated")
    }, e.prototype.updateActiveItems = function () {
        var a, b, c, d, e, f, g;
        for (a = 0; a < this.num.items; a++) this.dom.$items.eq(a).data("owl-item").active = !1, this.dom.$items.eq(a).data("owl-item").current = !1, this.dom.$items.eq(a).removeClass(this.options.activeClass).removeClass(this.options.centerClass);
        for (this.num.active = 0, stageX = this.pos.stage, view = this.options.rtl ? this.width.view : -this.width.view, b = 0; b < this.num.items; b++) c = this.dom.$items.eq(b), d = c.data("owl-item").posLeft, e = c.data("owl-item").width, f = this.options.rtl ? d + e : d - e, (this.op(d, "<=", stageX) && this.op(d, ">", stageX + view) || this.op(f, "<", stageX) && this.op(f, ">", stageX + view)) && (this.num.active++, this.options.freeDrag && !g && (g = !0, this.pos.current = c.data("owl-item").index, this.pos.currentAbs = c.data("owl-item").indexAbs), c.data("owl-item").active = !0, c.data("owl-item").current = !0, c.addClass(this.options.activeClass), this.options.lazyLoad || (c.data("owl-item").loaded = !0), this.options.loop && this.updateClonedItemsState(c.data("owl-item").index))
    }, e.prototype.updateClonedItemsState = function (a) {
        var b, c, d;
        for (this.options.center && (b = this.dom.$items.eq(this.pos.currentAbs).data("owl-item").index), d = 0; d < this.num.items; d++) c = this.dom.$items.eq(d), c.data("owl-item").index === a && (c.data("owl-item").current = !0, c.data("owl-item").index === b && c.addClass(this.options.centerClass))
    }, e.prototype.eventsCall = function () {
        this.e._onDragStart = function (a) {
            this.onDragStart(a)
        }.bind(this), this.e._onDragMove = function (a) {
            this.onDragMove(a)
        }.bind(this), this.e._onDragEnd = function (a) {
            this.onDragEnd(a)
        }.bind(this), this.e._transitionEnd = function (a) {
            this.transitionEnd(a)
        }.bind(this), this.e._resizer = function () {
            this.responsiveTimer()
        }.bind(this), this.e._responsiveCall = function () {
            this.responsive()
        }.bind(this), this.e._preventClick = function (a) {
            this.preventClick(a)
        }.bind(this), this.e._goToHash = function () {
            this.goToHash()
        }.bind(this), this.e._goToPage = function (a) {
            this.goToPage(a)
        }.bind(this), this.e._navNext = function (b) {
            return a(b.target).hasClass("disabled") ? !1 : (b.preventDefault(), void this.next())
        }.bind(this), this.e._navPrev = function (b) {
            return a(b.target).hasClass("disabled") ? !1 : (b.preventDefault(), void this.prev())
        }.bind(this)
    }, e.prototype.responsiveTimer = function () {
        return this.windowWidth() === this.width.prevWindow ? !1 : (b.clearTimeout(this.resizeTimer), this.resizeTimer = b.setTimeout(this.e._responsiveCall, this.options.responsiveRefreshRate), void(this.width.prevWindow = this.windowWidth()))
    }, e.prototype.internalEvents = function () {
        var a = k(),
            d = l();
        this.dragType = a && !d ? ["touchstart", "touchmove", "touchend", "touchcancel"] : a && d ? ["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel"] : ["mousedown", "mousemove", "mouseup"], (a || d) && this.options.touchDrag ? this.on(c, this.dragType[3], this.e._onDragEnd) : (this.dom.$stage.on("dragstart", function () {
            return !1
        }), this.options.mouseDrag ? this.dom.stage.onselectstart = function () {
            return !1
        } : this.dom.$el.addClass("owl-text-select-on")), this.options.URLhashListener && this.on(b, "hashchange", this.e._goToHash, !1), this.transitionEndVendor && this.on(this.dom.stage, this.transitionEndVendor, this.e._transitionEnd, !1), this.options.responsive !== !1 && this.on(b, "resize", this.e._resizer, !1), this.dragEvents()
    }, e.prototype.dragEvents = function () {
        !this.options.touchDrag || "touchstart" !== this.dragType[0] && "MSPointerDown" !== this.dragType[0] ? this.options.mouseDrag && "mousedown" === this.dragType[0] ? this.on(this.dom.stage, this.dragType[0], this.e._onDragStart, !1) : this.off(this.dom.stage, this.dragType[0], this.e._onDragStart) : this.on(this.dom.stage, this.dragType[0], this.e._onDragStart, !1)
    }, e.prototype.onDragStart = function (a) {
        var d = a.originalEvent || a || b.event;
        if (3 === d.which) return !1;
        "mousedown" === this.dragType[0] && this.dom.$stage.addClass("owl-grab"), this.trigger("drag"), this.drag.startTime = (new Date).getTime(), this.setSpeed(0), this.state.isTouch = !0, this.state.isScrolling = !1, this.state.isSwiping = !1, this.drag.distance = 0;
        var e = "touchstart" === d.type,
            f = e ? a.targetTouches[0].pageX : d.pageX || d.clientX,
            g = e ? a.targetTouches[0].pageY : d.pageY || d.clientY;
        if (this.drag.offsetX = this.dom.$stage.position().left - this.options.stagePadding, this.drag.offsetY = this.dom.$stage.position().top, this.options.rtl && (this.drag.offsetX = this.dom.$stage.position().left + this.width.stage - this.width.el + this.options.margin), this.state.inMotion && this.support3d) {
            var h = this.getTransformProperty();
            this.drag.offsetX = h, this.animStage(h)
        } else if (this.state.inMotion && !this.support3d) return this.state.inMotion = !1, !1;
        this.drag.startX = f - this.drag.offsetX, this.drag.startY = g - this.drag.offsetY, this.drag.start = f - this.drag.startX, this.drag.targetEl = d.target || d.srcElement, this.drag.updatedX = this.drag.start, ("IMG" === this.drag.targetEl.tagName || "A" === this.drag.targetEl.tagName) && (this.drag.targetEl.draggable = !1), this.on(c, this.dragType[1], this.e._onDragMove, !1), this.on(c, this.dragType[2], this.e._onDragEnd, !1)
    }, e.prototype.onDragMove = function (a) {
        if (this.state.isTouch && !this.state.isScrolling) {
            var c = a.originalEvent || a || b.event,
                e = "touchmove" == c.type,
                f = e ? c.targetTouches[0].pageX : c.pageX || c.clientX,
                g = e ? c.targetTouches[0].pageY : c.pageY || c.clientY;
            if (this.drag.currentX = f - this.drag.startX, this.drag.currentY = g - this.drag.startY, this.drag.distance = this.drag.currentX - this.drag.offsetX, this.drag.distance < 0 ? this.state.direction = this.options.rtl ? "right" : "left" : this.drag.distance > 0 && (this.state.direction = this.options.rtl ? "left" : "right"), this.options.loop) this.op(this.drag.currentX, ">", this.pos.minValue) && "right" === this.state.direction ? this.drag.currentX -= this.pos.loop : this.op(this.drag.currentX, "<", this.pos.maxValue) && "left" === this.state.direction && (this.drag.currentX += this.pos.loop);
            else {
                var h = this.options.rtl ? this.pos.maxValue : this.pos.minValue,
                    i = this.options.rtl ? this.pos.minValue : this.pos.maxValue,
                    j = this.options.pullDrag ? this.drag.distance / 5 : 0;
                this.drag.currentX = Math.max(Math.min(this.drag.currentX, h + j), i + j)
            }(this.drag.distance > 8 || this.drag.distance < -8) && (c.preventDefault !== d ? c.preventDefault() : c.returnValue = !1, this.state.isSwiping = !0), this.drag.updatedX = this.drag.currentX, (this.drag.currentY > 16 || this.drag.currentY < -16) && this.state.isSwiping === !1 && (this.state.isScrolling = !0, this.drag.updatedX = this.drag.start), this.animStage(this.drag.updatedX)
        }
    }, e.prototype.onDragEnd = function () {
        if (this.state.isTouch) {
            if ("mousedown" === this.dragType[0] && this.dom.$stage.removeClass("owl-grab"), this.trigger("dragged"), this.drag.targetEl.removeAttribute("draggable"), this.state.isTouch = !1, this.state.isScrolling = !1, this.state.isSwiping = !1, 0 === this.drag.distance && this.state.inMotion !== !0) return this.state.inMotion = !1, !1;
            this.drag.endTime = (new Date).getTime();
            var a = this.drag.endTime - this.drag.startTime,
                b = Math.abs(this.drag.distance);
            (b > 3 || a > 300) && this.removeClick(this.drag.targetEl);
            var d = this.closest(this.drag.updatedX);
            this.setSpeed(this.options.dragEndSpeed, !1, !0), this.animStage(this.pos.items[d]), this.options.pullDrag || this.drag.updatedX !== this.pos.items[d] || this.transitionEnd(), this.drag.distance = 0, this.off(c, this.dragType[1], this.e._onDragMove), this.off(c, this.dragType[2], this.e._onDragEnd)
        }
    }, e.prototype.removeClick = function (c) {
        this.drag.targetEl = c, a(c).on("click.preventClick", this.e._preventClick), b.setTimeout(function () {
            a(c).off("click.preventClick")
        }, 300)
    }, e.prototype.preventClick = function (b) {
        b.preventDefault ? b.preventDefault() : b.returnValue = !1, b.stopPropagation && b.stopPropagation(), a(b.target).off("click.preventClick")
    }, e.prototype.getTransformProperty = function () {
        var a = b.getComputedStyle(this.dom.stage, null).getPropertyValue(this.vendorName + "transform");
        a = a.replace(/matrix(3d)?\(|\)/g, "").split(",");
        var c = 16 === a.length;
        return c !== !0 ? a[4] : a[12]
    }, e.prototype.closest = function (a) {
        var b = 0,
            c = 30;
        if (!this.options.freeDrag)
            for (var d = 0; d < this.num.items; d++) a > this.pos.items[d] - c && a < this.pos.items[d] + c ? b = d : this.op(a, "<", this.pos.items[d]) && this.op(a, ">", this.pos.items[d + 1 || this.pos.items[d] - this.width.el]) && (b = "left" === this.state.direction ? d + 1 : d);
        return this.options.loop || (this.op(a, ">", this.pos.minValue) ? b = a = this.pos.min : this.op(a, "<", this.pos.maxValue) && (b = a = this.pos.max)), this.options.freeDrag ? (this.updateItemState(), a) : (this.pos.currentAbs = b, this.pos.current = this.dom.$items.eq(b).data("owl-item").index, b)
    }, e.prototype.animStage = function (a) {
        0 !== this.speed.current && this.pos.currentAbs !== this.pos.min && (this.trigger("translate"), this.state.inMotion = !0);
        var b = this.pos.stage = a,
            c = this.dom.stage.style;
        this.support3d ? (translate = "translate3d(" + b + "px,0px, 0px)", c[this.transformVendor] = translate) : this.state.isTouch ? c.left = b + "px" : this.dom.$stage.animate({
            left: b
        }, this.speed.css2speed, this.options.fallbackEasing, function () {
            this.state.inMotion && this.transitionEnd()
        }.bind(this)), this.onChange()
    }, e.prototype.updatePosition = function (a) {
        if (0 === this.num.oItems) return !1;
        if (a === d) return !1;
        var b = a;
        return this.pos.prev = this.pos.currentAbs, this.state.revert ? (this.pos.current = this.dom.$items.eq(b).data("owl-item").index, void(this.pos.currentAbs = b)) : (b = this.options.loop ? b >= this.num.oItems ? this.num.oItems - 1 : b : this.options.navRewind ? this.pos.current >= this.pos.max ? b > this.pos.max ? this.pos.min : 0 > b ? this.pos.max : b : b > this.pos.max ? this.pos.max : 0 > b ? this.pos.max : b : b > this.pos.max ? this.pos.max : 0 >= b ? 0 : b, this.pos.current = this.dom.$oItems.eq(b).data("owl-item").index, void(this.pos.currentAbs = this.dom.$oItems.eq(b).data("owl-item").indexAbs))
    }, e.prototype.setSpeed = function (a, b, c) {
        var e = a,
            f = b;
        if (e === !1 && 0 !== e && c !== !0 || e === d) {
            var g = Math.abs(f - this.pos.prev);
            g = 0 === g ? 1 : g, g > 6 && (g = 6), e = g * this.options.smartSpeed
        }
        if (e === !1 && c === !0 && (e = this.options.smartSpeed), 0 === e && (e = 0), this.support3d) {
            var h = this.dom.stage.style;
            h.webkitTransitionDuration = h.MsTransitionDuration = h.msTransitionDuration = h.MozTransitionDuration = h.OTransitionDuration = h.transitionDuration = e / 1e3 + "s"
        } else this.speed.css2speed = e;
        return this.speed.current = e, e
    }, e.prototype.jumpTo = function (a, b) {
        this.updatePosition(a), this.setSpeed(0), this.animStage(this.pos.items[this.pos.currentAbs]), b !== !0 && this.updateItemState()
    }, e.prototype.goTo = function (a, b) {
        this.updatePosition(a), this.setSpeed(b, this.pos.currentAbs), this.trigger("animate"), this.animStage(this.pos.items[this.pos.currentAbs])
    }, e.prototype.next = function (a) {
        var b = a || this.options.navSpeed;
        this.options.loop ? this.goToLoop(this.options.slideBy, b) : this.goTo(this.pos.current + this.options.slideBy, b)
    }, e.prototype.prev = function (a) {
        var b = a || this.options.navSpeed;
        this.options.loop ? this.goToLoop(-this.options.slideBy, b) : this.goTo(this.pos.current - this.options.slideBy, b)
    }, e.prototype.goToLoop = function (a, c) {
        var d = this.pos.currentAbs,
            e = this.pos.currentAbs,
            f = this.pos.currentAbs + a,
            g = 0 > e - f ? !0 : !1;
        this.state.revert = !0, f < this.options.items && g === !1 ? (this.state.bypass = !0, d = this.num.items - (this.options.items - e) - this.options.items, this.jumpTo(d, !0)) : f >= this.num.items - this.options.items && g === !0 && (this.state.bypass = !0, d = e - this.num.oItems, this.jumpTo(d, !0)), b.clearTimeout(this.e._goToLoop), this.e._goToLoop = b.setTimeout(function () {
            this.state.bypass = !1, this.goTo(d + a, c), this.state.revert = !1
        }.bind(this), 30)
    }, e.prototype.initPosition = function (a) {
        if (!this.dom.$oItems || !a) return !1;
        var b = this.options.startPosition;
        "URLHash" === this.options.startPosition ? b = this.options.startPosition = this.hashPosition() : typeof this.options.startPosition === Number || this.options.center || (this.options.startPosition = 0), this.dom.oStage.scrollLeft = 0, this.jumpTo(b, !0)
    }, e.prototype.goToHash = function () {
        var a = this.hashPosition();
        a === !1 && (a = 0), this.dom.oStage.scrollLeft = 0, this.goTo(a, this.options.navSpeed)
    }, e.prototype.hashPosition = function () {
        var a, c = b.location.hash.substring(1);
        if ("" === c) return !1;
        for (var d = 0; d < this.num.oItems; d++) c === this.dom.$oItems.eq(d).data("owl-item").hash && (a = d);
        return a
    }, e.prototype.transitionEnd = function (a) {
        if (a !== d) {
            a.stopPropagation();
            var b = a.target || a.srcElement || a.originalTarget;
            if (b !== this.dom.stage) return !1
        }
        this.state.inMotion = !1, this.updateItemState(), this.trigger("translated")
    }, e.prototype.isElWidthChanged = function () {
        var a = this.dom.$el.width() - this.options.stagePadding,
            b = this.width.el + this.options.margin;
        return a !== b
    }, e.prototype.windowWidth = function () {
        return this.options.responsiveBaseElement !== b ? this.width.window = a(this.options.responsiveBaseElement).width() : b.innerWidth ? this.width.window = b.innerWidth : c.documentElement && c.documentElement.clientWidth && (this.width.window = c.documentElement.clientWidth), this.width.window
    }, e.prototype.controls = function () {
        var b = c.createElement("div");
        b.className = this.options.controlsClass, this.dom.$el.append(b), this.dom.$cc = a(b)
    }, e.prototype.updateControls = function () {
        null === this.dom.$cc && (this.options.nav || this.options.dots) && (this.options.navContainer && this.options.dotsContainer || this.controls()), null === this.dom.$nav && this.options.nav && this.createNavigation(), null === this.dom.$page && this.options.dots && this.createDots(), null !== this.dom.$nav && (this.options.nav ? (this.dom.$nav.show(), this.updateNavigation()) : this.dom.$nav.hide()), null !== this.dom.$page && (this.options.dots ? (this.dom.$page.show(), this.updateDots()) : this.dom.$page.hide())
    }, e.prototype.createNavigation = function () {
        var b = this.options.navContainer ? a(this.options.navContainer).get(0) : this.dom.$cc.get(0),
            d = c.createElement("div");
        d.className = this.options.navContainerClass, b.appendChild(d);
        var e = c.createElement(this.options.navElement),
            f = c.createElement(this.options.navElement);
        e.className = this.options.navClass[0], f.className = this.options.navClass[1], d.appendChild(e), d.appendChild(f), this.dom.$nav = a(d), this.dom.$navPrev = a(e).html(this.options.navText[0]), this.dom.$navNext = a(f).html(this.options.navText[1]), this.dom.$nav.on(this.dragType[2], "." + this.options.navClass[0], this.e._navPrev), this.dom.$nav.on(this.dragType[2], "." + this.options.navClass[1], this.e._navNext)
    }, e.prototype.createDots = function () {
        function b(b) {
            b.preventDefault();
            var c = a(this).data("page");
            f.goTo(c, f.options.dotsSpeed)
        }
        var d = this.options.dotsContainer ? a(this.options.dotsContainer).get(0) : this.dom.$cc.get(0),
            e = c.createElement("div");
        e.className = this.options.dotsClass, d.appendChild(e), this.dom.$page = a(e);
        var f = this;
        this.dom.$page.on(this.dragType[2], "." + this.options.dotClass, b), this.rebuildDots()
    }, e.prototype.rebuildDots = function () {
        if (null === this.dom.$page) return !1;
        var b, d, e, f, g = 0,
            h = 0,
            i = 0,
            j = 0;
        for (b = this.options.dotsEach || this.options.items, (this.options.center || this.options.dotData) && (b = 1), this.dom.$page.html(""), f = 0; f < this.num.nav.length; f++) {
            if (g >= b || 0 === g) {
                d = c.createElement("div"), d.className = this.options.dotClass, e = c.createElement("span"), d.appendChild(e);
                var k = a(d);
                this.options.dotData && k.html(this.dom.$oItems.eq(f).data("owl-item").dot), k.data("page", i), k.data("goToPage", j), this.dom.$page.append(d), g = 0, j++
            }
            this.dom.$oItems.eq(f).data("owl-item").page = j - 1, g += this.num.nav[f], i++
        }
        if (!this.options.loop && !this.options.center)
            for (var l = this.num.nav.length - 1; l >= 0 && (h += this.num.nav[l], this.dom.$oItems.eq(l).data("owl-item").page = j - 1, !(h >= b)); l--);
        this.num.allPages = j - 1
    }, e.prototype.updateDots = function () {
        for (var a = this.dom.$page.children(), b = this.dom.$oItems.eq(this.pos.current).data("owl-item").page, c = 0; c < a.length; c++) {
            var d = a.eq(c).data("goToPage");
            d === b ? (this.pos.currentPage = c, a.eq(c).addClass("active")) : a.eq(c).removeClass("active")
        }
    }, e.prototype.updateNavigation = function () {
        var a = this.options.nav;
        this.dom.$navNext.toggleClass("disabled", !a), this.dom.$navPrev.toggleClass("disabled", !a), this.options.loop || !a || this.options.navRewind || (this.pos.current <= 0 && this.dom.$navPrev.addClass("disabled"), this.pos.current >= this.pos.max && this.dom.$navNext.addClass("disabled"))
    }, e.prototype.insertContent = function (a) {
        this.dom.$stage.empty(), this.fetchContent(a), this.refresh()
    }, e.prototype.addItem = function (a, b) {
        b = b || 0;
        var c = this.fillItem(a);
        if (0 === this.dom.$oItems.length) this.dom.$stage.append(c);
        else {
            var d = this.dom.$oItems.eq(b); - 1 !== b ? d.before(c) : d.after(c)
        }
        this.refresh()
    }, e.prototype.removeItem = function (a) {
        this.dom.$oItems.eq(a).remove(), this.refresh()
    }, e.prototype.addTriggerableEvents = function () {
        var b = a.proxy(function (b, c) {
            return a.proxy(function () {
                this.suppressedEvents[c] = !0, b.apply(this, [].slice.call(arguments, 1)), delete this.suppressedEvents[c]
            }, this)
        }, this);
        a.each({
            next: this.next,
            prev: this.prev,
            to: this.goTo,
            destroy: this.destroy,
            refresh: this.refresh,
            replace: this.insertContent,
            add: this.addItem,
            remove: this.removeItem
        }, a.proxy(function (a, c) {
            this.dom.$el.on(a + ".owl.carousel", b(c, a + ".owl.carousel"))
        }, this))
    }, e.prototype.watchVisibility = function () {
        function a(a) {
            return a.offsetWidth > 0 && a.offsetHeight > 0
        }

        function c() {
            a(this.dom.el) && (this.dom.$el.removeClass("owl-hidden"), this.refresh(), b.clearInterval(this.e._checkVisibile))
        }
        a(this.dom.el) || (this.dom.$el.addClass("owl-hidden"), b.clearInterval(this.e._checkVisibile), this.e._checkVisibile = b.setInterval(c.bind(this), 500))
    }, e.prototype.onChange = function () {
        this.state.isTouch || this.state.bypass || this.state.responsive || (this.options.nav || this.options.dots) && this.updateControls(), this.state.isTouch || this.state.bypass || (this.updateActiveItems(), this.storeInfo(), this.trigger("changed"))
    }, e.prototype.storeInfo = function () {
        this.info = {
            items: this.options.items,
            allItems: this.num.oItems,
            currentPosition: this.pos.current,
            currentPage: this.pos.currentPage,
            allPages: this.num.allPages,
            windowWidth: this.width.window,
            elWidth: this.width.el,
            breakpoint: this.num.breakpoint
        }, "function" == typeof this.options.info && this.options.info.apply(this, [this.info, this.dom.el])
    }, e.prototype.preloadAutoWidthImages = function (b) {
        var c = 0,
            d = this;
        b.each(function (e, f) {
            var g = a(f),
                h = new Image;
            h.onload = function () {
                c++, g.attr("src", h.src), g.css("opacity", 1), c >= b.length && (d.state.imagesLoaded = !0, d.init())
            }, h.src = g.attr("src") || g.attr("data-src") || g.attr("data-src-retina")
        })
    }, e.prototype.destroy = function () {
        this.dom.$el.hasClass(this.options.themeClass) && this.dom.$el.removeClass(this.options.themeClass), this.options.responsive !== !1 && this.off(b, "resize", this.e._resizer), this.transitionEndVendor && this.off(this.dom.stage, this.transitionEndVendor, this.e._transitionEnd);
        for (var a in this.plugins) this.plugins[a].destroy();
        (this.options.mouseDrag || this.options.touchDrag) && (this.off(this.dom.stage, this.dragType[0], this.e._onDragStart), this.options.mouseDrag && this.off(c, this.dragType[3], this.e._onDragStart), this.options.mouseDrag && (this.dom.$stage.off("dragstart", function () {
            return !1
        }), this.dom.stage.onselectstart = function () {})), this.options.URLhashListener && this.off(b, "hashchange", this.e._goToHash), this.dom.$el.off(".owl"), null !== this.dom.$cc && this.dom.$cc.remove(), null !== this.dom.$cItems && this.dom.$cItems.remove(), this.e = null, this.dom.$el.data("owlCarousel", null), delete this.dom.el.owlCarousel, this.dom.$stage.unwrap(), this.dom.$items.unwrap(), this.dom.$items.contents().unwrap(), this.dom = null
    }, e.prototype.op = function (a, b, c) {
        var d = this.options.rtl;
        switch (b) {
            case "<":
                return d ? a > c : c > a;
            case ">":
                return d ? c > a : a > c;
            case ">=":
                return d ? c >= a : a >= c;
            case "<=":
                return d ? a >= c : c >= a
        }
    }, e.prototype.on = function (a, b, c, d) {
        a.addEventListener ? a.addEventListener(b, c, d) : a.attachEvent && a.attachEvent("on" + b, c)
    }, e.prototype.off = function (a, b, c, d) {
        a.removeEventListener ? a.removeEventListener(b, c, d) : a.detachEvent && a.detachEvent("on" + b, c)
    }, e.prototype.trigger = function (b, c, d) {
        var e = a.camelCase(a.grep(["on", b, d], function (a) {
                return a
            }).join("-").toLowerCase()),
            f = a.Event([b, "owl", d || "carousel"].join(".").toLowerCase(), c);
        return f.data = a.extend(this.info, c), this.suppressedEvents[f.type] || this.dom.$el.trigger(f), "function" == typeof this.options[e] && this.options[e].apply(this, f), f
    }, e.prototype.browserSupport = function () {
        if (this.support3d = j(), this.support3d) {
            this.transformVendor = h();
            var a = ["transitionend", "webkitTransitionEnd", "transitionend", "oTransitionEnd"];
            this.transitionEndVendor = a[g()], this.vendorName = this.transformVendor.replace(/Transform/i, ""), this.vendorName = "" !== this.vendorName ? "-" + this.vendorName.toLowerCase() + "-" : ""
        }
        this.state.orientation = b.orientation
    }, a.fn.owlCarousel = function (b) {
        return this.each(function () {
            a(this).data("owlCarousel") || a(this).data("owlCarousel", new e(this, b))
        })
    }, a.fn.owlCarousel.Constructor = e
}(window.Zepto || window.jQuery, window, document), Function.prototype.bind || (Function.prototype.bind = function (a) {
        if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        var b = Array.prototype.slice.call(arguments, 1),
            c = this,
            d = function () {},
            e = function () {
                return c.apply(this instanceof d && a ? this : a, b.concat(Array.prototype.slice.call(arguments)))
            };
        return d.prototype = this.prototype, e.prototype = new d, e
    }),
    function (a, b) {
        LazyLoad = function (b) {
            this.owl = b, this.owl.options = a.extend({}, LazyLoad.Defaults, this.owl.options), this.owl.dom.$el.on({
                "updated.owl.carousel": a.proxy(function () {
                    this.owl.options.lazyLoad && this.check()
                }, this)
            })
        }, LazyLoad.Defaults = {
            lazyLoad: !1
        }, LazyLoad.prototype.check = function () {
            var a, c, d, e = b.devicePixelRatio > 1 ? "data-src-retina" : "data-src";
            for (d = 0; d < this.owl.num.items; d++) {
                var f = this.owl.dom.$items.eq(d);
                f.data("owl-item").current === !0 && f.data("owl-item").loaded === !1 && (c = f.find(".owl-lazy"), a = c.attr(e), a = a || c.attr("data-src"), a && (c.css("opacity", "0"), this.preload(c, f)))
            }
        }, LazyLoad.prototype.preload = function (c, d) {
            c.each(a.proxy(function (c, e) {
                this.owl.trigger("load", null, "lazy");
                var f = a(e),
                    g = new Image,
                    h = f.attr(b.devicePixelRatio > 1 ? "data-src-retina" : "data-src");
                h = h || f.attr("data-src"), g.onload = a.proxy(function () {
                    d.data("owl-item").loaded = !0, f.is("img") ? f.attr("src", g.src) : f.css("background-image", "url(" + g.src + ")"), f.css("opacity", 1), this.owl.trigger("loaded", null, "lazy")
                }, this), g.src = h
            }, this))
        }, LazyLoad.prototype.destroy = function () {
            this.owl.dom.$el.off(".owl")
        }, a.fn.owlCarousel.Constructor.Plugins.lazyLoad = LazyLoad
    }(window.Zepto || window.jQuery, window, document),
    function (a, b) {
        AutoHeight = function (b) {
            this.owl = b, this.owl.options = a.extend({}, AutoHeight.Defaults, this.owl.options), this.owl.dom.$el.on({
                "refreshed.owl.carousel changed.owl.carousel": a.proxy(function () {
                    this.owl.options.autoHeight && this.setHeight()
                }, this)
            })
        }, AutoHeight.Defaults = {
            autoHeight: !1,
            autoHeightClass: "owl-height"
        }, AutoHeight.prototype.setHeight = function (a) {
            if (this.owl.options.autoHeight !== !0 && a !== !0) return !1;
            this.owl.dom.$oStage.hasClass(this.owl.options.autoHeightClass) || this.owl.dom.$oStage.addClass(this.owl.options.autoHeightClass);
            var c = this.owl.dom.$items.eq(this.owl.pos.currentAbs),
                d = this.owl.dom.$oStage,
                e = 0,
                f = b.setInterval(function () {
                    e += 1, c.data("owl-item").loaded ? (d.height(c.height() + "px"), clearInterval(f)) : 500 === e && clearInterval(f)
                }, 100)
        }, AutoHeight.prototype.destroy = function () {
            this.owl.dom.$el.off(".owl")
        }, a.fn.owlCarousel.Constructor.Plugins.autoHeight = AutoHeight
    }(window.Zepto || window.jQuery, window, document),
    function (a, b, c) {
        Video = function (b) {
            this.owl = b, this.owl.options = a.extend({}, Video.Defaults, this.owl.options), this.owl.dom.$el.on("click.owl.video", ".owl-video-play-icon", a.proxy(function (a) {
                this.playVideo(a)
            }, this)), this.owl.dom.$el.on({
                "resize.owl.carousel": a.proxy(function (a) {
                    this.owl.options.video && !this.isInFullScreen() && a.preventDefault()
                }, this),
                "refresh.owl.carousel changed.owl.carousel": a.proxy(function () {
                    this.owl.state.videoPlay && this.stopVideo()
                }, this),
                "refresh.owl.carousel": a.proxy(function () {
                    return this.owl.options.video ? void this.owl.dom.$el.one("updated.owl.carousel", a.proxy(this.checkVideoLinks, this)) : !1
                }, this)
            })
        }, Video.Defaults = {
            video: !1,
            videoHeight: !1,
            videoWidth: !1
        }, Video.prototype.checkVideoLinks = function () {
            for (var a, b, c = 0; c < this.owl.num.items; c++) b = this.owl.dom.$items.eq(c), b.data("owl-item").hasVideo || (a = b.find(".owl-video"), a.length && (this.owl.state.hasVideos = !0, this.owl.dom.$items.eq(c).data("owl-item").hasVideo = !0, a.css("display", "none"), this.getVideoInfo(a, b)))
        }, Video.prototype.getVideoInfo = function (a, b) {
            var c, d, e, f = a.data("vimeo-id"),
                g = a.data("youtube-id"),
                h = a.data("width") || this.owl.options.videoWidth,
                i = a.data("height") || this.owl.options.videoHeight,
                j = a.attr("href");
            if (f) d = "vimeo", e = f;
            else if (g) d = "youtube", e = g;
            else {
                if (!j) throw new Error("Missing video link.");
                e = j.match(/(http:|https:|)\/\/(player.|www.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com))\/(video\/|embed\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/), e[3].indexOf("youtu") > -1 ? d = "youtube" : e[3].indexOf("vimeo") > -1 && (d = "vimeo"), e = e[6]
            }
            b.data("owl-item").videoType = d, b.data("owl-item").videoId = e, b.data("owl-item").videoWidth = h, b.data("owl-item").videoHeight = i, c = {
                type: d,
                id: e
            };
            var k = h && i ? 'style="width:' + h + "px;height:" + i + 'px;"' : "";
            a.wrap('<div class="owl-video-wrapper"' + k + "></div>"), this.createVideoTn(a, c)
        }, Video.prototype.createVideoTn = function (b, c) {
            function d(a) {
                f = '<div class="owl-video-play-icon"></div>', e = j.options.lazyLoad ? '<div class="owl-video-tn ' + i + '" ' + h + '="' + a + '"></div>' : '<div class="owl-video-tn" style="opacity:1;background-image:url(' + a + ')"></div>', b.after(e), b.after(f)
            }
            var e, f, g = b.find("img"),
                h = "src",
                i = "",
                j = this.owl;
            if (this.owl.options.lazyLoad && (h = "data-src", i = "owl-lazy"), g.length) return d(g.attr(h)), g.remove(), !1;
            if ("youtube" === c.type) {
                var k = "http://img.youtube.com/vi/" + c.id + "/hqdefault.jpg";
                d(k)
            } else "vimeo" === c.type && a.ajax({
                type: "GET",
                url: "http://vimeo.com/api/v2/video/" + c.id + ".json",
                jsonp: "callback",
                dataType: "jsonp",
                success: function (a) {
                    var b = a[0].thumbnail_large;
                    d(b), j.options.loop && j.updateItemState()
                }
            })
        }, Video.prototype.stopVideo = function () {
            this.owl.trigger("stop", null, "video");
            var a = this.owl.dom.$items.eq(this.owl.state.videoPlayIndex);
            a.find(".owl-video-frame").remove(), a.removeClass("owl-video-playing"), this.owl.state.videoPlay = !1
        }, Video.prototype.playVideo = function (b) {
            this.owl.trigger("play", null, "video"), this.owl.state.videoPlay && this.stopVideo();
            var c, d, e = a(b.target || b.srcElement),
                f = e.closest("." + this.owl.options.itemClass),
                g = f.data("owl-item").videoType,
                h = f.data("owl-item").videoId,
                i = f.data("owl-item").videoWidth || Math.floor(f.data("owl-item").width - this.owl.options.margin),
                j = f.data("owl-item").videoHeight || this.owl.dom.$stage.height();
            "youtube" === g ? c = '<iframe width="' + i + '" height="' + j + '" src="http://www.youtube.com/embed/' + h + "?autoplay=1&v=" + h + '" frameborder="0" allowfullscreen></iframe>' : "vimeo" === g && (c = '<iframe src="http://player.vimeo.com/video/' + h + '?autoplay=1" width="' + i + '" height="' + j + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>'), f.addClass("owl-video-playing"), this.owl.state.videoPlay = !0, this.owl.state.videoPlayIndex = f.data("owl-item").indexAbs, d = a('<div style="height:' + j + "px; width:" + i + 'px" class="owl-video-frame">' + c + "</div>"), e.after(d)
        }, Video.prototype.isInFullScreen = function () {
            var d = c.fullscreenElement || c.mozFullScreenElement || c.webkitFullscreenElement;
            return d && a(d.parentNode).hasClass("owl-video-frame") && (this.owl.setSpeed(0), this.owl.state.isFullScreen = !0), d && this.owl.state.isFullScreen && this.owl.state.videoPlay ? !1 : this.owl.state.isFullScreen ? (this.owl.state.isFullScreen = !1, !1) : this.owl.state.videoPlay && this.owl.state.orientation !== b.orientation ? (this.owl.state.orientation = b.orientation, !1) : !0
        }, Video.prototype.destroy = function () {
            this.owl.dom.$el.off(".owl"), this.owl.dom.$el.off(".owl.video")
        }, a.fn.owlCarousel.Constructor.Plugins.video = Video
    }(window.Zepto || window.jQuery, window, document),
    function (a) {
        Animate = function (b) {
            this.owl = b, this.owl.options = a.extend({}, Animate.Defaults, this.owl.options), this.owl.dom.$el.on({
                "animate.owl.carousel": a.proxy(function () {
                    (this.owl.options.animateIn || this.owl.options.animateOut) && this.swap()
                }, this)
            })
        }, Animate.Defaults = {
            animateOut: !1,
            animateIn: !1
        }, Animate.prototype.swap = function () {
            this.owl.setSpeed(0), this.owl.state.animate = 1 === this.owl.options.items && this.owl.support3d ? !0 : !1;
            var b = this.owl.dom.$items.eq(this.owl.pos.prev),
                c = Math.abs(b.data("owl-item").width) * this.owl.pos.prev,
                d = this.owl.dom.$items.eq(this.owl.pos.currentAbs),
                e = Math.abs(d.data("owl-item").width) * this.owl.pos.currentAbs;
            if (this.owl.pos.currentAbs === this.owl.pos.prev) return !1;
            var f = e - c,
                g = this.owl.options.animateIn,
                h = this.owl.options.animateOut,
                i = this.owl;
            removeStyles = function () {
                a(this).css({
                    left: ""
                }).removeClass("animated owl-animated-out owl-animated-in").removeClass(g).removeClass(h), i.transitionEnd()
            }, h && b.css({
                left: f + "px"
            }).addClass("animated owl-animated-out " + h).one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", removeStyles), g && d.addClass("animated owl-animated-in " + g).one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", removeStyles)
        }, Animate.prototype.destroy = function () {
            this.owl.dom.$el.off(".owl")
        }, a.fn.owlCarousel.Constructor.Plugins.animate = Animate
    }(window.Zepto || window.jQuery, window, document),
    function (a, b, c) {
        Autoplay = function (b) {
            this.owl = b, this.owl.options = a.extend({}, Autoplay.Defaults, this.owl.options), this.owl.dom.$el.on({
                "translated.owl.carousel refreshed.owl.carousel": a.proxy(function () {
                    this.autoplay()
                }, this),
                "play.owl.autoplay": a.proxy(function (a, b, c) {
                    this.play(b, c)
                }, this),
                "stop.owl.autoplay": a.proxy(function () {
                    this.stop()
                }, this)
            }), this.owl.options.autoplayHoverPause && (this.owl.dom.$el.on("mouseover.ap.owl", ".owl-stage", a.proxy(function () {
                this.pause()
            }, this)), this.owl.dom.$el.on("mouseleave.ap.owl", ".owl-stage", a.proxy(function () {
                this.autoplay()
            }, this)))
        }, Autoplay.Defaults = {
            autoplay: !1,
            autoplayTimeout: 5e3,
            autoplayHoverPause: !1,
            autoplaySpeed: !1
        }, Autoplay.prototype.autoplay = function () {
            this.owl.options.autoplay && !this.owl.state.videoPlay ? (b.clearInterval(this.apInterval), this.apInterval = b.setInterval(function () {
                this.play()
            }.bind(this), this.owl.options.autoplayTimeout)) : (b.clearInterval(this.apInterval), this.autoplayState = !1)
        }, Autoplay.prototype.play = function (a, d) {
            return c.hidden === !0 ? !1 : (this.owl.options.autoplay || (this.owl._options.autoplay = this.owl.options.autoplay = !0, this.owl._options.autoplayTimeout = this.owl.options.autoplayTimeout = a || this.owl.options.autoplayTimeout || 4e3, this.owl._options.autoplaySpeed = d || this.owl.options.autoplaySpeed), this.owl.options.autoplay === !1 || this.owl.state.isTouch || this.owl.state.isScrolling || this.owl.state.isSwiping || this.owl.state.inMotion ? (b.clearInterval(this.apInterval), !1) : (!this.owl.options.loop && this.owl.pos.current >= this.owl.pos.max ? (b.clearInterval(this.e._autoplay), this.owl.goTo(0)) : this.owl.next(this.owl.options.autoplaySpeed), void(this.autoplayState = !0)))
        }, Autoplay.prototype.stop = function () {
            this.owl._options.autoplay = this.owl.options.autoplay = !1, this.autoplayState = !1, b.clearInterval(this.apInterval)
        }, Autoplay.prototype.pause = function () {
            b.clearInterval(this.apInterval)
        }, Autoplay.prototype.destroy = function () {
            b.clearInterval(this.apInterval), this.owl.dom.$el.off(".owl")
        }, a.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay
    }(window.Zepto || window.jQuery, window, document);
! function (t) {
    var e, n, i, a, o, c, d, l, h, s, r, f, p = 0,
        g = {},
        u = [],
        y = 0,
        b = {},
        m = [],
        x = null,
        w = new Image,
        v = /\.(jpg|gif|png|bmp|jpeg)(.*)?$/i,
        C = /[^\.]\.(swf)\s*$/i,
        k = 1,
        O = !1,
        M = 20,
        I = t.extend(t("<div/>")[0], {
            prop: 0
        }),
        j = 0,
        F = !t.support.opacity && !window.XMLHttpRequest,
        S = function () {
            n.hide(), w.onerror = w.onload = null, x && x.abort(), e.empty()
        },
        T = function () {
            t.fancybox('<p id="fancybox_error">The requested content cannot be loaded.<br />Please try again later.</p>', {
                scrolling: "no",
                padding: 20,
                transitionIn: "none",
                transitionOut: "none"
            })
        },
        D = function () {
            return [t(window).width(), t(window).height(), t(document).scrollLeft(), t(document).scrollTop()]
        },
        E = function () {
            var t, e = D(),
                n = {},
                i = b.margin,
                a = b.autoScale,
                o = 2 * (M + i),
                c = 2 * (M + i),
                d = 2 * b.padding;
            return b.width.toString().indexOf("%") > -1 ? (n.width = e[0] * parseFloat(b.width) / 100 - 2 * M, a = !1) : n.width = b.width + d, b.height.toString().indexOf("%") > -1 ? (n.height = e[1] * parseFloat(b.height) / 100 - 2 * M, a = !1) : n.height = b.height + d, a && (n.width > e[0] - o || n.height > e[1] - c) && ("image" == g.type || "swf" == g.type ? (o += d, c += d, t = Math.min(Math.min(e[0] - o, b.width) / b.width, Math.min(e[1] - c, b.height) / b.height), n.width = Math.round(t * (n.width - d)) + d, n.height = Math.round(t * (n.height - d)) + d) : (n.width = Math.min(n.width, e[0] - o), n.height = Math.min(n.height, e[1] - c))), n.top = e[3] + .5 * (e[1] - (n.height + 2 * M)), n.left = e[2] + .5 * (e[0] - (n.width + 2 * M)), b.autoScale === !1 && (n.top = Math.max(e[3] + i, n.top), n.left = Math.max(e[2] + i, n.left)), n
        },
        A = function (t) {
            if (t && t.length) switch (b.titlePosition) {
                case "inside":
                    return t;
                case "over":
                    return '<span id="fancybox-title-over">' + t + "</span>";
                default:
                    return '<span id="fancybox-title-wrap"><span id="fancybox-title-left"></span><span id="fancybox-title-main">' + t + '</span><span id="fancybox-title-right"></span></span>'
            }
            return !1
        },
        H = function () {
            var e = b.title,
                n = f.width - 2 * b.padding,
                i = "fancybox-title-" + b.titlePosition;
            if (t("#fancybox-title").remove(), j = 0, b.titleShow !== !1 && (e = t.isFunction(b.titleFormat) ? b.titleFormat(e, m, y, b) : A(e), e && "" !== e)) {
                switch (t('<div id="fancybox-title" class="' + i + '" />').css({
                    width: n,
                    paddingLeft: b.padding,
                    paddingRight: b.padding
                }).html(e).appendTo("body"), b.titlePosition) {
                    case "inside":
                        j = t("#fancybox-title").outerHeight(!0) - b.padding, f.height += j;
                        break;
                    case "over":
                        t("#fancybox-title").css("bottom", b.padding);
                        break;
                    default:
                        t("#fancybox-title").css("bottom", -1 * t("#fancybox-title").outerHeight(!0))
                }
                t("#fancybox-title").appendTo(o).hide()
            }
        },
        B = function () {
            t(document).unbind("keydown.fb").bind("keydown.fb", function (e) {
                27 == e.keyCode && b.enableEscapeButton ? (e.preventDefault(), t.fancybox.close()) : 37 == e.keyCode ? (e.preventDefault(), t.fancybox.prev()) : 39 == e.keyCode && (e.preventDefault(), t.fancybox.next())
            }), t.fn.mousewheel && (a.unbind("mousewheel.fb"), m.length > 1 && a.bind("mousewheel.fb", function (e, n) {
                e.preventDefault(), O || 0 === n || (n > 0 ? t.fancybox.prev() : t.fancybox.next())
            })), b.showNavArrows && ((b.cyclic && m.length > 1 || 0 !== y) && l.show(), (b.cyclic && m.length > 1 || y != m.length - 1) && h.show())
        },
        L = function () {
            var t, e;
            m.length - 1 > y && (t = m[y + 1].href, "undefined" != typeof t && t.match(v) && (e = new Image, e.src = t)), y > 0 && (t = m[y - 1].href, "undefined" != typeof t && t.match(v) && (e = new Image, e.src = t))
        },
        P = function () {
            c.css("overflow", "auto" == b.scrolling ? "image" == b.type || "iframe" == b.type || "swf" == b.type ? "hidden" : "auto" : "yes" == b.scrolling ? "auto" : "visible"), t.support.opacity || (c.get(0).style.removeAttribute("filter"), a.get(0).style.removeAttribute("filter")), t("#fancybox-title").show(), b.hideOnContentClick && c.one("click", t.fancybox.close), b.hideOnOverlayClick && i.one("click", t.fancybox.close), b.showCloseButton && d.show(), B(), t(window).bind("resize.fb", t.fancybox.center), b.centerOnScroll ? t(window).bind("scroll.fb", t.fancybox.center) : t(window).unbind("scroll.fb"), t.isFunction(b.onComplete) && b.onComplete(m, y, b), O = !1, L()
        },
        N = function (t) {
            var e = Math.round(r.width + (f.width - r.width) * t),
                n = Math.round(r.height + (f.height - r.height) * t),
                i = Math.round(r.top + (f.top - r.top) * t),
                o = Math.round(r.left + (f.left - r.left) * t);
            a.css({
                width: e + "px",
                height: n + "px",
                top: i + "px",
                left: o + "px"
            }), e = Math.max(e - 2 * b.padding, 0), n = Math.max(n - (2 * b.padding + j * t), 0), c.css({
                width: e + "px",
                height: n + "px"
            }), "undefined" != typeof f.opacity && a.css("opacity", .5 > t ? .5 : t)
        },
        W = function (t) {
            var e = t.offset();
            return e.top += parseFloat(t.css("paddingTop")) || 0, e.left += parseFloat(t.css("paddingLeft")) || 0, e.top += parseFloat(t.css("border-top-width")) || 0, e.left += parseFloat(t.css("border-left-width")) || 0, e.width = t.width(), e.height = t.height(), e
        },
        z = function () {
            var e, n, i = g.orig ? t(g.orig) : !1,
                a = {};
            return i && i.length ? (e = W(i), a = {
                width: e.width + 2 * b.padding,
                height: e.height + 2 * b.padding,
                top: e.top - b.padding - M,
                left: e.left - b.padding - M
            }) : (n = D(), a = {
                width: 1,
                height: 1,
                top: n[3] + .5 * n[1],
                left: n[2] + .5 * n[0]
            }), a
        },
        q = function () {
            if (n.hide(), a.is(":visible") && t.isFunction(b.onCleanup) && b.onCleanup(m, y, b) === !1) return t.event.trigger("fancybox-cancel"), void(O = !1);
            if (m = u, y = p, b = g, c.get(0).scrollTop = 0, c.get(0).scrollLeft = 0, b.overlayShow && (F && t("select:not(#fancybox-tmp select)").filter(function () {
                    return "hidden" !== this.style.visibility
                }).css({
                    visibility: "hidden"
                }).one("fancybox-cleanup", function () {
                    this.style.visibility = "inherit"
                }), i.css({
                    "background-color": b.overlayColor,
                    opacity: b.overlayOpacity
                }).unbind().show()), f = E(), H(), a.is(":visible")) {
                t(d.add(l).add(h)).hide();
                var o, s = a.position();
                return r = {
                    top: s.top,
                    left: s.left,
                    width: a.width(),
                    height: a.height()
                }, o = r.width == f.width && r.height == f.height, void c.fadeOut(b.changeFade, function () {
                    var n = function () {
                        c.html(e.contents()).fadeIn(b.changeFade, P)
                    };
                    t.event.trigger("fancybox-change"), c.empty().css("overflow", "hidden"), o ? (c.css({
                        top: b.padding,
                        left: b.padding,
                        width: Math.max(f.width - 2 * b.padding, 1),
                        height: Math.max(f.height - 2 * b.padding - j, 1)
                    }), n()) : (c.css({
                        top: b.padding,
                        left: b.padding,
                        width: Math.max(r.width - 2 * b.padding, 1),
                        height: Math.max(r.height - 2 * b.padding, 1)
                    }), I.prop = 0, t(I).animate({
                        prop: 1
                    }, {
                        duration: b.changeSpeed,
                        easing: b.easingChange,
                        step: N,
                        complete: n
                    }))
                })
            }
            a.css("opacity", 1), "elastic" == b.transitionIn ? (r = z(), c.css({
                top: b.padding,
                left: b.padding,
                width: Math.max(r.width - 2 * b.padding, 1),
                height: Math.max(r.height - 2 * b.padding, 1)
            }).html(e.contents()), a.css(r).show(), b.opacity && (f.opacity = 0), I.prop = 0, t(I).animate({
                prop: 1
            }, {
                duration: b.speedIn,
                easing: b.easingIn,
                step: N,
                complete: P
            })) : (c.css({
                top: b.padding,
                left: b.padding,
                width: Math.max(f.width - 2 * b.padding, 1),
                height: Math.max(f.height - 2 * b.padding - j, 1)
            }).html(e.contents()), a.css(f).fadeIn("none" == b.transitionIn ? 0 : b.speedIn, P))
        },
        Q = function () {
            e.width(g.width), e.height(g.height), "auto" == g.width && (g.width = e.width()), "auto" == g.height && (g.height = e.height()), q()
        },
        R = function () {
            O = !0, g.width = w.width, g.height = w.height, t("<img />").attr({
                id: "fancybox-img",
                src: w.src,
                alt: g.title
            }).appendTo(e), q()
        },
        $ = function () {
            S();
            var n, i, a, o, d, l, h, s = u[p];
            if (g = t.extend({}, t.fn.fancybox.defaults, "undefined" == typeof t(s).data("fancybox") ? g : t(s).data("fancybox")), a = s.title || t(s).title || g.title || "", s.nodeName && !g.orig && (g.orig = t(s).children("img:first").length ? t(s).children("img:first") : t(s)), "" === a && g.orig && (a = g.orig.attr("alt")), n = s.nodeName && /^(?:javascript|#)/i.test(s.href) ? g.href || null : g.href || s.href || null, g.type ? (i = g.type, n || (n = g.content)) : g.content ? i = "html" : n ? n.match(v) ? i = "image" : n.match(C) ? i = "swf" : t(s).hasClass("iframe") ? i = "iframe" : n.match(/#/) ? (s = n.substr(n.indexOf("#")), i = t(s).length > 0 ? "inline" : "ajax") : i = "ajax" : i = "inline", g.type = i, g.href = n, g.title = a, g.autoDimensions && "iframe" !== g.type && "swf" !== g.type && (g.width = "auto", g.height = "auto"), g.modal && (g.overlayShow = !0, g.hideOnOverlayClick = !1, g.hideOnContentClick = !1, g.enableEscapeButton = !1, g.showCloseButton = !1), t.isFunction(g.onStart) && g.onStart(u, p, g) === !1) return void(O = !1);
            switch (e.css("padding", M + g.padding + g.margin), t(".fancybox-inline-tmp").unbind("fancybox-cancel").bind("fancybox-change", function () {
                t(this).replaceWith(c.children())
            }), i) {
                case "html":
                    e.html(g.content), Q();
                    break;
                case "inline":
                    t('<div class="fancybox-inline-tmp" />').hide().insertBefore(t(s)).bind("fancybox-cleanup", function () {
                        t(this).replaceWith(c.children())
                    }).bind("fancybox-cancel", function () {
                        t(this).replaceWith(e.children())
                    }), t(s).appendTo(e), Q();
                    break;
                case "image":
                    O = !1, t.fancybox.showActivity(), w = new Image, w.onerror = function () {
                        T()
                    }, w.onload = function () {
                        w.onerror = null, w.onload = null, R()
                    }, w.src = n;
                    break;
                case "swf":
                    o = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="' + g.width + '" height="' + g.height + '"><param name="movie" value="' + n + '"></param>', d = "", t.each(g.swf, function (t, e) {
                        o += '<param name="' + t + '" value="' + e + '"></param>', d += " " + t + '="' + e + '"'
                    }), o += '<embed src="' + n + '" type="application/x-shockwave-flash" width="' + g.width + '" height="' + g.height + '"' + d + "></embed></object>", e.html(o), Q();
                    break;
                case "ajax":
                    l = n.split("#", 2), h = g.ajax.data || {}, l.length > 1 && (n = l[0], "string" == typeof h ? h += "&selector=" + l[1] : h.selector = l[1]), O = !1, t.fancybox.showActivity(), x = t.ajax(t.extend(g.ajax, {
                        url: n,
                        data: h,
                        error: T,
                        success: function (t) {
                            200 == x.status && (e.html(t), Q())
                        }
                    }));
                    break;
                case "iframe":
                    t('<iframe id="fancybox-frame" name="fancybox-frame' + (new Date).getTime() + '" frameborder="0" hspace="0" scrolling="' + g.scrolling + '" src="' + g.href + '"></iframe>').appendTo(e), q()
            }
        },
        X = function () {
            return n.is(":visible") ? (t("div", n).css("top", -40 * k + "px"), void(k = (k + 1) % 12)) : void clearInterval(s)
        },
        _ = function () {
            t("#fancybox-wrap").length || (t("body").append(e = t('<div id="fancybox-tmp"></div>'), n = t('<div id="fancybox-loading"><div></div></div>'), i = t('<div id="fancybox-overlay"></div>'), a = t('<div id="fancybox-wrap"></div>')), t.support.opacity || (a.addClass("fancybox-ie"), n.addClass("fancybox-ie")), o = t('<div id="fancybox-outer"></div>').append('<div class="fancy-bg" id="fancy-bg-n"></div><div class="fancy-bg" id="fancy-bg-ne"></div><div class="fancy-bg" id="fancy-bg-e"></div><div class="fancy-bg" id="fancy-bg-se"></div><div class="fancy-bg" id="fancy-bg-s"></div><div class="fancy-bg" id="fancy-bg-sw"></div><div class="fancy-bg" id="fancy-bg-w"></div><div class="fancy-bg" id="fancy-bg-nw"></div>').appendTo(a), o.append(c = t('<div id="fancybox-inner"></div>'), d = t('<a id="fancybox-close"></a>'), l = t('<a href="javascript:;" id="fancybox-left"><span class="fancy-ico" id="fancybox-left-ico"></span></a>'), h = t('<a href="javascript:;" id="fancybox-right"><span class="fancy-ico" id="fancybox-right-ico"></span></a>')), d.click(t.fancybox.close), n.click(t.fancybox.cancel), l.click(function (e) {
                e.preventDefault(), t.fancybox.prev()
            }), h.click(function (e) {
                e.preventDefault(), t.fancybox.next()
            }), F && (i.get(0).style.setExpression("height", "document.body.scrollHeight > document.body.offsetHeight ? document.body.scrollHeight : document.body.offsetHeight + 'px'"), n.get(0).style.setExpression("top", "(-20 + (document.documentElement.clientHeight ? document.documentElement.clientHeight/2 : document.body.clientHeight/2 ) + ( ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop )) + 'px'"), o.prepend('<iframe id="fancybox-hide-sel-frame" src="javascript:\'\';" scrolling="no" frameborder="0" ></iframe>')))
        };
    t.fn.fancybox = function (e) {
        return t(this).data("fancybox", t.extend({}, e, t.metadata ? t(this).metadata() : {})).unbind("click.fb").bind("click.fb", function (e) {
            if (e.preventDefault(), !O) {
                O = !0, t(this).blur(), u = [], p = 0;
                var n = t(this).attr("rel") || "";
                return n && "" != n && "nofollow" !== n ? (u = t("a[rel=" + n + "], area[rel=" + n + "]"), p = u.index(this)) : u.push(this), $(), !1
            }
        }), this
    }, t.fancybox = function (e) {
        if (!O) {
            O = !0;
            var n = "undefined" != typeof arguments[1] ? arguments[1] : {};
            if (u = [], p = n.index || 0, t.isArray(e)) {
                for (var i = 0, a = e.length; a > i; i++) "object" == typeof e[i] ? t(e[i]).data("fancybox", t.extend({}, n, e[i])) : e[i] = t({}).data("fancybox", t.extend({
                    content: e[i]
                }, n));
                u = jQuery.merge(u, e)
            } else "object" == typeof e ? t(e).data("fancybox", t.extend({}, n, e)) : e = t({}).data("fancybox", t.extend({
                content: e
            }, n)), u.push(e);
            (p > u.length || 0 > p) && (p = 0), $()
        }
    }, t.fancybox.showActivity = function () {
        clearInterval(s), n.show(), s = setInterval(X, 66)
    }, t.fancybox.hideActivity = function () {
        n.hide()
    }, t.fancybox.next = function () {
        return t.fancybox.pos(y + 1)
    }, t.fancybox.prev = function () {
        return t.fancybox.pos(y - 1)
    }, t.fancybox.pos = function (t) {
        O || (t = parseInt(t, 10), t > -1 && m.length > t && (p = t, $()), b.cyclic && m.length > 1 && 0 > t && (p = m.length - 1, $()), b.cyclic && m.length > 1 && t >= m.length && (p = 0, $()))
    }, t.fancybox.cancel = function () {
        O || (O = !0, t.event.trigger("fancybox-cancel"), S(), g && t.isFunction(g.onCancel) && g.onCancel(u, p, g), O = !1)
    }, t.fancybox.close = function () {
        function e() {
            i.fadeOut("fast"), a.hide(), t.event.trigger("fancybox-cleanup"), c.empty(), t.isFunction(b.onClosed) && b.onClosed(m, y, b), m = g = [], y = p = 0, b = g = {}, O = !1
        }
        if (!O && !a.is(":hidden")) {
            if (O = !0, b && t.isFunction(b.onCleanup) && b.onCleanup(m, y, b) === !1) return void(O = !1);
            if (S(), t(d.add(l).add(h)).hide(), t("#fancybox-title").remove(), a.add(c).add(i).unbind(), t(window).unbind("resize.fb scroll.fb"), t(document).unbind("keydown.fb"), c.css("overflow", "hidden"), "elastic" == b.transitionOut) {
                r = z();
                var n = a.position();
                f = {
                    top: n.top,
                    left: n.left,
                    width: a.width(),
                    height: a.height()
                }, b.opacity && (f.opacity = 1), I.prop = 1, t(I).animate({
                    prop: 0
                }, {
                    duration: b.speedOut,
                    easing: b.easingOut,
                    step: N,
                    complete: e
                })
            } else a.fadeOut("none" == b.transitionOut ? 0 : b.speedOut, e)
        }
    }, t.fancybox.resize = function () {
        var e, n;
        O || a.is(":hidden") || (O = !0, e = c.wrapInner("<div style='overflow:auto'></div>").children(), n = e.height(), a.css({
            height: n + 2 * b.padding + j
        }), c.css({
            height: n
        }), e.replaceWith(e.children()), t.fancybox.center())
    }, t.fancybox.center = function () {
        O = !0;
        var t = D(),
            e = b.margin,
            n = {};
        n.top = t[3] + .5 * (t[1] - (a.height() - j + 2 * M)), n.left = t[2] + .5 * (t[0] - (a.width() + 2 * M)), n.top = Math.max(t[3] + e, n.top), n.left = Math.max(t[2] + e, n.left), a.css(n), O = !1
    }, t.fn.fancybox.defaults = {
        padding: 0,
        margin: 20,
        opacity: !1,
        modal: !1,
        cyclic: !1,
        scrolling: "auto",
        width: 666,
        height: 835,
        autoScale: !0,
        autoDimensions: !0,
        centerOnScroll: !1,
        ajax: {},
        swf: {
            wmode: "transparent"
        },
        hideOnOverlayClick: !0,
        hideOnContentClick: !1,
        overlayShow: !0,
        overlayOpacity: .3,
        overlayColor: "#666",
        titleShow: !0,
        titlePosition: "outside",
        titleFormat: null,
        transitionIn: "fade",
        transitionOut: "fade",
        speedIn: 300,
        speedOut: 300,
        changeSpeed: 300,
        changeFade: "fast",
        easingIn: "swing",
        easingOut: "swing",
        showCloseButton: !0,
        showNavArrows: !0,
        enableEscapeButton: !0,
        onStart: null,
        onCancel: null,
        onComplete: null,
        onCleanup: null,
        onClosed: null
    }, t(document).ready(function () {
        _()
    })
}(jQuery);

/* SPRACHWAHL Variablen */
var timer;

/* SUCHE Variablen */
var searchFocus = false;
var searchTimer = false;

/* TEASER Variablen */
var teaserTimer = false;

/* PRODUKT Variablen */
var element_parent;
var timer;

/* PRODUKTDETAIL Variablen */
//var element_parent;
//var timer;

/* CYCLE Helper-Function */
// timeouts per slide (in seconds) 
var timeouts = [8, 5, 5];

function calculateTimeout(currElement, nextElement, opts, isForward) {
    var index = opts.currSlide;
    return timeouts[index] * 1000;
}

/* Video Variablen und Helper-Function */
var ytplayer;

function onYouTubePlayerReady(playerId) {
    ytplayer = document.getElementById('yt_video');
    ytplayer.playVideo();
}


/* ON DOCUMENT READY */
/* ----------------- */


$(document).ready(function () {
    /**
    	//Add WEB-7 / Remove WEB-562 - by sb9945
        if($('input[name=logintype]').val() != 'logout' && document.cookie.indexOf('fe_typo_login') != -1){
            $('.navbar-form ul li.dropdown:last').addClass('open');
        }
    **/
    if (document.cookie.indexOf('radiohintclick') == -1) {
        var bxradiohint = document.getElementById('radiohint');
        if (typeof (bxradiohint) != 'undefined' && bxradiohint != null) {
            bxradiohint.style.display = 'block';
        }
    }





    /* FANCYBOX */
    $(".video").fancybox({
        'autoScale': false,
        'overlayOpacity': 0.7,
        'overlayColor': '#fff',
        'transitionIn': 'fade',
        'transitionOut': 'fade',
        'type': 'swf',
        'width': 680,
        'height': 411,
        'titleShow': 'false',
        'titleFormat': 'null',
        'titlePosition': 'outside'
    });
    $(".web").fancybox({
        'autoScale': true,
        'overlayOpacity': 0.7,
        'overlayColor': '#fff',
        'transitionIn': 'fade',
        'transitionOut': 'fade',
        'type': 'iframe',
        'scrolling': 'yes',
        'width': 600,
        'height': 600,
        'titleShow': 'false',
        'titleFormat': 'null',
        'titlePosition': 'inside'
    });
    $(".web_video").fancybox({
        'autoScale': true,
        'overlayOpacity': 0.7,
        'overlayColor': '#fff',
        'transitionIn': 'fade',
        'transitionOut': 'fade',
        'type': 'iframe',
        'scrolling': 'yes',
        'width': 600,
        'height': 530,
        'titleShow': 'false',
        'titleFormat': 'null',
        'titlePosition': 'inside'
    });
    $(".big_picture").fancybox({
        'autoScale': true,
        'overlayOpacity': 0.7,
        'overlayColor': '#fff',
        'transitionIn': 'fade', //elastic
        'transitionOut': 'fade',
        'titleFormat': 'null',
        'titleShow': true,
        'titlePosition': 'inside'
    });
    $(".big_picture2").fancybox({
        'autoScale': true,
        'overlayOpacity': 0.7,
        'overlayColor': '#fff',
        'transitionIn': 'elastic',
        'transitionOut': 'fade',
        'titleFormat': 'null',
        'titleShow': false,
        'titlePosition': 'inside'
    });
    $(".video_fullscreen").fancybox({
        'width': '80%',
        'height': '80%',
        'autoScale': true,
        'overlayOpacity': 0.7,
        'overlayColor': '#fff',
        'transitionIn': 'fade',
        'transitionOut': 'fade',
        'type': 'iframe'
    });

    $(".video_fullscreen").trigger('click');

    /* CLOSE FANCYBOX */
    /*iframe lightbox*/
    try {
        [].forEach.call(document.getElementsByClassName("iframe-lightbox-link"), function (el) {
            el.lightbox = new IframeLightbox(el);
        });
    } catch (e) {
        //console.log(e);
    }


    /* ACCORDION SLIDER */
    // instantiate the accordion
    $('#example3').accordionSlider({
        width: 1600,
        height: 345,
        responsiveMode: 'custom',
        visiblePanels: 7,
        startPanel: 0,
        closePanelsOnMouseOut: false,
        shadow: false,
        panelDistance: 1,
        autoplay: false,
        mouseWheel: false,
        breakpoints: {
            960: {
                visiblePanels: 5
            },
            650: {
                visiblePanels: 4
            },
            500: {
                visiblePanels: 3
            }
        }
    });
    /* ACCORDION SLIDER */


    // BACK TO TOP PLUGIN
    $(window).scroll(function () {
        if ($(this).scrollTop() >= 1000) {
            $('.backtotop').fadeIn();
        } else {
            $('.backtotop').fadeOut();
        }
        /*if($(this).scrollTop() >= 500 && $('#gdpr-cookie-message').height()<300) {
        	$('#gdpr-cookie-message').css("position","fixed");
        } else {
        	$('#gdpr-cookie-message').css("position","relative");
        }*/
    });

    $('.backtotop').click(function () {
        $('body,html').animate(0, 800);
        $('body,html').animate({
            scrollTop: 0
        }, 800);
        return false;
    });

    // CLOSE BACK TO TOP PLUGIN


    // FARBWECHSEL
    $('.farbwahl a').click(function () {
        var color = $(this).attr('class'); // color name
        //		console.log('ID: '+color);
        $('.MyElement').find('.active img').removeClass().addClass(color); // remove all css classes of the item
        // julia new 19.12.15  --------
        $('.slider_vertical').find('img').removeClass().addClass(color);
        return false;
    });

    /*
    	$(this).find('.farbwahl a').hover(function(){
    		var src = $(this).attr('href');
    		var newImage = new Image();
    		newImage.src = src;
    	});

    	$(this).find('.farbwahl a').click(function(){
    		var id = $(this).attr('class');
    		var src = $(this).attr('href');
    		$('#'+id).attr('src', src);
    		$('.zoomWindow').css({
    			'background-image': 'url(' + src.replace('_thumb', '_large') + ')'
    		});
    		$('.zoomWindow').attr('src',src.replace('_thumb', '_large'));
    		return false;
    	});
    */

    /*
    	$(this).find('.farbwahl a').click(function(){
    		var id = $(this).attr('class');
    		var src = $(this).attr('href');
    		$('#'+id).attr('src', src);
    		$('.zoomWindow').css({
    			'background-image': 'url(' + src.replace('_thumb', '_large') + ')'
    		});
    		return false;
    	});
    */


    var msliderdefaultcfg = {

        width: 750,
        minHeight: 0,
        space: 0,
        grabCursor: true,
        swipe: true,
        mouse: true,
        keyboard: false,
        layout: "partialview",
        wheel: false,
        autoplay: false,
        instantStartLayers: false,
        mobileBGVideo: false,
        loop: true,
        shuffle: false,
        preload: 0,
        heightLimit: true,
        smoothHeight: true,
        endPause: false,
        overPause: true,
        fillMode: "fill",
        centerControls: true,
        startOnAppear: false,
        layersMode: "center",
        autofillTarget: "",
        hideLayers: false,
        fullscreenMargin: 0,
        speed: 80,
        dir: "h",
        autoHeight: true,
        parallaxMode: 'swipe',
        view: "flow",
        filters: {
            grayscale: 1,
            opacity: 1,
        }
    };

    /* Slider Coverflow */
    var slider = new MasterSlider();
    slider.control('arrows', {
        autohide: false
    });
    slider.setup('masterslider', msliderdefaultcfg);

    var slider2 = new MasterSlider();
    slider2.control('arrows', {
        autohide: false
    });
    slider2.setup('masterslider2', msliderdefaultcfg);

    var slider3 = new MasterSlider();
    slider3.control('arrows', {
        autohide: false
    });
    slider3.setup('masterslider3', msliderdefaultcfg);

    var slider4 = new MasterSlider();
    slider4.control('arrows', {
        autohide: false
    });
    slider4.setup('masterslider4', msliderdefaultcfg);

    var slider5 = new MasterSlider();
    slider5.control('arrows', {
        autohide: false
    });
    slider5.setup('masterslider5', msliderdefaultcfg);


    /* CLose Slider Coverflow */




    /* Optimierungen Abstände */
    $("p").filter(function () {
        return $.trim(this.innerHTML) === "&nbsp;"
    }).remove();

    $(".subnavigation .anker").parent().parent().parent().find("+ .container").addClass("anker-wrapper");
    /* Close Optimierungen Abstände */

    $(window).load(function () {
        /*
            $('.flexslider').flexslider({
                animation: "slide",
        		pausePlay: true,
                start: function(slider){
                  $('body').removeClass('loading');
                }
              
            });
        */

        if ($('.flexslider').length > 0) {
            // dann schau, wieviel li-Elemente in der ul.slides exisiteren (innerhalb der Klasse flexslider),
            // wenn es mehr als drei li Elemente sind, dann setzte die swipe variable auf true, sonst ist swipe auf false gesetzt...
            if ($('.flexslider .slides li').length > 2) {
                var swipe = true;
                //console.log('swipe true');
                //console.log($('.flexslider li').length);
            } else {
                var swipe = false;
                //console.log('swipe false');
                //console.log($('.flexslider li').length);
            }
            // ... und übergebe den Wert ("false" oder "true")
            $('.flexslider').flexslider({
                animation: "slide",
                pausePlay: false,
                start: function (slider) {
                    $('body').removeClass('loading');
                },
                touch: swipe // touch: true (true oder falses sind boolean Werte... Allow touch swipe navigation of the slider on enabled devices -> Quelle:https://github.com/woothemes/FlexSlider/wiki/FlexSlider-Properties
            });
        }

        //--------------------------------------------------------------------------------

        /* don't show pausePlay if only one picture is in header  */
        var numItems = $('.flexslider .flex-control-nav li').length;
        //console.log('numItems: '+numItems);
        if (numItems == '0') {
            //console.log('ein Bild im Slider');
            $('.flex-pauseplay').hide();
        } else {
            //console.log('mehrere Bilder im Slider');
            $('.flex-pauseplay').show();
        }

        //--------------------------------------------------------------------------------	

        $('.flexslider2').flexslider({
            animation: "slide",
            controlNav: "thumbnails",
            slideshow: false,
            smoothHeight: true
        });

        $('.flexslider3').flexslider({
            animation: "slide",
            slideshow: false,
            animationLoop: false,
            controlNav: true,
            directionNav: true,
            smoothHeight: true
        });

        // The slider being synced must be initialized first
        $('.carousel').flexslider({
            animation: "slide",
            controlNav: false,
            animationLoop: false,
            slideshow: false,
            itemWidth: 100,
            itemMargin: 5,
            asNavFor: '.slider'
        });

        $('.slider').flexslider({
            animation: "slide",
            controlNav: false,
            animationLoop: false,
            slideshow: false,
            sync: ".carousel",
            smoothHeight: true
        });


        /* OWL CAROUSEL */
        $(".owl-example-mobile").owlCarousel({
            loop: false,
            navText: ['<i class="fa fa-angle-left fa-3x"></i>', '<i class="fa fa-angle-right fa-3x"></i>'],
            navigationText: false,
            nav: true,
            dots: false,
            //Mouse Events
            dragBeforeAnimFinish: true,
            smoothHeight: true,
            mouseDrag: true,
            touchDrag: true,
            responsive: {
                0: {
                    items: 2,
                },
                600: {
                    items: 3,
                },
                1000: {
                    items: 4,
                }
            }
        });

        $(".produktkarussell").owlCarousel({
            loop: false,
            navText: ['<i class="fa fa-angle-left fa-3x"></i>', '<i class="fa fa-angle-right fa-3x"></i>'],
            navigationText: false,
            nav: true,
            dots: false,
            //Mouse Events
            dragBeforeAnimFinish: true,
            mouseDrag: true,
            touchDrag: true,
            responsive: {
                0: {
                    items: 2,
                },
                600: {
                    items: 3,
                },
                800: {
                    items: 4,
                },
                1000: {
                    items: 5,
                },
                1200: {
                    items: 6,
                }
            }
        });

        $(".produktkarussell_small").owlCarousel({
            loop: false,
            navText: ['<i class="fa fa-angle-left fa-3x"></i>', '<i class="fa fa-angle-right fa-3x"></i>'],
            navigationText: false,
            nav: true,
            dots: false,
            //Mouse Events
            dragBeforeAnimFinish: true,
            mouseDrag: true,
            touchDrag: true,
            responsive: {
                0: {
                    items: 2,
                },
                600: {
                    items: 2,
                },
                800: {
                    items: 2,
                },
                1000: {
                    items: 3,
                },
                1200: {
                    items: 4,
                }
            }
        });

        // Produktkarussell
        var sync1 = $(".slider");
        var sync2 = $(".thumbnails");
        var flag = false;

        function setCurrent() {
            $(".thumbnails .selected").removeClass("selected");
            $(".slider .owl-item").each(function (index) {
                if ($(this).hasClass("active")) {
                    $(".thumbnails .owl-item:nth-child(" + (index + 1) + ")").removeClass("selected").addClass("selected");
                }
            });
        }

        var slides = sync1.owlCarousel({
            items: 1,
            nav: true,
            navText: false,
            navSpeed: 1000,
            dots: false,
            mouseDrag: false, // unterdrückt die Möglichkeit mit der Maus zu „wischen“
            touchDrag: false, // unterdrückt die Möglichkeit mit dem Finger zu „wischen“
            onDragged: setCurrent
        }).on('change.owl.carousel', function (e) {
            if (e.namespace && e.property.name === 'position' && !flag) {
                flag = true;
                thumbs.to(e.relatedTarget.relative(e.property.value), 300, true);
                flag = false;
            }
        }).data('owl.carousel');


        var thumbs = sync2.owlCarousel({
            items: 7,
            margin: 5,
            navText: ['<i class="fa fa-angle-left fa-2x"></i>', '<i class="fa fa-angle-right fa-2x"></i>'],
            navigationText: false,
            nav: true,
            dots: false,
            responsive: {
                0: {
                    items: 3,
                },
                330: {
                    items: 4,
                },
                480: {
                    items: 6,
                },
                767: {
                    items: 5,
                },
                992: {
                    items: 6,
                }
            },
            navSpeed: 1000,
            dots: false,
        }).on('click', '.item', function (e) {
            e.preventDefault();
            sync1.trigger('to.owl.carousel', [$(e.target).parents('.owl-item').index(), 300, true]);
            $(e.target).parents('.owl-item').siblings().removeClass("selected");
            $(e.target).parents('.owl-item').addClass("selected");
        }).on('change.owl.carousel', function (e) {
            if (e.namespace && e.property.name === 'position' && !flag) {
                //console.log('...');
            }
        }).data('owl.carousel');

        setCurrent();

        $(".owl-next").click(function () {
            setCurrent();
        });

        $(".owl-prev").click(function () {
            setCurrent();
        });

        // Produktkarusell mit Farbwahl
        var sync3 = $(".slider_vertical");
        var sync4 = $(".thumbnails_vertical");
        var flag = false;

        function setCurrent() {
            $(".thumbnails_vertical .selected").removeClass("selected");
            $(".slider_vertical .owl-item").each(function (index) {
                if ($(this).hasClass("active")) {
                    $(".thumbnails_vertical .owl-item:nth-child(" + (index + 1) + ")").removeClass("selected").addClass("selected");
                }
            });
        }

        var slides = sync3.owlCarousel({
            items: 1,
            nav: true,
            navText: false,
            navSpeed: 1000,
            dots: false,
            onDragged: setCurrent
        }).on('change.owl.carousel', function (e) {
            if (e.namespace && e.property.name === 'position' && !flag) {
                flag = true;
                thumbs.to(e.relatedTarget.relative(e.property.value), 300, true);
                flag = false;
            }
        }).data('owl.carousel');


        var thumbs = sync4.owlCarousel({
            items: 2,
            margin: 5,
            navText: ['<i class="fa fa-angle-left fa-2x"></i>', '<i class="fa fa-angle-right fa-2x"></i>'],
            navigationText: false,
            nav: true,
            dots: false,
            responsive: {
                0: {
                    items: 4,
                },
                330: {
                    items: 4,
                },
                480: {
                    items: 4,
                },
                767: {
                    items: 4,
                },
                992: {
                    items: 4,
                }
            },
            navSpeed: 1000,
            dots: false,
        }).on('click', '.item', function (e) {
            e.preventDefault();
            sync3.trigger('to.owl.carousel', [$(e.target).parents('.owl-item').index(), 300, true]);
            $(e.target).parents('.owl-item').siblings().removeClass("selected");
            $(e.target).parents('.owl-item').addClass("selected");
        }).on('change.owl.carousel', function (e) {
            if (e.namespace && e.property.name === 'position' && !flag) {
                //console.log('...');
            }
        }).data('owl.carousel');

        setCurrent();

        $(".owl-next").click(function () {
            setCurrent();
        });

        $(".owl-prev").click(function () {
            setCurrent();
        });

        // Close Produktkarusell mit Farbwahl

        /* CLOSE OWL CAROUSEL */

        if ($('#bxcomparesliderproduct').length) {
            $('#bxcomparesliderproduct').twentytwenty({
                default_offset_pct: 0.5,
                orientation: 'horizontal',
                //before_label: $('#bxcomparesliderproduct').data("lblprev"),
                //after_label: $('#bxcomparesliderproduct').data("lblnext"),
                no_overlay: true,
                move_with_handle_only: false,
                click_to_move: false
            });
        }

    });



    $(function () {
        $('[data-toggle="tooltip"]').tooltip();
    })

    /*
    $(function () {
        $('[data-toggle="popover"]').popover(); 
    })
    */

    /*
    $("[data-toggle=popover]").popover({
        html: true, 
    	placement: "top",
    	//trigger: "focus",
    	//trigger: 'focus',
    	content: function() {
              return $('.popover-content').html();
        }
    });
    */

    /*
    $("[data-toggle=popover]").popover({
        container: 'body',
        html: true,
    	placement: "top",
    	trigger: "focus",
        content: function () {
            return $(this).next('.popover-content').html();
        }
    });
    */

    $('.bt_popover').popover({
        placement: 'top',
        trigger: 'focus',
        container: 'body',
        html: true,
        content: function () {
            return $(this).next('.popover-content').html();
        }
    });

    // Smooth Scroll Menü
    $('.anker').onePageNav({
        currentClass: 'red',
        changeHash: true,
        scrollSpeed: 750,
        scrollThreshold: 0.5,
        easing: 'swing'
    });


    $('#accordion').on('shown.bs.collapse hidden.bs.collapse', function (e) {
        $(e.target).prev('.panel-heading').find("i.fa.pull-right").toggleClass('fa-plus fa-minus', 50, "fade");
    });
    $('.accordion_warenkorb').on('shown.bs.collapse hidden.bs.collapse', function (e) {
        $(e.target).prev('.panel-heading').find("i.fa.pull-right").toggleClass('fa-angle-down fa-angle-up', 50, "fade");
    });

    /*
    $('#accordion').on('shown.bs.collapse hidden.bs.collapse', function (e) {
          $(e.target).prev('.panel-heading').change("i.fa.pull-right").toggleClass('fa-plus fa-minus',50, "fade" );
    })
    */

    /*
    $('.panel-heading').click( function() {
          $(this).toggleClass('on');
    //	  $(e.target).prev('.panel-heading').add("on");
    })
    */

    /*
    $('#accordion').on('shown.bs.collapse', function () {
             $(this).prev('.panel-heading').addClass('on');
        });

        $('#accordion').on('hidden.bs.collapse', function () {
             $(this).prev('.panel-heading').removeClass('on');
        });
    */


    $('.panel-heading').click(function () {
        $('.panel-heading').removeClass('highlight');
        $(this).addClass('highlight');
    })


    //plugin bootstrap minus and plus
    //http://jsfiddle.net/laelitenetwork/puJ6G/

    // Anzahl der Produkte für den Warenkorb
    /*
    $('.btn-number').click(function(e){
        e.preventDefault();

        fieldName = $(this).attr('data-field');
        type      = $(this).attr('data-type');
        var input = $("input[name='"+fieldName+"']");
        var currentVal = parseInt(input.val());
        if (!isNaN(currentVal)) {
            if(type == 'minus') {
                
                if(currentVal > input.attr('min')) {
                    input.val(currentVal - 1).change();
                } 
                if(parseInt(input.val()) == input.attr('min')) {
                    $(this).attr('disabled', true);
                }
            } else if(type == 'plus') {
                if(currentVal < input.attr('max')) {
                    input.val(currentVal + 1).change();
                }
                if(parseInt(input.val()) == input.attr('max')) {
                    $(this).attr('disabled', true);
                }
            }
        } else {
            input.val(0);
        }
    });
    $('.input-number').focusin(function(){
       $(this).data('oldValue', $(this).val());
    });
    $('.input-number').change(function() {
        minValue =  parseInt($(this).attr('min'));
        maxValue =  parseInt($(this).attr('max'));
        valueCurrent = parseInt($(this).val());

        name = $(this).attr('name');
        if(valueCurrent >= minValue) {
            $(".btn-number[data-type='minus'][data-field='"+name+"']").removeAttr('disabled')
        } else {
            alert('Sorry, the minimum value was reached');
            $(this).val($(this).data('oldValue'));
        }
        if(valueCurrent <= maxValue) {
            $(".btn-number[data-type='plus'][data-field='"+name+"']").removeAttr('disabled')
        } else {
            alert('Sorry, the maximum value was reached');
            $(this).val($(this).data('oldValue'));
        }
        
        
    });
    $(".input-number").keydown(function (e) {
            // Allow: backspace, delete, tab, escape, enter and .
            if ($.inArray(e.keyCode, [46, 8, 9, 27, 13, 190]) !== -1 ||
                 // Allow: Ctrl+A
                (e.keyCode == 65 && e.ctrlKey === true) || 
                 // Allow: home, end, left, right
                (e.keyCode >= 35 && e.keyCode <= 39)) {
                     // let it happen, don't do anything
                     return;
            }
            // Ensure that it is a number and stop the keypress
            if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
                e.preventDefault();
            }
        });
    */
    // Ende


    /* Navi als Selectfeld für kleinere Ansichten */
    $("#accordion ul.nav.nav-tabs.warenkorb li").click(function () {
        $(this).siblings().removeClass('active');
        //$(this).addClass('active');
    });


    $("#meinTabContent ul.nav.nav-tabs.warenkorb li").click(function () {
        $(this).siblings().removeClass('active');
        //$(this).addClass('active');
    });

    //TODO MOVE
    $(".farbwahl a").click(function () {
        $('.farbfaecher').find('a.active').removeClass('active');
        $(this).siblings().removeClass('active');
        $(this).addClass('active');
    });
    $(".farbwahl a").on('touchstart tap', function (e) {
        $(this).trigger('click');
    });


    /* Hack für die Navigation bei Touch-Geräten */
    /*
    $('.#navbar .dropdown-menu > li ').on('click touchend', function(e) {
        var el = $(this);
        var link = el.attr('href');
        window.location = link;
    });
    */

    /*
    $('#navbar .dropdown-menu > li').on('click', function () {
        $(this).toggleClass('hover')
    });
    */

    /*
    // Ausklappnavi Produkte
    $('#navbar ul.wide-produkte.dropdown-menu > li').on("touchstart", function (e) {
        "use strict"; //satisfy the code inspectors
        var link = $(this); //preselect the link
        if (link.hasClass('hover')) {
            return true;
        } else {
            link.addClass("hover");
            $('#navbar ul.wide-produkte.dropdown-menu > li').not(this).removeClass("hover");
            e.preventDefault();
            return false; //extra, and to make sure the function has consistent return points
        }
    });
    */

    // Ausklappnavi 3. Ebene
    $('#navbar .simple .dropdown-menu > li.haschildren ').on("touchstart", function (e) {
        "use strict"; //satisfy the code inspectors
        var link = $(this); //preselect the link
        if (link.hasClass('hover')) {
            return true;
        } else {
            link.addClass("hover");
            $('#navbar .simple .dropdown-menu > li.haschildren ').not(this).removeClass("hover");
            e.preventDefault();
            return false; //extra, and to make sure the function has consistent return points
        }
    });


    $('.ih-item.square.effect4 a').on("touchstart", function (e) {
        "use strict"; //satisfy the code inspectors
        var link = $(this); //preselect the link
        if (link.hasClass('hover')) {
            return true;
        } else {
            link.addClass("hover");
            $('.ih-item.square.effect4 a').not(this).removeClass("hover");
            e.preventDefault();
            return false; //extra, and to make sure the function has consistent return points
        }
    });

    $('.referenzen a').on("touchstart", function (e) {
        "use strict"; //satisfy the code inspectors
        var link = $(this); //preselect the link
        if (link.hasClass('hover')) {
            return true;
        } else {
            link.addClass("hover");
            $('.referenzen a').not(this).removeClass("hover");
            e.preventDefault();
            return false; //extra, and to make sure the function has consistent return points
        }
    });
});
$(document).ready(function () {
    $('[data-toggle="offcanvas"]').click(function () {
        $('.row-offcanvas').toggleClass('active')
    });
});
/*
 * jQuery FlexSlider v2.6.0
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
;
(function ($) {

    var focused = true;

    //FlexSlider: Object Instance
    $.flexslider = function (el, options) {
        var slider = $(el);

        // making variables public
        slider.vars = $.extend({}, $.flexslider.defaults, options);

        var namespace = slider.vars.namespace,
            msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,
            touch = (("ontouchstart" in window) || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,
            // depricating this idea, as devices are being released with both of these events
            eventType = "click touchend MSPointerUp keyup",
            watchedEvent = "",
            watchedEventClearTimer,
            vertical = slider.vars.direction === "vertical",
            reverse = slider.vars.reverse,
            carousel = (slider.vars.itemWidth > 0),
            fade = slider.vars.animation === "fade",
            asNav = slider.vars.asNavFor !== "",
            methods = {};

        // Store a reference to the slider object
        $.data(el, "flexslider", slider);

        // Private slider methods
        methods = {
            init: function () {
                slider.animating = false;
                // Get current slide and make sure it is a number
                slider.currentSlide = parseInt((slider.vars.startAt ? slider.vars.startAt : 0), 10);
                if (isNaN(slider.currentSlide)) {
                    slider.currentSlide = 0;
                }
                slider.animatingTo = slider.currentSlide;
                slider.atEnd = (slider.currentSlide === 0 || slider.currentSlide === slider.last);
                slider.containerSelector = slider.vars.selector.substr(0, slider.vars.selector.search(' '));
                slider.slides = $(slider.vars.selector, slider);
                slider.container = $(slider.containerSelector, slider);
                slider.count = slider.slides.length;
                // SYNC:
                slider.syncExists = $(slider.vars.sync).length > 0;
                // SLIDE:
                if (slider.vars.animation === "slide") {
                    slider.vars.animation = "swing";
                }
                slider.prop = (vertical) ? "top" : "marginLeft";
                slider.args = {};
                // SLIDESHOW:
                slider.manualPause = false;
                slider.stopped = false;
                //PAUSE WHEN INVISIBLE
                slider.started = false;
                slider.startTimeout = null;
                // TOUCH/USECSS:
                slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && (function () {
                    var obj = document.createElement('div'),
                        props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
                    for (var i in props) {
                        if (obj.style[props[i]] !== undefined) {
                            slider.pfx = props[i].replace('Perspective', '').toLowerCase();
                            slider.prop = "-" + slider.pfx + "-transform";
                            return true;
                        }
                    }
                    return false;
                }());
                slider.ensureAnimationEnd = '';
                // CONTROLSCONTAINER:
                if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer);
                // MANUAL:
                if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls);

                // CUSTOM DIRECTION NAV:
                if (slider.vars.customDirectionNav !== "") slider.customDirectionNav = $(slider.vars.customDirectionNav).length === 2 && $(slider.vars.customDirectionNav);

                // RANDOMIZE:
                if (slider.vars.randomize) {
                    slider.slides.sort(function () {
                        return (Math.round(Math.random()) - 0.5);
                    });
                    slider.container.empty().append(slider.slides);
                }

                slider.doMath();

                // INIT
                slider.setup("init");

                // CONTROLNAV:
                if (slider.vars.controlNav) {
                    methods.controlNav.setup();
                }

                // DIRECTIONNAV:
                if (slider.vars.directionNav) {
                    methods.directionNav.setup();
                }

                // KEYBOARD:
                if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
                    $(document).bind('keyup', function (event) {
                        var keycode = event.keyCode;
                        if (!slider.animating && (keycode === 39 || keycode === 37)) {
                            var target = (keycode === 39) ? slider.getTarget('next') :
                                (keycode === 37) ? slider.getTarget('prev') : false;
                            slider.flexAnimate(target, slider.vars.pauseOnAction);
                        }
                    });
                }
                // MOUSEWHEEL:
                if (slider.vars.mousewheel) {
                    slider.bind('mousewheel', function (event, delta, deltaX, deltaY) {
                        event.preventDefault();
                        var target = (delta < 0) ? slider.getTarget('next') : slider.getTarget('prev');
                        slider.flexAnimate(target, slider.vars.pauseOnAction);
                    });
                }

                // PAUSEPLAY
                if (slider.vars.pausePlay) {
                    methods.pausePlay.setup();
                }

                //PAUSE WHEN INVISIBLE
                if (slider.vars.slideshow && slider.vars.pauseInvisible) {
                    methods.pauseInvisible.init();
                }

                // SLIDSESHOW
                if (slider.vars.slideshow) {
                    if (slider.vars.pauseOnHover) {
                        slider.hover(function () {
                            if (!slider.manualPlay && !slider.manualPause) {
                                slider.pause();
                            }
                        }, function () {
                            if (!slider.manualPause && !slider.manualPlay && !slider.stopped) {
                                slider.play();
                            }
                        });
                    }
                    // initialize animation
                    //If we're visible, or we don't use PageVisibility API
                    if (!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
                        (slider.vars.initDelay > 0) ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay): slider.play();
                    }
                }

                // ASNAV:
                if (asNav) {
                    methods.asNav.setup();
                }

                // TOUCH
                if (touch && slider.vars.touch) {
                    methods.touch();
                }

                // FADE&&SMOOTHHEIGHT || SLIDE:
                if (!fade || (fade && slider.vars.smoothHeight)) {
                    $(window).bind("resize orientationchange focus", methods.resize);
                }

                slider.find("img").attr("draggable", "false");

                // API: start() Callback
                setTimeout(function () {
                    slider.vars.start(slider);
                }, 200);
            },
            asNav: {
                setup: function () {
                    slider.asNav = true;
                    slider.animatingTo = Math.floor(slider.currentSlide / slider.move);
                    slider.currentItem = slider.currentSlide;
                    slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");
                    if (!msGesture) {
                        slider.slides.on(eventType, function (e) {
                            e.preventDefault();
                            var $slide = $(this),
                                target = $slide.index();
                            var posFromLeft = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container
                            if (posFromLeft <= 0 && $slide.hasClass(namespace + 'active-slide')) {
                                slider.flexAnimate(slider.getTarget("prev"), true);
                            } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + "active-slide")) {
                                slider.direction = (slider.currentItem < target) ? "next" : "prev";
                                slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                            }
                        });
                    } else {
                        el._slider = slider;
                        slider.slides.each(function () {
                            var that = this;
                            that._gesture = new MSGesture();
                            that._gesture.target = that;
                            that.addEventListener("MSPointerDown", function (e) {
                                e.preventDefault();
                                if (e.currentTarget._gesture) {
                                    e.currentTarget._gesture.addPointer(e.pointerId);
                                }
                            }, false);
                            that.addEventListener("MSGestureTap", function (e) {
                                e.preventDefault();
                                var $slide = $(this),
                                    target = $slide.index();
                                if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {
                                    slider.direction = (slider.currentItem < target) ? "next" : "prev";
                                    slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                                }
                            });
                        });
                    }
                }
            },
            controlNav: {
                setup: function () {
                    if (!slider.manualControls) {
                        methods.controlNav.setupPaging();
                    } else { // MANUALCONTROLS:
                        methods.controlNav.setupManual();
                    }
                },
                setupPaging: function () {
                    var type = (slider.vars.controlNav === "thumbnails") ? 'control-thumbs' : 'control-paging',
                        j = 1,
                        item,
                        slide;

                    slider.controlNavScaffold = $('<ol class="' + namespace + 'control-nav ' + namespace + type + '"></ol>');

                    if (slider.pagingCount > 1) {
                        for (var i = 0; i < slider.pagingCount; i++) {
                            slide = slider.slides.eq(i);
                            if (undefined === slide.attr('data-thumb-alt')) {
                                slide.attr('data-thumb-alt', '');
                            }
                            altText = ('' !== slide.attr('data-thumb-alt')) ? altText = ' alt="' + slide.attr('data-thumb-alt') + '"' : '';
                            item = (slider.vars.controlNav === "thumbnails") ? '<img src="' + slide.attr('data-thumb') + '"' + altText + '/>' : '<a href="#">' + j + '</a>';
                            if ('thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions) {
                                var captn = slide.attr('data-thumbcaption');
                                if ('' !== captn && undefined !== captn) {
                                    item += '<span class="' + namespace + 'caption">' + captn + '</span>';
                                }
                            }
                            slider.controlNavScaffold.append('<li>' + item + '</li>');
                            j++;
                        }
                    }

                    // CONTROLSCONTAINER:
                    (slider.controlsContainer) ? $(slider.controlsContainer).append(slider.controlNavScaffold): slider.append(slider.controlNavScaffold);
                    methods.controlNav.set();

                    methods.controlNav.active();

                    slider.controlNavScaffold.delegate('a, img', eventType, function (event) {
                        event.preventDefault();

                        if (watchedEvent === "" || watchedEvent === event.type) {
                            var $this = $(this),
                                target = slider.controlNav.index($this);

                            if (!$this.hasClass(namespace + 'active')) {
                                slider.direction = (target > slider.currentSlide) ? "next" : "prev";
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            }
                        }

                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();

                    });
                },
                setupManual: function () {
                    slider.controlNav = slider.manualControls;
                    methods.controlNav.active();

                    slider.controlNav.bind(eventType, function (event) {
                        event.preventDefault();

                        if (watchedEvent === "" || watchedEvent === event.type) {
                            var $this = $(this),
                                target = slider.controlNav.index($this);

                            if (!$this.hasClass(namespace + 'active')) {
                                (target > slider.currentSlide) ? slider.direction = "next": slider.direction = "prev";
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            }
                        }

                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();
                    });
                },
                set: function () {
                    var selector = (slider.vars.controlNav === "thumbnails") ? 'img' : 'a';
                    slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, (slider.controlsContainer) ? slider.controlsContainer : slider);
                },
                active: function () {
                    slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
                },
                update: function (action, pos) {
                    if (slider.pagingCount > 1 && action === "add") {
                        slider.controlNavScaffold.append($('<li><a href="#">' + slider.count + '</a></li>'));
                    } else if (slider.pagingCount === 1) {
                        slider.controlNavScaffold.find('li').remove();
                    } else {
                        slider.controlNav.eq(pos).closest('li').remove();
                    }
                    methods.controlNav.set();
                    (slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length) ? slider.update(pos, action): methods.controlNav.active();
                }
            },
            directionNav: {
                setup: function () {
                    var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li class="' + namespace + 'nav-prev"><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li class="' + namespace + 'nav-next"><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + '</a></li></ul>');

                    // CUSTOM DIRECTION NAV:
                    if (slider.customDirectionNav) {
                        slider.directionNav = slider.customDirectionNav;
                        // CONTROLSCONTAINER:
                    } else if (slider.controlsContainer) {
                        $(slider.controlsContainer).append(directionNavScaffold);
                        slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
                    } else {
                        slider.append(directionNavScaffold);
                        slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
                    }

                    methods.directionNav.update();

                    slider.directionNav.bind(eventType, function (event) {
                        event.preventDefault();
                        var target;

                        if (watchedEvent === "" || watchedEvent === event.type) {
                            target = ($(this).hasClass(namespace + 'next')) ? slider.getTarget('next') : slider.getTarget('prev');
                            slider.flexAnimate(target, slider.vars.pauseOnAction);
                        }

                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();
                    });
                },
                update: function () {
                    var disabledClass = namespace + 'disabled';
                    if (slider.pagingCount === 1) {
                        slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');
                    } else if (!slider.vars.animationLoop) {
                        if (slider.animatingTo === 0) {
                            slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "prev").addClass(disabledClass).attr('tabindex', '-1');
                        } else if (slider.animatingTo === slider.last) {
                            slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "next").addClass(disabledClass).attr('tabindex', '-1');
                        } else {
                            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
                        }
                    } else {
                        slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
                    }
                }
            },
            pausePlay: {
                setup: function () {
                    var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a href="#"></a></div>');

                    // CONTROLSCONTAINER:
                    if (slider.controlsContainer) {
                        slider.controlsContainer.append(pausePlayScaffold);
                        slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
                    } else {
                        slider.append(pausePlayScaffold);
                        slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
                    }

                    methods.pausePlay.update((slider.vars.slideshow) ? namespace + 'pause' : namespace + 'play');

                    slider.pausePlay.bind(eventType, function (event) {
                        event.preventDefault();

                        if (watchedEvent === "" || watchedEvent === event.type) {
                            if ($(this).hasClass(namespace + 'pause')) {
                                slider.manualPause = true;
                                slider.manualPlay = false;
                                slider.pause();
                            } else {
                                slider.manualPause = false;
                                slider.manualPlay = true;
                                slider.play();
                            }
                        }

                        // setup flags to prevent event duplication
                        if (watchedEvent === "") {
                            watchedEvent = event.type;
                        }
                        methods.setToClearWatchedEvent();
                    });
                },
                update: function (state) {
                    (state === "play") ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText): slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);
                }
            },
            touch: function () {
                var startX,
                    startY,
                    offset,
                    cwidth,
                    dx,
                    startT,
                    onTouchStart,
                    onTouchMove,
                    onTouchEnd,
                    scrolling = false,
                    localX = 0,
                    localY = 0,
                    accDx = 0;

                if (!msGesture) {
                    onTouchStart = function (e) {
                        if (slider.animating) {
                            e.preventDefault();
                        } else if ((window.navigator.msPointerEnabled) || e.touches.length === 1) {
                            slider.pause();
                            // CAROUSEL:
                            cwidth = (vertical) ? slider.h : slider.w;
                            startT = Number(new Date());
                            // CAROUSEL:

                            // Local vars for X and Y points.
                            localX = e.touches[0].pageX;
                            localY = e.touches[0].pageY;

                            offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                                (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                                (carousel && slider.currentSlide === slider.last) ? slider.limit :
                                (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                                (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                            startX = (vertical) ? localY : localX;
                            startY = (vertical) ? localX : localY;

                            el.addEventListener('touchmove', onTouchMove, false);
                            el.addEventListener('touchend', onTouchEnd, false);
                        }
                    };

                    onTouchMove = function (e) {
                        // Local vars for X and Y points.

                        localX = e.touches[0].pageX;
                        localY = e.touches[0].pageY;

                        dx = (vertical) ? startX - localY : startX - localX;
                        scrolling = (vertical) ? (Math.abs(dx) < Math.abs(localX - startY)) : (Math.abs(dx) < Math.abs(localY - startY));

                        var fxms = 500;

                        if (!scrolling || Number(new Date()) - startT > fxms) {
                            e.preventDefault();
                            if (!fade && slider.transitions) {
                                if (!slider.vars.animationLoop) {
                                    dx = dx / ((slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0) ? (Math.abs(dx) / cwidth + 2) : 1);
                                }
                                slider.setProps(offset + dx, "setTouch");
                            }
                        }
                    };

                    onTouchEnd = function (e) {
                        // finish the touch by undoing the touch session
                        el.removeEventListener('touchmove', onTouchMove, false);

                        if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                            var updateDx = (reverse) ? -dx : dx,
                                target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                            if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            } else {
                                if (!fade) {
                                    slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                                }
                            }
                        }
                        el.removeEventListener('touchend', onTouchEnd, false);

                        startX = null;
                        startY = null;
                        dx = null;
                        offset = null;
                    };

                    el.addEventListener('touchstart', onTouchStart, false);
                } else {
                    el.style.msTouchAction = "none";
                    el._gesture = new MSGesture();
                    el._gesture.target = el;
                    el.addEventListener("MSPointerDown", onMSPointerDown, false);
                    el._slider = slider;
                    el.addEventListener("MSGestureChange", onMSGestureChange, false);
                    el.addEventListener("MSGestureEnd", onMSGestureEnd, false);

                    function onMSPointerDown(e) {
                        e.stopPropagation();
                        if (slider.animating) {
                            e.preventDefault();
                        } else {
                            slider.pause();
                            el._gesture.addPointer(e.pointerId);
                            accDx = 0;
                            cwidth = (vertical) ? slider.h : slider.w;
                            startT = Number(new Date());
                            // CAROUSEL:

                            offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                                (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                                (carousel && slider.currentSlide === slider.last) ? slider.limit :
                                (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                                (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                        }
                    }

                    function onMSGestureChange(e) {
                        e.stopPropagation();
                        var slider = e.target._slider;
                        if (!slider) {
                            return;
                        }
                        var transX = -e.translationX,
                            transY = -e.translationY;

                        //Accumulate translations.
                        accDx = accDx + ((vertical) ? transY : transX);
                        dx = accDx;
                        scrolling = (vertical) ? (Math.abs(accDx) < Math.abs(-transX)) : (Math.abs(accDx) < Math.abs(-transY));

                        if (e.detail === e.MSGESTURE_FLAG_INERTIA) {
                            setImmediate(function () {
                                el._gesture.stop();
                            });

                            return;
                        }

                        if (!scrolling || Number(new Date()) - startT > 500) {
                            e.preventDefault();
                            if (!fade && slider.transitions) {
                                if (!slider.vars.animationLoop) {
                                    dx = accDx / ((slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0) ? (Math.abs(accDx) / cwidth + 2) : 1);
                                }
                                slider.setProps(offset + dx, "setTouch");
                            }
                        }
                    }

                    function onMSGestureEnd(e) {
                        e.stopPropagation();
                        var slider = e.target._slider;
                        if (!slider) {
                            return;
                        }
                        if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                            var updateDx = (reverse) ? -dx : dx,
                                target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                            if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                                slider.flexAnimate(target, slider.vars.pauseOnAction);
                            } else {
                                if (!fade) {
                                    slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                                }
                            }
                        }

                        startX = null;
                        startY = null;
                        dx = null;
                        offset = null;
                        accDx = 0;
                    }
                }
            },
            resize: function () {
                if (!slider.animating && slider.is(':visible')) {
                    if (!carousel) {
                        slider.doMath();
                    }

                    if (fade) {
                        // SMOOTH HEIGHT:
                        methods.smoothHeight();
                    } else if (carousel) { //CAROUSEL:
                        slider.slides.width(slider.computedW);
                        slider.update(slider.pagingCount);
                        slider.setProps();
                    } else if (vertical) { //VERTICAL:
                        slider.viewport.height(slider.h);
                        slider.setProps(slider.h, "setTotal");
                    } else {
                        // SMOOTH HEIGHT:
                        if (slider.vars.smoothHeight) {
                            methods.smoothHeight();
                        }
                        slider.newSlides.width(slider.computedW);
                        slider.setProps(slider.computedW, "setTotal");
                    }
                }
            },
            smoothHeight: function (dur) {
                if (!vertical || fade) {
                    var $obj = (fade) ? slider : slider.viewport;
                    (dur) ? $obj.animate({
                        "height": slider.slides.eq(slider.animatingTo).height()
                    }, dur): $obj.height(slider.slides.eq(slider.animatingTo).height());
                }
            },
            sync: function (action) {
                var $obj = $(slider.vars.sync).data("flexslider"),
                    target = slider.animatingTo;

                switch (action) {
                    case "animate":
                        $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true);
                        break;
                    case "play":
                        if (!$obj.playing && !$obj.asNav) {
                            $obj.play();
                        }
                        break;
                    case "pause":
                        $obj.pause();
                        break;
                }
            },
            uniqueID: function ($clone) {
                // Append _clone to current level and children elements with id attributes
                $clone.filter('[id]').add($clone.find('[id]')).each(function () {
                    var $this = $(this);
                    $this.attr('id', $this.attr('id') + '_clone');
                });
                return $clone;
            },
            pauseInvisible: {
                visProp: null,
                init: function () {
                    var visProp = methods.pauseInvisible.getHiddenProp();
                    if (visProp) {
                        var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange';
                        document.addEventListener(evtname, function () {
                            if (methods.pauseInvisible.isHidden()) {
                                if (slider.startTimeout) {
                                    clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible
                                } else {
                                    slider.pause(); //Or just pause
                                }
                            } else {
                                if (slider.started) {
                                    slider.play(); //Initiated before, just play
                                } else {
                                    if (slider.vars.initDelay > 0) {
                                        setTimeout(slider.play, slider.vars.initDelay);
                                    } else {
                                        slider.play(); //Didn't init before: simply init or wait for it
                                    }
                                }
                            }
                        });
                    }
                },
                isHidden: function () {
                    var prop = methods.pauseInvisible.getHiddenProp();
                    if (!prop) {
                        return false;
                    }
                    return document[prop];
                },
                getHiddenProp: function () {
                    var prefixes = ['webkit', 'moz', 'ms', 'o'];
                    // if 'hidden' is natively supported just return it
                    if ('hidden' in document) {
                        return 'hidden';
                    }
                    // otherwise loop over all the known prefixes until we find one
                    for (var i = 0; i < prefixes.length; i++) {
                        if ((prefixes[i] + 'Hidden') in document) {
                            return prefixes[i] + 'Hidden';
                        }
                    }
                    // otherwise it's not supported
                    return null;
                }
            },
            setToClearWatchedEvent: function () {
                clearTimeout(watchedEventClearTimer);
                watchedEventClearTimer = setTimeout(function () {
                    watchedEvent = "";
                }, 3000);
            }
        };

        // public methods
        slider.flexAnimate = function (target, pause, override, withSync, fromNav) {
            if (!slider.vars.animationLoop && target !== slider.currentSlide) {
                slider.direction = (target > slider.currentSlide) ? "next" : "prev";
            }

            if (asNav && slider.pagingCount === 1) slider.direction = (slider.currentItem < target) ? "next" : "prev";

            if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
                if (asNav && withSync) {
                    var master = $(slider.vars.asNavFor).data('flexslider');
                    slider.atEnd = target === 0 || target === slider.count - 1;
                    master.flexAnimate(target, true, false, true, fromNav);
                    slider.direction = (slider.currentItem < target) ? "next" : "prev";
                    master.direction = slider.direction;

                    if (Math.ceil((target + 1) / slider.visible) - 1 !== slider.currentSlide && target !== 0) {
                        slider.currentItem = target;
                        slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
                        target = Math.floor(target / slider.visible);
                    } else {
                        slider.currentItem = target;
                        slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
                        return false;
                    }
                }

                slider.animating = true;
                slider.animatingTo = target;

                // SLIDESHOW:
                if (pause) {
                    slider.pause();
                }

                // API: before() animation Callback
                slider.vars.before(slider);

                // SYNC:
                if (slider.syncExists && !fromNav) {
                    methods.sync("animate");
                }

                // CONTROLNAV
                if (slider.vars.controlNav) {
                    methods.controlNav.active();
                }

                // !CAROUSEL:
                // CANDIDATE: slide active class (for add/remove slide)
                if (!carousel) {
                    slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');
                }

                // INFINITE LOOP:
                // CANDIDATE: atEnd
                slider.atEnd = target === 0 || target === slider.last;

                // DIRECTIONNAV:
                if (slider.vars.directionNav) {
                    methods.directionNav.update();
                }

                if (target === slider.last) {
                    // API: end() of cycle Callback
                    slider.vars.end(slider);
                    // SLIDESHOW && !INFINITE LOOP:
                    if (!slider.vars.animationLoop) {
                        slider.pause();
                    }
                }

                // SLIDE:
                if (!fade) {
                    var dimension = (vertical) ? slider.slides.filter(':first').height() : slider.computedW,
                        margin, slideString, calcNext;

                    // INFINITE LOOP / REVERSE:
                    if (carousel) {
                        margin = slider.vars.itemMargin;
                        calcNext = ((slider.itemW + margin) * slider.move) * slider.animatingTo;
                        slideString = (calcNext > slider.limit && slider.visible !== 1) ? slider.limit : calcNext;
                    } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
                        slideString = (reverse) ? (slider.count + slider.cloneOffset) * dimension : 0;
                    } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
                        slideString = (reverse) ? 0 : (slider.count + 1) * dimension;
                    } else {
                        slideString = (reverse) ? ((slider.count - 1) - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
                    }
                    slider.setProps(slideString, "", slider.vars.animationSpeed);
                    if (slider.transitions) {
                        if (!slider.vars.animationLoop || !slider.atEnd) {
                            slider.animating = false;
                            slider.currentSlide = slider.animatingTo;
                        }

                        // Unbind previous transitionEnd events and re-bind new transitionEnd event
                        slider.container.unbind("webkitTransitionEnd transitionend");
                        slider.container.bind("webkitTransitionEnd transitionend", function () {
                            clearTimeout(slider.ensureAnimationEnd);
                            slider.wrapup(dimension);
                        });

                        // Insurance for the ever-so-fickle transitionEnd event
                        clearTimeout(slider.ensureAnimationEnd);
                        slider.ensureAnimationEnd = setTimeout(function () {
                            slider.wrapup(dimension);
                        }, slider.vars.animationSpeed + 100);

                    } else {
                        slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function () {
                            slider.wrapup(dimension);
                        });
                    }
                } else { // FADE:
                    if (!touch) {
                        //slider.slides.eq(slider.currentSlide).fadeOut(slider.vars.animationSpeed, slider.vars.easing);
                        //slider.slides.eq(target).fadeIn(slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

                        slider.slides.eq(slider.currentSlide).css({
                            "zIndex": 1
                        }).animate({
                            "opacity": 0
                        }, slider.vars.animationSpeed, slider.vars.easing);
                        slider.slides.eq(target).css({
                            "zIndex": 2
                        }).animate({
                            "opacity": 1
                        }, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

                    } else {
                        slider.slides.eq(slider.currentSlide).css({
                            "opacity": 0,
                            "zIndex": 1
                        });
                        slider.slides.eq(target).css({
                            "opacity": 1,
                            "zIndex": 2
                        });
                        slider.wrapup(dimension);
                    }
                }
                // SMOOTH HEIGHT:
                if (slider.vars.smoothHeight) {
                    methods.smoothHeight(slider.vars.animationSpeed);
                }
            }
        };
        slider.wrapup = function (dimension) {
            // SLIDE:
            if (!fade && !carousel) {
                if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
                    slider.setProps(dimension, "jumpEnd");
                } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
                    slider.setProps(dimension, "jumpStart");
                }
            }
            slider.animating = false;
            slider.currentSlide = slider.animatingTo;
            // API: after() animation Callback
            slider.vars.after(slider);
        };

        // SLIDESHOW:
        slider.animateSlides = function () {
            if (!slider.animating && focused) {
                slider.flexAnimate(slider.getTarget("next"));
            }
        };
        // SLIDESHOW:
        slider.pause = function () {
            clearInterval(slider.animatedSlides);
            slider.animatedSlides = null;
            slider.playing = false;
            // PAUSEPLAY:
            if (slider.vars.pausePlay) {
                methods.pausePlay.update("play");
            }
            // SYNC:
            if (slider.syncExists) {
                methods.sync("pause");
            }
        };
        // SLIDESHOW:
        slider.play = function () {
            if (slider.playing) {
                clearInterval(slider.animatedSlides);
            }
            slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
            slider.started = slider.playing = true;
            // PAUSEPLAY:
            if (slider.vars.pausePlay) {
                methods.pausePlay.update("pause");
            }
            // SYNC:
            if (slider.syncExists) {
                methods.sync("play");
            }
        };
        // STOP:
        slider.stop = function () {
            slider.pause();
            slider.stopped = true;
        };
        slider.canAdvance = function (target, fromNav) {
            // ASNAV:
            var last = (asNav) ? slider.pagingCount - 1 : slider.last;
            return (fromNav) ? true :
                (asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev") ? true :
                (asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next") ? false :
                (target === slider.currentSlide && !asNav) ? false :
                (slider.vars.animationLoop) ? true :
                (slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next") ? false :
                (slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next") ? false :
                true;
        };
        slider.getTarget = function (dir) {
            slider.direction = dir;
            if (dir === "next") {
                return (slider.currentSlide === slider.last) ? 0 : slider.currentSlide + 1;
            } else {
                return (slider.currentSlide === 0) ? slider.last : slider.currentSlide - 1;
            }
        };

        // SLIDE:
        slider.setProps = function (pos, special, dur) {
            var target = (function () {
                var posCheck = (pos) ? pos : ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo,
                    posCalc = (function () {
                        if (carousel) {
                            return (special === "setTouch") ? pos :
                                (reverse && slider.animatingTo === slider.last) ? 0 :
                                (reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                                (slider.animatingTo === slider.last) ? slider.limit : posCheck;
                        } else {
                            switch (special) {
                                case "setTotal":
                                    return (reverse) ? ((slider.count - 1) - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;
                                case "setTouch":
                                    return (reverse) ? pos : pos;
                                case "jumpEnd":
                                    return (reverse) ? pos : slider.count * pos;
                                case "jumpStart":
                                    return (reverse) ? slider.count * pos : pos;
                                default:
                                    return pos;
                            }
                        }
                    }());

                return (posCalc * -1) + "px";
            }());

            if (slider.transitions) {
                target = (vertical) ? "translate3d(0," + target + ",0)" : "translate3d(" + target + ",0,0)";
                dur = (dur !== undefined) ? (dur / 1000) + "s" : "0s";
                slider.container.css("-" + slider.pfx + "-transition-duration", dur);
                slider.container.css("transition-duration", dur);
            }

            slider.args[slider.prop] = target;
            if (slider.transitions || dur === undefined) {
                slider.container.css(slider.args);
            }

            slider.container.css('transform', target);
        };

        slider.setup = function (type) {
            // SLIDE:
            if (!fade) {
                var sliderOffset, arr;

                if (type === "init") {
                    slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({
                        "overflow": "hidden",
                        "position": "relative"
                    }).appendTo(slider).append(slider.container);
                    // INFINITE LOOP:
                    slider.cloneCount = 0;
                    slider.cloneOffset = 0;
                    // REVERSE:
                    if (reverse) {
                        arr = $.makeArray(slider.slides).reverse();
                        slider.slides = $(arr);
                        slider.container.empty().append(slider.slides);
                    }
                }
                // INFINITE LOOP && !CAROUSEL:
                if (slider.vars.animationLoop && !carousel) {
                    slider.cloneCount = 2;
                    slider.cloneOffset = 1;
                    // clear out old clones
                    if (type !== "init") {
                        slider.container.find('.clone').remove();
                    }
                    slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true'))
                        .prepend(methods.uniqueID(slider.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'));
                }
                slider.newSlides = $(slider.vars.selector, slider);

                sliderOffset = (reverse) ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset;
                // VERTICAL:
                if (vertical && !carousel) {
                    slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
                    setTimeout(function () {
                        slider.newSlides.css({
                            "display": "block"
                        });
                        slider.doMath();
                        slider.viewport.height(slider.h);
                        slider.setProps(sliderOffset * slider.h, "init");
                    }, (type === "init") ? 100 : 0);
                } else {
                    slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
                    slider.setProps(sliderOffset * slider.computedW, "init");
                    setTimeout(function () {
                        slider.doMath();
                        slider.newSlides.css({
                            "width": slider.computedW,
                            "marginRight": slider.computedM,
                            "float": "left",
                            "display": "block"
                        });
                        // SMOOTH HEIGHT:
                        if (slider.vars.smoothHeight) {
                            methods.smoothHeight();
                        }
                    }, (type === "init") ? 100 : 0);
                }
            } else { // FADE:
                slider.slides.css({
                    "width": "100%",
                    "float": "left",
                    "marginRight": "-100%",
                    "position": "relative"
                });
                if (type === "init") {
                    if (!touch) {
                        //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
                        if (slider.vars.fadeFirstSlide == false) {
                            slider.slides.css({
                                "opacity": 0,
                                "display": "block",
                                "zIndex": 1
                            }).eq(slider.currentSlide).css({
                                "zIndex": 2
                            }).css({
                                "opacity": 1
                            });
                        } else {
                            slider.slides.css({
                                "opacity": 0,
                                "display": "block",
                                "zIndex": 1
                            }).eq(slider.currentSlide).css({
                                "zIndex": 2
                            }).animate({
                                "opacity": 1
                            }, slider.vars.animationSpeed, slider.vars.easing);
                        }
                    } else {
                        slider.slides.css({
                            "opacity": 0,
                            "display": "block",
                            "webkitTransition": "opacity " + slider.vars.animationSpeed / 1000 + "s ease",
                            "zIndex": 1
                        }).eq(slider.currentSlide).css({
                            "opacity": 1,
                            "zIndex": 2
                        });
                    }
                }
                // SMOOTH HEIGHT:
                if (slider.vars.smoothHeight) {
                    methods.smoothHeight();
                }
            }
            // !CAROUSEL:
            // CANDIDATE: active slide
            if (!carousel) {
                slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");
            }

            //FlexSlider: init() Callback
            slider.vars.init(slider);
        };

        slider.doMath = function () {
            var slide = slider.slides.first(),
                slideMargin = slider.vars.itemMargin,
                minItems = slider.vars.minItems,
                maxItems = slider.vars.maxItems;

            slider.w = (slider.viewport === undefined) ? slider.width() : slider.viewport.width();
            slider.h = slide.height();
            slider.boxPadding = slide.outerWidth() - slide.width();

            // CAROUSEL:
            if (carousel) {
                slider.itemT = slider.vars.itemWidth + slideMargin;
                slider.itemM = slideMargin;
                slider.minW = (minItems) ? minItems * slider.itemT : slider.w;
                slider.maxW = (maxItems) ? (maxItems * slider.itemT) - slideMargin : slider.w;
                slider.itemW = (slider.minW > slider.w) ? (slider.w - (slideMargin * (minItems - 1))) / minItems :
                    (slider.maxW < slider.w) ? (slider.w - (slideMargin * (maxItems - 1))) / maxItems :
                    (slider.vars.itemWidth > slider.w) ? slider.w : slider.vars.itemWidth;

                slider.visible = Math.floor(slider.w / (slider.itemW));
                slider.move = (slider.vars.move > 0 && slider.vars.move < slider.visible) ? slider.vars.move : slider.visible;
                slider.pagingCount = Math.ceil(((slider.count - slider.visible) / slider.move) + 1);
                slider.last = slider.pagingCount - 1;
                slider.limit = (slider.pagingCount === 1) ? 0 :
                    (slider.vars.itemWidth > slider.w) ? (slider.itemW * (slider.count - 1)) + (slideMargin * (slider.count - 1)) : ((slider.itemW + slideMargin) * slider.count) - slider.w - slideMargin;
            } else {
                slider.itemW = slider.w;
                slider.itemM = slideMargin;
                slider.pagingCount = slider.count;
                slider.last = slider.count - 1;
            }
            slider.computedW = slider.itemW - slider.boxPadding;
            slider.computedM = slider.itemM;
        };

        slider.update = function (pos, action) {
            slider.doMath();

            // update currentSlide and slider.animatingTo if necessary
            if (!carousel) {
                if (pos < slider.currentSlide) {
                    slider.currentSlide += 1;
                } else if (pos <= slider.currentSlide && pos !== 0) {
                    slider.currentSlide -= 1;
                }
                slider.animatingTo = slider.currentSlide;
            }

            // update controlNav
            if (slider.vars.controlNav && !slider.manualControls) {
                if ((action === "add" && !carousel) || slider.pagingCount > slider.controlNav.length) {
                    methods.controlNav.update("add");
                } else if ((action === "remove" && !carousel) || slider.pagingCount < slider.controlNav.length) {
                    if (carousel && slider.currentSlide > slider.last) {
                        slider.currentSlide -= 1;
                        slider.animatingTo -= 1;
                    }
                    methods.controlNav.update("remove", slider.last);
                }
            }
            // update directionNav
            if (slider.vars.directionNav) {
                methods.directionNav.update();
            }

        };

        slider.addSlide = function (obj, pos) {
            var $obj = $(obj);

            slider.count += 1;
            slider.last = slider.count - 1;

            // append new slide
            if (vertical && reverse) {
                (pos !== undefined) ? slider.slides.eq(slider.count - pos).after($obj): slider.container.prepend($obj);
            } else {
                (pos !== undefined) ? slider.slides.eq(pos).before($obj): slider.container.append($obj);
            }

            // update currentSlide, animatingTo, controlNav, and directionNav
            slider.update(pos, "add");

            // update slider.slides
            slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
            // re-setup the slider to accomdate new slide
            slider.setup();

            //FlexSlider: added() Callback
            slider.vars.added(slider);
        };
        slider.removeSlide = function (obj) {
            var pos = (isNaN(obj)) ? slider.slides.index($(obj)) : obj;

            // update count
            slider.count -= 1;
            slider.last = slider.count - 1;

            // remove slide
            if (isNaN(obj)) {
                $(obj, slider.slides).remove();
            } else {
                (vertical && reverse) ? slider.slides.eq(slider.last).remove(): slider.slides.eq(obj).remove();
            }

            // update currentSlide, animatingTo, controlNav, and directionNav
            slider.doMath();
            slider.update(pos, "remove");

            // update slider.slides
            slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
            // re-setup the slider to accomdate new slide
            slider.setup();

            // FlexSlider: removed() Callback
            slider.vars.removed(slider);
        };

        //FlexSlider: Initialize
        methods.init();
    };

    // Ensure the slider isn't focussed if the window loses focus.
    $(window).blur(function (e) {
        focused = false;
    }).focus(function (e) {
        focused = true;
    });

    //FlexSlider: Default Settings
    $.flexslider.defaults = {
        namespace: "flex-", //{NEW} String: Prefix string attached to the class of every element generated by the plugin
        selector: ".slides > li", //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
        animation: "fade", //String: Select your animation type, "fade" or "slide"
        easing: "swing", //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
        direction: "horizontal", //String: Select the sliding direction, "horizontal" or "vertical"
        reverse: false, //{NEW} Boolean: Reverse the animation direction
        animationLoop: true, //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
        smoothHeight: false, //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
        startAt: 0, //Integer: The slide that the slider should start on. Array notation (0 = first slide)
        slideshow: true, //Boolean: Animate slider automatically
        slideshowSpeed: 7000, //Integer: Set the speed of the slideshow cycling, in milliseconds
        animationSpeed: 600, //Integer: Set the speed of animations, in milliseconds
        initDelay: 0, //{NEW} Integer: Set an initialization delay, in milliseconds
        randomize: false, //Boolean: Randomize slide order
        fadeFirstSlide: true, //Boolean: Fade in the first slide when animation type is "fade"
        thumbCaptions: false, //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.

        // Usability features
        pauseOnAction: true, //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
        pauseOnHover: false, //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
        pauseInvisible: true, //{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
        useCSS: true, //{NEW} Boolean: Slider will use CSS3 transitions if available
        touch: true, //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
        video: false, //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches

        // Primary Controls
        controlNav: true, //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage
        directionNav: true, //Boolean: Create navigation for previous/next navigation? (true/false)
        prevText: "Previous", //String: Set the text for the "previous" directionNav item
        nextText: "Next", //String: Set the text for the "next" directionNav item

        // Secondary Navigation
        keyboard: true, //Boolean: Allow slider navigating via keyboard left/right keys
        multipleKeyboard: false, //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
        mousewheel: false, //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
        pausePlay: false, //Boolean: Create pause/play dynamic element  !!!!!!!
        pauseText: "Pause", //String: Set the text for the "pause" pausePlay item
        playText: "Play", //String: Set the text for the "play" pausePlay item

        // Special properties
        controlsContainer: "", //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
        manualControls: "", //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
        customDirectionNav: "", //{NEW} jQuery Object/Selector: Custom prev / next button. Must be two jQuery elements. In order to make the events work they have to have the classes "prev" and "next" (plus namespace)
        sync: "", //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
        asNavFor: "", //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider

        // Carousel Options
        itemWidth: 0, //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
        itemMargin: 0, //{NEW} Integer: Margin between carousel items.
        minItems: 1, //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
        maxItems: 0, //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
        move: 0, //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
        allowOneSlide: true, //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide

        // Callback API
        start: function () {}, //Callback: function(slider) - Fires when the slider loads the first slide
        before: function () {}, //Callback: function(slider) - Fires asynchronously with each slider animation
        after: function () {}, //Callback: function(slider) - Fires after each slider animation completes
        end: function () {}, //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
        added: function () {}, //{NEW} Callback: function(slider) - Fires after a slide is added
        removed: function () {}, //{NEW} Callback: function(slider) - Fires after a slide is removed
        init: function () {} //{NEW} Callback: function(slider) - Fires after the slider is initially setup
    };

    //FlexSlider: Plugin Function
    $.fn.flexslider = function (options) {
        if (options === undefined) {
            options = {};
        }

        if (typeof options === "object") {
            return this.each(function () {
                var $this = $(this),
                    selector = (options.selector) ? options.selector : ".slides > li",
                    $slides = $this.find(selector);

                if (($slides.length === 1 && options.allowOneSlide === true) || $slides.length === 0) {
                    $slides.fadeIn(400);
                    if (options.start) {
                        options.start($this);
                    }
                } else if ($this.data('flexslider') === undefined) {
                    new $.flexslider(this, options);
                }
            });
        } else {
            // Helper strings to quickly perform functions on the slider
            var $slider = $(this).data('flexslider');
            switch (options) {
                case "play":
                    $slider.play();
                    break;
                case "pause":
                    $slider.pause();
                    break;
                case "stop":
                    $slider.stop();
                    break;
                case "next":
                    $slider.flexAnimate($slider.getTarget("next"), true);
                    break;
                case "prev":
                case "previous":
                    $slider.flexAnimate($slider.getTarget("prev"), true);
                    break;
                default:
                    if (typeof options === "number") {
                        $slider.flexAnimate(options, true);
                    }
            }
        }
    };
})(jQuery);

/*!
 * Accordion Slider - v2.6
 * Homepage: http://bqworks.com/accordion-slider/
 * Author: bqworks
 * Author URL: http://bqworks.com/
 */
;
(function (window, $) {

    "use strict";

    /*
    	Static methods for Accordion Slider
    */
    $.AccordionSlider = {

        modules: {},

        addModule: function (name, module, target) {
            if (typeof this.modules[target] === 'undefined')
                this.modules[target] = [];

            this.modules[target].push(name);

            if (target === 'accordion')
                $.extend(AccordionSlider.prototype, module);
            else if (target === 'panel')
                $.extend(AccordionSliderPanel.prototype, module);
        }
    };

    // namespace
    var NS = $.AccordionSlider.namespace = 'AccordionSlider';

    var AccordionSlider = function (instance, options) {

        // reference to the accordion jQuery object
        this.$accordion = $(instance);

        // reference to the container of the panels
        this.$panelsContainer = null;

        // reference to the container that will mask the panels
        this.$maskContainer = null;

        // holds the options specified when the accordion was instantiated
        this.options = options;

        // holds the final settings of the accordion
        this.settings = {};

        // keep a separate reference of the settings which will not be altered by breakpoints or by other means
        this.originalSettings = {};

        // the index of the currently opened panel (starts with 0)
        this.currentIndex = -1;

        // the index of the current page
        this.currentPage = 0;

        // the size, in pixels, of the accordion
        this.totalSize = 0;

        // the size of the panels' container
        this.totalPanelsSize = 0;

        // the computed size, in pixels, of the opened panel
        this.computedOpenedPanelSize = 0;

        // the computed maximum allowed size, in pixels, of the opened panel
        this.maxComputedOpenedPanelSize = 0;

        // the size, in pixels, of the collapsed panels
        this.collapsedPanelSize = 0;

        // the size, in pixels, of the closed panels
        this.closedPanelSize = 0;

        // the distance, in pixels, between the accordion's panels
        this.computedPanelDistance = 0;

        // array that contains the AccordionSliderPanel objects
        this.panels = [];

        // timer used for delaying the opening of the panel on mouse hover
        this.mouseDelayTimer = 0;

        // simple objects to be used for animation
        this.openPanelAnimation = {};
        this.closePanelsAnimation = {};

        // generate a unique ID to be used for event listening
        this.uniqueId = new Date().valueOf();

        // stores size breakpoints in an array for sorting purposes
        this.breakpoints = [];

        // indicates the current size breakpoint
        this.currentBreakpoint = -1;

        // keeps a reference to the previous number of visible panels
        this.previousVisiblePanels = -1;

        // indicates whether the accordion is currently scrolling
        this.isPageScrolling = false;

        // indicates the left or top property based on the orientation of the accordion
        this.positionProperty = 'left';

        // indicates the width or height property based on the orientation of the accordion
        this.sizeProperty = 'width';

        // keeps a reference to the ratio between the size actual size of the accordion and the set size
        this.autoResponsiveRatio = 1;

        // indicates whether the panels will overlap, based on the set panelOverlap property
        // and also based on the computed distance between panels
        this.isOverlapping = false;

        // initialize the accordion
        this._init();
    };

    AccordionSlider.prototype = {

        /*
        	The starting place for the accordion
        */
        _init: function () {
            var that = this;

            this.$accordion.removeClass('as-no-js');

            // get reference to the panels' container and 
            // create additional mask container, which will mask the panels' container
            this.$maskContainer = $('<div class="as-mask"></div>').appendTo(this.$accordion);
            this.$panelsContainer = this.$accordion.find('.as-panels').appendTo(this.$maskContainer);

            // create the 'as-panels' element if it wasn't created manually
            if (this.$panelsContainer.length === 0)
                this.$panelsContainer = $('<div class="as-panels"></div>').appendTo(this.$maskContainer);

            // initialize accordion modules
            var modules = $.AccordionSlider.modules.accordion;

            // Merge the modules' default settings with the core's default settings
            if (typeof modules !== 'undefined') {
                for (var i = 0; i < modules.length; i++) {
                    var defaults = modules[i] + 'Defaults';

                    if (typeof this[defaults] !== 'undefined') {
                        $.extend(this.defaults, this[defaults]);
                    } else {
                        defaults = modules[i].substring(0, 1).toLowerCase() + modules[i].substring(1) + 'Defaults';

                        if (typeof this[defaults] !== 'undefined') {
                            $.extend(this.defaults, this[defaults]);
                        }
                    }
                }
            }

            // Merge the user defined settings with the default settings
            this.settings = $.extend({}, this.defaults, this.options);

            // Initialize the modules
            if (typeof modules !== 'undefined') {
                for (var j = 0; j < modules.length; j++) {
                    if (typeof this['init' + modules[j]] !== 'undefined') {
                        this['init' + modules[j]]();
                    }
                }
            }

            // keep a reference of the original settings and use it
            // to restore the settings when the breakpoints are used
            this.originalSettings = $.extend({}, this.settings);

            if (this.settings.shuffle === true) {
                var shuffledPanels = this.$panelsContainer.find('.as-panel').sort(function () {
                    return 0.5 - Math.random();
                });
                this.$panelsContainer.empty().append(shuffledPanels);
            }

            // set a panel to be opened from the start
            this.currentIndex = this.settings.startPanel;

            if (this.currentIndex === -1)
                this.$accordion.addClass('as-closed');
            else
                this.$accordion.addClass('as-opened');

            // if a panels was not set to be opened but a page was specified,
            // set that page index to be opened
            if (this.settings.startPage !== -1)
                this.currentPage = this.settings.startPage;

            // parse the breakpoints object and store the values into an array
            // sorting them in ascending order based on the specified size
            if (this.settings.breakpoints !== null) {
                for (var sizes in this.settings.breakpoints) {
                    this.breakpoints.push({
                        size: parseInt(sizes, 10),
                        properties: this.settings.breakpoints[sizes]
                    });
                }

                this.breakpoints = this.breakpoints.sort(function (a, b) {
                    return a.size >= b.size ? 1 : -1;
                });
            }

            // prepare request animation frame
            this._prepareRAF();

            // update the accordion
            this.update();

            // if there is a panel opened at start handle that panel as if it was manually opened
            if (this.currentIndex !== -1) {
                this.$accordion.find('.as-panel').eq(this.currentIndex).addClass('as-opened');

                // fire 'panelOpen' event
                var eventObject = {
                    type: 'panelOpen',
                    index: this.currentIndex,
                    previousIndex: -1
                };
                this.trigger(eventObject);
                if ($.isFunction(this.settings.panelOpen))
                    this.settings.panelOpen.call(this, eventObject);
            }

            // listen for 'mouseenter' events
            this.on('mouseenter.' + NS, function (event) {
                var eventObject = {
                    type: 'accordionMouseOver'
                };
                that.trigger(eventObject);
                if ($.isFunction(that.settings.accordionMouseOver))
                    that.settings.accordionMouseOver.call(that, eventObject);
            });

            // listen for 'mouseleave' events
            this.on('mouseleave.' + NS, function (event) {
                clearTimeout(that.mouseDelayTimer);

                // close the panels
                if (that.settings.closePanelsOnMouseOut === true)
                    that.closePanels();

                var eventObject = {
                    type: 'accordionMouseOut'
                };
                that.trigger(eventObject);
                if ($.isFunction(that.settings.accordionMouseOut))
                    that.settings.accordionMouseOut.call(that, eventObject);
            });

            // resize the accordion when the browser resizes
            $(window).on('resize.' + this.uniqueId + '.' + NS, function () {
                that.resize();
            });

            // fire the 'init' event
            this.trigger({
                type: 'init'
            });
            if ($.isFunction(this.settings.init))
                this.settings.init.call(this, {
                    type: 'init'
                });
        },

        /*
        	Update the accordion after a property was changed or panels were added/removed
        */
        update: function () {
            var that = this;

            // add a class to the accordion based on the orientation
            // to be used in CSS
            if (this.settings.orientation === 'horizontal') {
                this.$accordion.removeClass('as-vertical').addClass('as-horizontal');
                this.positionProperty = 'left';
                this.sizeProperty = 'width';
            } else if (this.settings.orientation === 'vertical') {
                this.$accordion.removeClass('as-horizontal').addClass('as-vertical');
                this.positionProperty = 'top';
                this.sizeProperty = 'height';
            }

            // if the number of visible panels has change, update the current page to reflect
            // the same relative position of the panels
            if (this.settings.visiblePanels === -1) {
                this.currentPage = 0;
            } else if (this.currentIndex !== -1) {
                this.currentPage = Math.floor(this.currentIndex / this.settings.visiblePanels);
            } else if (this.settings.visiblePanels !== this.previousVisiblePanels && this.previousVisiblePanels !== -1) {
                var correctPage = Math.round((this.currentPage * this.previousVisiblePanels) / this.settings.visiblePanels);

                if (this.currentPage !== correctPage)
                    this.currentPage = correctPage;
            }

            // if there is distance between the panels, the panels can't overlap
            if (this.settings.panelDistance > 0 || this.settings.panelOverlap === false) {
                this.isOverlapping = false;
                this.$accordion.removeClass('as-overlap');
            } else if (this.settings.panelOverlap === true) {
                this.isOverlapping = true;
                this.$accordion.addClass('as-overlap');
            }

            // clear inline size of the background images because the orientation might have changes
            this.$accordion.find('img.as-background, img.as-background-opened').css({
                'width': '',
                'height': ''
            });

            // update panels
            this._updatePanels();

            // create or update the pagination buttons
            this._updatePaginationButtons();

            // create or remove the shadow
            if (this.settings.shadow === true) {
                this.$accordion.find('.as-panel').addClass('as-shadow');
            } else if (this.settings.shadow === false) {
                this.$accordion.find('.as-shadow').removeClass('as-shadow');
            }

            // reset the panels' container position
            this.$panelsContainer.attr('style', '');

            // set the size of the accordion
            this.resize();

            // fire the update event
            var eventObject = {
                type: 'update'
            };
            that.trigger(eventObject);
            if ($.isFunction(that.settings.update))
                that.settings.update.call(that, eventObject);
        },

        /*
        	Create, remove or update panels based on the HTML specified in the accordion
        */
        _updatePanels: function () {
            var that = this;

            // check if there are removed items in the DOM and remove the from the array of panels
            for (var i = this.panels.length - 1; i >= 0; i--) {
                if (this.$accordion.find('.as-panel[data-index="' + i + '"]').length === 0) {
                    var panel = this.panels[i];

                    panel.off('panelMouseOver.' + NS);
                    panel.off('panelMouseOut.' + NS);
                    panel.off('panelClick.' + NS);
                    panel.off('imagesComplete.' + NS);
                    panel.destroy();
                    this.panels.splice(i, 1);
                }
            }

            // parse the DOM and create uninstantiated panels and reset the indexes
            this.$accordion.find('.as-panel').each(function (index, element) {
                var panel = $(element);

                if (typeof panel.attr('data-init') === 'undefined') {
                    that._createPanel(index, panel);
                } else {
                    that.panels[index].setIndex(index);
                    that.panels[index].update();
                }
            });
        },

        /*
        	Create an individual panel
        */
        _createPanel: function (index, element) {
            var that = this,
                $element = $(element);

            // create a panel instance and add it to the array of panels
            var panel = new AccordionSliderPanel($element, this, index);
            this.panels.splice(index, 0, panel);

            // listen for 'panelMouseOver' events
            panel.on('panelMouseOver.' + NS, function (event) {
                if (that.isPageScrolling === true)
                    return;

                if (that.settings.openPanelOn === 'hover') {
                    clearTimeout(that.mouseDelayTimer);

                    // open the panel, but only after a short delay in order to prevent
                    // opening panels that the user doesn't intend
                    that.mouseDelayTimer = setTimeout(function () {
                        that.openPanel(event.index);
                    }, that.settings.mouseDelay);
                }

                var eventObject = {
                    type: 'panelMouseOver',
                    index: index
                };
                that.trigger(eventObject);
                if ($.isFunction(that.settings.panelMouseOver))
                    that.settings.panelMouseOver.call(that, eventObject);
            });

            // listen for 'panelMouseOut' events
            panel.on('panelMouseOut.' + NS, function (event) {
                if (that.isPageScrolling === true)
                    return;

                var eventObject = {
                    type: 'panelMouseOut',
                    index: index
                };
                that.trigger(eventObject);
                if ($.isFunction(that.settings.panelMouseOut))
                    that.settings.panelMouseOut.call(that, eventObject);
            });

            // listen for 'panelClick' events
            panel.on('panelClick.' + NS, function (event) {
                if (that.$accordion.hasClass('as-swiping'))
                    return;

                if (that.settings.openPanelOn === 'click') {
                    // open the panel if it's not already opened
                    // and close the panels if the clicked panel is opened
                    if (index !== that.currentIndex) {
                        that.openPanel(event.index);
                    } else {
                        that.closePanels();
                    }
                }

                var eventObject = {
                    type: 'panelClick',
                    index: index
                };
                that.trigger(eventObject);
                if ($.isFunction(that.settings.panelClick))
                    that.settings.panelClick.call(that, eventObject);
            });

            // disable links if the panel should open on click and it wasn't opened yet
            panel.on('panelMouseDown.' + NS, function (event) {
                $(this).find('a').off('click.disablePanelLink');

                if (index !== that.currentIndex && that.settings.openPanelOn === 'click') {
                    $(this).find('a').one('click.disablePanelLink', function (event) {
                        event.preventDefault();
                    });
                }
            });

            // listen for 'imagesComplete' events and if the images were loaded in
            // the panel that is currently opened and the size of the panel is different
            // than the currently computed size of the panel, force the re-opening of the panel
            // to the correct size
            panel.on('imagesComplete.' + NS, function (event) {
                if (event.index === that.currentIndex && event.contentSize !== that.computedOpenedPanelSize) {
                    that.openPanel(event.index, true);
                }
            });
        },

        /*
        	Removes all panels
        */
        removePanels: function () {
            $.each(this.panels, function (index, element) {
                element.off('panelMouseOver.' + NS);
                element.off('panelMouseOut.' + NS);
                element.off('panelClick.' + NS);
                element.off('imagesComplete.' + NS);

                element.destroy();
            });

            this.panels.length = 0;
        },

        /*
        	Called when the accordion needs to resize 
        */
        resize: function () {
            var that = this;

            this.$maskContainer.attr('style', '');

            // prepare the accordion for responsiveness
            if (this.settings.responsive === true) {
                // if the accordion is responsive set the width to 100% and use
                // the specified width and height as a max-width and max-height
                this.$accordion.css({
                    width: '100%',
                    height: this.settings.height,
                    maxWidth: this.settings.width,
                    maxHeight: this.settings.height
                });

                // if an aspect ratio was not specified, set the aspect ratio
                // based on the specified width and height
                if (this.settings.aspectRatio === -1)
                    this.settings.aspectRatio = this.settings.width / this.settings.height;

                this.$accordion.css('height', this.$accordion.innerWidth() / this.settings.aspectRatio);

                if (this.settings.responsiveMode === 'auto') {
                    // get the accordion's size ratio based on the set size and the actual size
                    this.autoResponsiveRatio = this.$accordion.innerWidth() / this.settings.width;

                    this.$maskContainer.css({
                        width: this.settings.width,
                        height: this.settings.height
                    });

                    // scale the mask container based on the current ratio
                    if (this.autoResponsiveRatio < 1) {
                        this.$maskContainer.css({
                            '-webkit-transform': 'scaleX(' + this.autoResponsiveRatio + ') scaleY(' + this.autoResponsiveRatio + ')',
                            '-ms-transform': 'scaleX(' + this.autoResponsiveRatio + ') scaleY(' + this.autoResponsiveRatio + ')',
                            'transform': 'scaleX(' + this.autoResponsiveRatio + ') scaleY(' + this.autoResponsiveRatio + ')',
                            '-webkit-transform-origin': 'top left',
                            '-ms-transform-origin': 'top left',
                            'transform-origin': 'top left'
                        });
                    } else {
                        this.$maskContainer.css({
                            '-webkit-transform': '',
                            '-ms-transform': '',
                            'transform': '',
                            '-webkit-transform-origin': '',
                            '-ms-transform-origin': '',
                            'transform-origin': ''
                        });
                    }

                    this.totalSize = this.settings.orientation === "horizontal" ? this.$maskContainer.innerWidth() : this.$maskContainer.innerHeight();
                } else {
                    this.totalSize = this.settings.orientation === "horizontal" ? this.$accordion.innerWidth() : this.$accordion.innerHeight();
                }
            } else {
                this.$accordion.css({
                    width: this.settings.width,
                    height: this.settings.height,
                    maxWidth: '',
                    maxHeight: ''
                });
                this.totalSize = this.settings.orientation === "horizontal" ? this.$accordion.innerWidth() : this.$accordion.innerHeight();
            }

            // set the size of the background images explicitly because of a bug?
            // that causes anchors not to adapt their size to the size of the image,
            // when the image size is set in percentages, which causes the total size
            // of the panel to be bigger than it should
            if (this.settings.orientation === 'horizontal')
                this.$accordion.find('img.as-background, img.as-background-opened').css('height', this.$panelsContainer.innerHeight());
            else
                this.$accordion.find('img.as-background, img.as-background-opened').css('width', this.$panelsContainer.innerWidth());

            // set the initial computedPanelDistance to the value defined in the options
            this.computedPanelDistance = this.settings.panelDistance;

            // parse computedPanelDistance and set it to a pixel value
            if (typeof this.computedPanelDistance === 'string') {
                if (this.computedPanelDistance.indexOf('%') !== -1) {
                    this.computedPanelDistance = this.totalSize * (parseInt(this.computedPanelDistance, 10) / 100);
                } else if (this.computedPanelDistance.indexOf('px') !== -1) {
                    this.computedPanelDistance = parseInt(this.computedPanelDistance, 10);
                }
            }

            // set the size, in pixels, of the closed panels
            this.closedPanelSize = (this.totalSize - (this.getVisiblePanels() - 1) * this.computedPanelDistance) / this.getVisiblePanels();

            // round the value
            this.closedPanelSize = Math.floor(this.closedPanelSize);

            // set the initial computedOpenedPanelSize to the value defined in the options
            this.computedOpenedPanelSize = this.settings.openedPanelSize;

            // if the panels are set to open to their maximum size,
            // parse maxComputedOpenedPanelSize and set it to a pixel value
            if (this.settings.openedPanelSize === 'max') {
                // set the initial maxComputedOpenedPanelSize to the value defined in the options
                this.maxComputedOpenedPanelSize = this.settings.maxOpenedPanelSize;

                if (typeof this.maxComputedOpenedPanelSize === 'string') {
                    if (this.maxComputedOpenedPanelSize.indexOf('%') !== -1) {
                        this.maxComputedOpenedPanelSize = this.totalSize * (parseInt(this.maxComputedOpenedPanelSize, 10) / 100);
                    } else if (this.maxComputedOpenedPanelSize.indexOf('px') !== -1) {
                        this.maxComputedOpenedPanelSize = parseInt(this.maxComputedOpenedPanelSize, 10);
                    }
                }
            }

            // parse computedOpenedPanelSize and set it to a pixel value
            if (typeof this.computedOpenedPanelSize === 'string') {
                if (this.computedOpenedPanelSize.indexOf('%') !== -1) {
                    this.computedOpenedPanelSize = this.totalSize * (parseInt(this.computedOpenedPanelSize, 10) / 100);
                } else if (this.computedOpenedPanelSize.indexOf('px') !== -1) {
                    this.computedOpenedPanelSize = parseInt(this.computedOpenedPanelSize, 10);
                } else if (this.computedOpenedPanelSize === 'max' && this.currentIndex !== -1) {
                    var contentSize = this.getPanelAt(this.currentIndex).getContentSize();
                    this.computedOpenedPanelSize = contentSize === 'loading' ? this.closedPanelSize : Math.min(contentSize, this.maxComputedOpenedPanelSize);
                }
            }

            // set the size, in pixels, of the collapsed panels
            this.collapsedPanelSize = (this.totalSize - this.computedOpenedPanelSize - (this.getVisiblePanels() - 1) * this.computedPanelDistance) / (this.getVisiblePanels() - 1);

            // round the values
            this.computedOpenedPanelSize = Math.floor(this.computedOpenedPanelSize);
            this.collapsedPanelSize = Math.floor(this.collapsedPanelSize);

            // get the total size of the panels' container
            this.totalPanelsSize = this.closedPanelSize * this.getTotalPanels() + this.computedPanelDistance * (this.getTotalPanels() - 1);

            this.$panelsContainer.css(this.sizeProperty, this.totalPanelsSize);

            // recalculate the totalSize due to the fact that rounded sizes can cause incorrect positioning
            // since the actual size of all panels from a page might be smaller than the whole width of the accordion
            this.totalSize = this.closedPanelSize * this.getVisiblePanels() + this.computedPanelDistance * (this.getVisiblePanels() - 1);

            if (this.settings.responsiveMode === 'custom' || this.settings.responsive === false) {
                this.$accordion.css(this.sizeProperty, this.totalSize);
            } else {
                this.$accordion.css(this.sizeProperty, this.totalSize * this.autoResponsiveRatio);
                this.$maskContainer.css(this.sizeProperty, this.totalSize);
            }

            // if there are multiple pages, set the correct position of the panels' container
            if (this.settings.visiblePanels !== -1) {
                var cssObj = {},
                    targetPosition = -(this.totalSize + this.computedPanelDistance) * this.currentPage;

                if (this.currentPage === this.getTotalPages() - 1)
                    targetPosition = -(this.closedPanelSize * this.getTotalPanels() + this.computedPanelDistance * (this.getTotalPanels() - 1) - this.totalSize);

                cssObj[this.positionProperty] = targetPosition;
                this.$panelsContainer.css(cssObj);
            }

            // calculate missing panels for the last page of panels
            var missingPanels = (this.currentPage === this.getTotalPages() - 1) && (this.getTotalPanels() % this.settings.visiblePanels) !== 0 ?
                this.settings.visiblePanels - this.getTotalPanels() % this.settings.visiblePanels :
                0;

            // set the position and size of each panel
            $.each(this.panels, function (index, element) {
                // get the position of the panel based on the currently selected index and the panel's index
                var position;

                if (that.currentIndex === -1) {
                    position = index * (that.closedPanelSize + that.computedPanelDistance);
                } else if (that.settings.visiblePanels === -1) {
                    position = index * (that.collapsedPanelSize + that.computedPanelDistance) + (index > that.currentIndex ? that.computedOpenedPanelSize - that.collapsedPanelSize : 0);
                } else {
                    if (that._getPageOfPanel(index) === that.currentPage) {
                        position = that.currentPage * (that.totalSize + that.computedPanelDistance) +
                            (index + missingPanels - that.currentPage * that.settings.visiblePanels) * (that.collapsedPanelSize + that.computedPanelDistance) +
                            (index > that.currentIndex ? that.computedOpenedPanelSize - that.collapsedPanelSize : 0);

                        if (that.currentPage === that.getTotalPages() - 1 && missingPanels !== 0)
                            position -= (that.getTotalPages() - that.getTotalPanels() / that.settings.visiblePanels) * (that.totalSize + that.computedPanelDistance);
                    } else {
                        position = index * (that.closedPanelSize + that.computedPanelDistance);
                    }
                }

                element.setPosition(position);

                // get the size of the panel based on the state of the panel (opened, closed or collapsed)
                if (that.isOverlapping === false) {
                    var size = (that.currentIndex === -1 || (that.settings.visiblePanels !== -1 && that._getPageOfPanel(index) !== that.currentPage)) ?
                        (that.closedPanelSize) :
                        (index === that.currentIndex ? that.computedOpenedPanelSize : that.collapsedPanelSize);
                    element.setSize(size);
                }
            });

            // check if the current window width is bigger than the biggest breakpoint
            // and if necessary reset the properties to the original settings
            // if the window width is smaller than a certain breakpoint, apply the settings specified
            // for that breakpoint but only after merging them with the original settings
            // in order to make sure that only the specified settings for the breakpoint are applied
            if (this.settings.breakpoints !== null && this.breakpoints.length > 0) {
                if ($(window).width() > this.breakpoints[this.breakpoints.length - 1].size && this.currentBreakpoint !== -1) {
                    this.currentBreakpoint = -1;
                    this._setProperties(this.originalSettings, false);
                } else {
                    for (var i = 0, n = this.breakpoints.length; i < n; i++) {
                        if ($(window).width() <= this.breakpoints[i].size) {
                            if (this.currentBreakpoint !== this.breakpoints[i].size) {

                                var eventObject = {
                                    type: 'breakpointReach',
                                    size: this.breakpoints[i].size,
                                    settings: this.breakpoints[i].properties
                                };
                                that.trigger(eventObject);
                                if ($.isFunction(that.settings.breakpointReach))
                                    that.settings.breakpointReach.call(that, eventObject);

                                this.currentBreakpoint = this.breakpoints[i].size;
                                var settings = $.extend({}, this.originalSettings, this.breakpoints[i].properties);
                                this._setProperties(settings, false);
                            }
                            break;
                        }
                    }
                }
            }
        },

        /*
        	Set properties on runtime
        */
        _setProperties: function (properties, store) {
            // parse the properties passed as an object
            for (var prop in properties) {
                // if the number of visible panels is changed, store a reference of the previous value
                // which will be used to move the panels to the corresponding page
                if (prop === 'visiblePanels' && this.settings.visiblePanels !== -1)
                    this.previousVisiblePanels = this.settings.visiblePanels;

                this.settings[prop] = properties[prop];

                // alter the original settings as well unless 'false' is passed to the 'store' parameter
                if (store !== false)
                    this.originalSettings[prop] = properties[prop];
            }

            this.update();
        },

        /*
        	Destroy the Accordion Slider instance
        */
        destroy: function () {
            // remove the stored reference to this instance
            this.$accordion.removeData('accordionSlider');

            // remove inline style
            this.$accordion.attr('style', '');
            this.$panelsContainer.attr('style', '');

            // detach event handlers
            this.off('mouseenter.' + NS);
            this.off('mouseleave.' + NS);

            $(window).off('resize.' + this.uniqueId + '.' + NS);

            // stop animations
            this._stopPanelsAnimation(this.openPanelAnimation);
            this._stopPanelsAnimation(this.closePanelsAnimation);

            // destroy modules
            var modules = $.AccordionSlider.modules.accordion;

            if (typeof modules !== 'undefined')
                for (var i = 0; i < modules.length; i++) {
                    if (typeof this['destroy' + modules[i]] !== 'undefined')
                        this['destroy' + modules[i]]();
                }

            // destroy all panels
            this.removePanels();

            // move the panels from the mask container back in the main accordion container
            this.$panelsContainer.appendTo(this.$accordion);

            // remove elements that were created by the script
            this.$maskContainer.remove();
            this.$accordion.find('.as-pagination-buttons').remove();
        },

        /*
        	Attach an event handler to the accordion
        */
        on: function (type, callback) {
            return this.$accordion.on(type, callback);
        },

        /*
        	Detach an event handler
        */
        off: function (type) {
            return this.$accordion.off(type);
        },

        /*
        	Trigger an event on the accordion
        */
        trigger: function (data) {
            return this.$accordion.triggerHandler(data);
        },

        /*
        	Return the panel at the specified index
        */
        getPanelAt: function (index) {
            return this.panels[index];
        },

        /*
        	Return the index of the currently opened panel
        */
        getCurrentIndex: function () {
            return this.currentIndex;
        },

        /*
        	Return the total amount of panels
        */
        getTotalPanels: function () {
            return this.panels.length;
        },

        /*
        	Open the next panel
        */
        nextPanel: function () {
            var index = (this.currentIndex >= this.getTotalPanels() - 1) ? 0 : (this.currentIndex + 1);
            this.openPanel(index);
        },

        /*
        	Open the previous panel
        */
        previousPanel: function () {
            var index = this.currentIndex <= 0 ? (this.getTotalPanels() - 1) : (this.currentIndex - 1);
            this.openPanel(index);
        },

        /*
        	Animate the panels using request animation frame
        */
        _animatePanels: function (target, args) {
            var startTime = new Date().valueOf(),
                progress = 0;

            target.isRunning = true;
            target.timer = window.requestAnimationFrame(_animate);

            function _animate() {
                if (progress < 1) {
                    // get the progress by calculating the elapsed time
                    progress = (new Date().valueOf() - startTime) / args.duration;

                    if (progress > 1)
                        progress = 1;

                    // apply swing easing
                    progress = 0.5 - Math.cos(progress * Math.PI) / 2;

                    args.step(progress);

                    target.timer = window.requestAnimationFrame(_animate);
                } else {
                    args.complete();

                    target.isRunning = false;
                    window.cancelAnimationFrame(target.timer);
                }
            }
        },

        /*
        	Stop running panel animations
        */
        _stopPanelsAnimation: function (target) {
            if (typeof target.isRunning !== 'undefined' && target.isRunning === true) {
                target.isRunning = false;
                window.cancelAnimationFrame(target.timer);
            }
        },

        /*
        	Check if window.requestAnimationFrame exists in the browser and if it doesn't, 
        	try alternative function names or implement window.requestAnimationFrame using window.setTimeout
        */
        _prepareRAF: function () {
            if (typeof window.requestAnimationFrame === 'undefined') {
                var vendorPrefixes = ['webkit', 'moz'];

                for (var i = 0; i < vendorPrefixes.length; i++) {
                    window.requestAnimationFrame = window[vendorPrefixes[i] + 'RequestAnimationFrame'];
                    window.cancelAnimationFrame = window.cancelAnimationFrame || window[vendorPrefixes[i] + 'CancelAnimationFrame'] || window[vendorPrefixes[i] + 'CancelRequestAnimationFrame'];
                }
            }

            // polyfill inspired from Erik Moller
            if (typeof window.requestAnimationFrame === 'undefined') {
                var lastTime = 0;

                window.requestAnimationFrame = function (callback, element) {
                    var currentTime = new Date().valueOf(),
                        timeToCall = Math.max(0, 16 - (currentTime - lastTime));

                    var id = window.setTimeout(function () {
                        callback(currentTime + timeToCall);
                    }, timeToCall);

                    lastTime = currentTime + timeToCall;

                    return id;
                };

                window.cancelAnimationFrame = function (id) {
                    clearTimeout(id);
                };
            }
        },

        /*
        	Open the panel at the specified index
        */
        openPanel: function (index, force) {
            if (index === this.currentIndex && force !== true)
                return;

            // remove the "closed" class and add the "opened" class, which indicates
            // that the accordion has an opened panel
            if (this.$accordion.hasClass('as-opened') === false) {
                this.$accordion.removeClass('as-closed');
                this.$accordion.addClass('as-opened');
            }

            var previousIndex = this.currentIndex;

            this.currentIndex = index;

            // synchronize the page with the selected panel by navigating to the page that
            // contains the panel if necessary.
            // if the last page is already selected and the selected panel is on this last page 
            // don't navigate to a different page no matter what panel is selected and whether
            // the panel actually belongs to the previous page
            if (this.settings.visiblePanels !== -1 && !(this.currentPage === this.getTotalPages() - 1 && index >= this.getTotalPanels() - this.settings.visiblePanels)) {
                var page = Math.floor(this.currentIndex / this.settings.visiblePanels);

                if (page !== this.currentPage)
                    this.gotoPage(page);

                // reset the current index because when the closePanels was called inside gotoPage the current index became -1
                this.currentIndex = index;
            }

            var that = this,
                targetSize = [],
                targetPosition = [],
                startSize = [],
                startPosition = [],
                animatedPanels = [],
                firstPanel = this._getFirstPanelFromPage(),
                lastPanel = this._getLastPanelFromPage(),
                counter = 0;

            this.$accordion.find('.as-panel.as-opened').removeClass('as-opened');
            this.$accordion.find('.as-panel').eq(this.currentIndex).addClass('as-opened');

            // check if the panel needs to open to its maximum size and recalculate
            // the size of the opened panel and the size of the collapsed panel
            if (this.settings.openedPanelSize === 'max') {
                var contentSize = this.getPanelAt(this.currentIndex).getContentSize();
                this.computedOpenedPanelSize = contentSize === 'loading' ? this.closedPanelSize : Math.min(contentSize, this.maxComputedOpenedPanelSize);

                this.collapsedPanelSize = (this.totalSize - this.computedOpenedPanelSize - (this.getVisiblePanels() - 1) * this.computedPanelDistance) / (this.getVisiblePanels() - 1);
            }

            // get the starting and target position and size of each panel
            for (var i = firstPanel; i <= lastPanel; i++) {
                var panel = this.getPanelAt(i);

                startPosition[i] = panel.getPosition();
                targetPosition[i] = this.currentPage * (this.totalSize + this.computedPanelDistance) +
                    counter * (this.collapsedPanelSize + this.computedPanelDistance) +
                    (i > this.currentIndex ? this.computedOpenedPanelSize - this.collapsedPanelSize : 0);

                // the last page might contain less panels than the set number of visible panels.
                // in this situation, the last page will contain some panels from the previous page
                // and this requires the panels from the last page to be positioned differently than
                // the rest of the panels. this requires some amendments to the position of the last panels
                // by replacing the current page index with a float number: this.getTotalPanels() / this.settings.visiblePanels, 
                // which would represent the actual number of existing pages.
                // here we subtract the float number from the formal number of pages in order to calculate
                // how much length it's necessary to subtract from the initially calculated value
                if (this.settings.visiblePanels !== -1 && this.currentPage === this.getTotalPages() - 1)
                    targetPosition[i] -= (this.getTotalPages() - this.getTotalPanels() / this.settings.visiblePanels) * (this.totalSize + this.computedPanelDistance);

                // check if the panel's position needs to change
                if (targetPosition[i] !== startPosition[i])
                    animatedPanels.push(i);

                if (this.isOverlapping === false) {
                    startSize[i] = panel.getSize();
                    targetSize[i] = i === this.currentIndex ? this.computedOpenedPanelSize : this.collapsedPanelSize;

                    // check if the panel's size needs to change
                    if (targetSize[i] !== startSize[i] && $.inArray(i, animatedPanels) === -1)
                        animatedPanels.push(i);
                }

                counter++;
            }

            var totalPanels = animatedPanels.length;

            // stop the close panels animation if it's on the same page
            if (this.closePanelsAnimation.page === this.currentPage)
                this._stopPanelsAnimation(this.closePanelsAnimation);

            // stop any running animations
            this._stopPanelsAnimation(this.openPanelAnimation);

            // assign the current page
            this.openPanelAnimation.page = this.currentPage;

            // animate the panels
            this._animatePanels(this.openPanelAnimation, {
                duration: this.settings.openPanelDuration,
                step: function (progress) {
                    for (var i = 0; i < totalPanels; i++) {
                        var value = animatedPanels[i],
                            panel = that.getPanelAt(value);

                        panel.setPosition(progress * (targetPosition[value] - startPosition[value]) + startPosition[value]);

                        if (that.isOverlapping === false)
                            panel.setSize(progress * (targetSize[value] - startSize[value]) + startSize[value]);
                    }
                },
                complete: function () {
                    // fire 'panelOpenComplete' event
                    var eventObject = {
                        type: 'panelOpenComplete',
                        index: that.currentIndex
                    };
                    that.trigger(eventObject);
                    if ($.isFunction(that.settings.panelOpenComplete))
                        that.settings.panelOpenComplete.call(that, eventObject);
                }
            });

            // fire 'panelOpen' event
            var eventObject = {
                type: 'panelOpen',
                index: index,
                previousIndex: previousIndex
            };
            this.trigger(eventObject);
            if ($.isFunction(this.settings.panelOpen))
                this.settings.panelOpen.call(this, eventObject);
        },

        /*
        	Close the panels
        */
        closePanels: function () {
            var previousIndex = this.currentIndex;

            this.currentIndex = -1;

            // remove the "opened" class and add the "closed" class, which indicates
            // that the accordion is closed
            if (this.$accordion.hasClass('as-closed') === false) {
                this.$accordion.removeClass('as-opened');
                this.$accordion.addClass('as-closed');
            }

            // remove the "opened" class from the previously opened panel
            this.$accordion.find('.as-panel.as-opened').removeClass('as-opened');

            clearTimeout(this.mouseDelayTimer);

            var that = this,
                targetSize = [],
                targetPosition = [],
                startSize = [],
                startPosition = [],
                firstPanel = this._getFirstPanelFromPage(),
                lastPanel = this._getLastPanelFromPage(),
                counter = 0;

            // get the starting and target size and position of each panel
            for (var i = firstPanel; i <= lastPanel; i++) {
                var panel = this.getPanelAt(i);

                startPosition[i] = panel.getPosition();
                targetPosition[i] = this.currentPage * (this.totalSize + this.computedPanelDistance) + counter * (this.closedPanelSize + this.computedPanelDistance);

                // same calculations as in openPanel
                if (this.settings.visiblePanels !== -1 && this.currentPage === this.getTotalPages() - 1)
                    targetPosition[i] -= (this.getTotalPages() - this.getTotalPanels() / this.settings.visiblePanels) * (this.totalSize + this.computedPanelDistance);

                if (this.isOverlapping === false) {
                    startSize[i] = panel.getSize();
                    targetSize[i] = this.closedPanelSize;
                }

                counter++;
            }

            // stop the open panel animation if it's on the same page
            if (this.openPanelAnimation.page === this.currentPage)
                this._stopPanelsAnimation(this.openPanelAnimation);

            // stop any running animations
            this._stopPanelsAnimation(this.closePanelsAnimation);

            // assign the current page
            this.closePanelsAnimation.page = this.currentPage;

            // animate the panels
            this._animatePanels(this.closePanelsAnimation, {
                duration: this.settings.closePanelDuration,
                step: function (progress) {
                    for (var i = firstPanel; i <= lastPanel; i++) {
                        var panel = that.getPanelAt(i);

                        panel.setPosition(progress * (targetPosition[i] - startPosition[i]) + startPosition[i]);

                        if (that.isOverlapping === false)
                            panel.setSize(progress * (targetSize[i] - startSize[i]) + startSize[i]);
                    }
                },
                complete: function () {
                    // fire 'panelsCloseComplete' event
                    var eventObject = {
                        type: 'panelsCloseComplete',
                        previousIndex: previousIndex
                    };
                    that.trigger(eventObject);
                    if ($.isFunction(that.settings.panelsCloseComplete))
                        that.settings.panelsCloseComplete.call(that, eventObject);
                }
            });

            // fire 'panelsClose' event
            var eventObject = {
                type: 'panelsClose',
                previousIndex: previousIndex
            };
            this.trigger(eventObject);
            if ($.isFunction(this.settings.panelsClose))
                this.settings.panelsClose.call(this, eventObject);
        },

        /*
        	Return the number of visible panels
        */
        getVisiblePanels: function () {
            return this.settings.visiblePanels === -1 ? this.getTotalPanels() : this.settings.visiblePanels;
        },

        /*
        	Return the total number of pages
        */
        getTotalPages: function () {
            if (this.settings.visiblePanels === -1)
                return 1;

            return Math.ceil(this.getTotalPanels() / this.settings.visiblePanels);
        },

        /*
        	Return the current page
        */
        getCurrentPage: function () {
            return this.settings.visiblePanels === -1 ? 0 : this.currentPage;
        },

        /*
        	Navigate to the indicated page
        */
        gotoPage: function (index) {
            // close any opened panels before scrolling to a different page
            if (this.currentIndex !== -1)
                this.closePanels();

            this.currentPage = index;

            this.isPageScrolling = true;

            var that = this,
                animObj = {},
                targetPosition = -(index * this.totalSize + this.currentPage * this.computedPanelDistance);

            if (this.currentPage === this.getTotalPages() - 1)
                targetPosition = -(this.totalPanelsSize - this.totalSize);

            animObj[this.positionProperty] = targetPosition;

            // fire 'pageScroll' event
            var eventObject = {
                type: 'pageScroll',
                index: this.currentPage
            };
            this.trigger(eventObject);
            if ($.isFunction(this.settings.pageScroll))
                this.settings.pageScroll.call(this, eventObject);

            this.$panelsContainer.stop().animate(animObj, this.settings.pageScrollDuration, this.settings.pageScrollEasing, function () {
                that.isPageScrolling = false;

                // fire 'pageScrollComplete' event
                var eventObject = {
                    type: 'pageScrollComplete',
                    index: that.currentPage
                };
                that.trigger(eventObject);
                if ($.isFunction(that.settings.pageScrollComplete))
                    that.settings.pageScrollComplete.call(that, eventObject);
            });
        },

        /*
        	Navigate to the next page
        */
        nextPage: function () {
            var index = (this.currentPage >= this.getTotalPages() - 1) ? 0 : (this.currentPage + 1);
            this.gotoPage(index);
        },

        /*
        	Navigate to the previous page
        */
        previousPage: function () {
            var index = this.currentPage <= 0 ? (this.getTotalPages() - 1) : (this.currentPage - 1);
            this.gotoPage(index);
        },

        /*
        	Calculate and return the first panel from the current page
        */
        _getFirstPanelFromPage: function () {
            if (this.settings.visiblePanels === -1) {
                return 0;
            } else if (this.currentPage === this.getTotalPages() - 1 && this.currentPage !== 0) {
                return this.getTotalPanels() - this.settings.visiblePanels;
            } else {
                return this.currentPage * this.settings.visiblePanels;
            }
        },

        /*
        	Calculate and return the last panel from the current page
        */
        _getLastPanelFromPage: function () {
            if (this.settings.visiblePanels === -1) {
                return this.getTotalPanels() - 1;
            } else if (this.currentPage === this.getTotalPages() - 1) {
                return this.getTotalPanels() - 1;
            } else {
                return (this.currentPage + 1) * this.settings.visiblePanels - 1;
            }
        },

        /*
        	Return the page that the specified panel belongs to
        */
        _getPageOfPanel: function (index) {
            if (this.currentPage === this.getTotalPages() - 1 && index >= this.getTotalPanels() - this.settings.visiblePanels)
                return this.getTotalPages() - 1;

            return Math.floor(index / this.settings.visiblePanels);
        },

        /*
        	Create or update the pagination buttons
        */
        _updatePaginationButtons: function () {
            var paginationButtons = this.$accordion.find('.as-pagination-buttons'),
                that = this,
                totalPages = this.getTotalPages();

            // remove the buttons if there are no more pages
            if (totalPages <= 1 && paginationButtons.length !== 0) {
                paginationButtons.remove();
                paginationButtons.off('click.' + NS, '.as-pagination-button');
                this.off('pageScroll.' + NS);

                this.$accordion.removeClass('as-has-buttons');
                // if there are pages and the buttons were not created yet, create them now
            } else if (totalPages > 1 && paginationButtons.length === 0) {
                // create the buttons' container
                paginationButtons = $('<div class="as-pagination-buttons"></div>').appendTo(this.$accordion);

                // create the buttons
                for (var i = 0; i < this.getTotalPages(); i++) {
                    $('<div class="as-pagination-button"></div>').appendTo(paginationButtons);
                }

                // listen for button clicks 
                paginationButtons.on('click.' + NS, '.as-pagination-button', function () {
                    that.gotoPage($(this).index());
                });

                // set the initially selected button
                paginationButtons.find('.as-pagination-button').eq(this.currentPage).addClass('as-selected');

                // select the corresponding panel when the page changes and change the selected button
                this.on('pageScroll.' + NS, function (event) {
                    paginationButtons.find('.as-selected').removeClass('as-selected');
                    paginationButtons.find('.as-pagination-button').eq(event.index).addClass('as-selected');
                });

                this.$accordion.addClass('as-has-buttons');

                // update the buttons if they already exist but their number differs from
                // the number of existing pages
            } else if (totalPages > 1 && paginationButtons.length !== 0) {
                paginationButtons.empty();

                // create the buttons
                for (var j = 0; j < this.getTotalPages(); j++) {
                    $('<div class="as-pagination-button"></div>').appendTo(paginationButtons);
                }

                // change the selected the buttons
                paginationButtons.find('.as-selected').removeClass('as-selected');
                paginationButtons.find('.as-pagination-button').eq(this.currentPage).addClass('as-selected');
            }
        },

        /*
        	The default options of the accordion
        */
        defaults: {
            width: 800,
            height: 400,
            responsive: true,
            responsiveMode: 'auto',
            aspectRatio: -1,
            orientation: 'horizontal',
            startPanel: -1,
            openedPanelSize: 'max',
            maxOpenedPanelSize: '80%',
            openPanelOn: 'hover',
            closePanelsOnMouseOut: true,
            mouseDelay: 200,
            panelDistance: 0,
            openPanelDuration: 700,
            closePanelDuration: 700,
            pageScrollDuration: 500,
            pageScrollEasing: 'swing',
            breakpoints: null,
            visiblePanels: -1,
            startPage: 0,
            shadow: true,
            shuffle: false,
            panelOverlap: true,
            init: function () {},
            update: function () {},
            accordionMouseOver: function () {},
            accordionMouseOut: function () {},
            panelClick: function () {},
            panelMouseOver: function () {},
            panelMouseOut: function () {},
            panelOpen: function () {},
            panelsClose: function () {},
            pageScroll: function () {},
            panelOpenComplete: function () {},
            panelsCloseComplete: function () {},
            pageScrollComplete: function () {},
            breakpointReach: function () {}
        }
    };

    var AccordionSliderPanel = function (panel, accordion, index) {

        // reference to the panel jQuery object
        this.$panel = panel;

        // reference to the accordion object
        this.accordion = accordion;

        // reference to the global settings of the accordion
        this.settings = this.accordion.settings;

        // set a namespace for the panel
        this.panelNS = 'AccordionSliderPanel' + index + '.' + NS;

        this.isLoading = false;
        this.isLoaded = false;

        // set the index of the panel
        this.setIndex(index);

        // initialize the panel
        this._init();
    };

    AccordionSliderPanel.prototype = {

        /*
        	The starting point for the panel
        */
        _init: function () {
            var that = this;

            this.$panel.attr('data-init', true);

            // listen for 'mouseenter' events
            this.on('mouseenter.' + this.panelNS, function () {
                that.trigger({
                    type: 'panelMouseOver.' + NS,
                    index: that.index
                });
            });

            // listen for 'mouseleave' events
            this.on('mouseleave.' + this.panelNS, function () {
                that.trigger({
                    type: 'panelMouseOut.' + NS,
                    index: that.index
                });
            });

            // listen for 'click' events
            this.on('click.' + this.panelNS, function () {
                that.trigger({
                    type: 'panelClick.' + NS,
                    index: that.index
                });
            });

            // listen for 'mousedown' events
            this.on('mousedown.' + this.panelNS, function () {
                that.trigger({
                    type: 'panelMouseDown.' + NS,
                    index: that.index
                });
            });

            // set position and size properties
            this.update();

            // initialize panel modules
            var modules = $.AccordionSlider.modules.panel;

            if (typeof modules !== 'undefined')
                for (var i = 0; i < modules.length; i++) {
                    if (typeof this['init' + modules[i]] !== 'undefined')
                        this['init' + modules[i]]();
                }
        },

        /*
        	Update the panel
        */
        update: function () {
            // get the new position and size properties
            this.positionProperty = this.settings.orientation === 'horizontal' ? 'left' : 'top';
            this.sizeProperty = this.settings.orientation === 'horizontal' ? 'width' : 'height';

            // reset the current size and position
            this.$panel.css({
                top: '',
                left: '',
                width: '',
                height: ''
            });
        },

        /*
        	Destroy the panel
        */
        destroy: function () {
            // detach all event listeners
            this.off('mouseenter.' + this.panelNS);
            this.off('mouseleave.' + this.panelNS);
            this.off('click.' + this.panelNS);
            this.off('mousedown.' + this.panelNS);

            // clean the element from attached styles and data
            this.$panel.attr('style', '');
            this.$panel.removeAttr('data-init');
            this.$panel.removeAttr('data-index');

            // destroy panel modules
            var modules = $.AccordionSlider.modules.panel;

            if (typeof modules !== 'undefined')
                for (var i = 0; i < modules.length; i++) {
                    if (typeof this['destroy' + modules[i]] !== 'undefined')
                        this['destroy' + modules[i]]();
                }
        },

        /*
        	Return the index of the panel
        */
        getIndex: function () {
            return this.index;
        },

        /*
        	Set the index of the panel
        */
        setIndex: function (index) {
            this.index = index;
            this.$panel.attr('data-index', this.index);
        },

        /*
        	Return the position of the panel
        */
        getPosition: function () {
            return parseInt(this.$panel.css(this.positionProperty), 10);
        },

        /*
        	Set the position of the panel
        */
        setPosition: function (value) {
            this.$panel.css(this.positionProperty, value);
        },

        /*
        	Return the size of the panel
        */
        getSize: function () {
            return parseInt(this.$panel.css(this.sizeProperty), 10);
        },

        /*
        	Set the size of the panel
        */
        setSize: function (value) {
            this.$panel.css(this.sizeProperty, value);
        },

        /*
        	Get the real size of the panel's content
        */
        getContentSize: function () {
            // check if there are loading images
            if (this.isLoaded === false)
                if (this.checkImagesComplete() === 'loading')
                    return 'loading';

            this.$panel.find('.as-opened').css('display', 'none');

            var size = this.sizeProperty === 'width' ? this.$panel[0].scrollWidth : this.$panel[0].scrollHeight;

            this.$panel.find('.as-opened').css('display', '');

            return size;
        },

        /*
        	Check the status of all images from the panel
        */
        checkImagesComplete: function () {
            if (this.isLoading === true)
                return 'loading';

            var that = this,
                status = 'complete';

            // check if there is any unloaded image inside the panel
            this.$panel.find('img').each(function (index) {
                var image = $(this)[0];

                if (image.complete === false || typeof $(this).attr('data-src') !== 'undefined')
                    status = 'loading';
            });

            // continue checking until all images have loaded
            if (status === 'loading') {
                this.isLoading = true;

                var checkImage = setInterval(function () {
                    var loaded = true;

                    that.$panel.find('img').each(function (index) {
                        var image = $(this)[0];

                        if (image.complete === false || typeof $(this).attr('data-src') !== 'undefined')
                            loaded = false;
                    });

                    if (loaded === true) {
                        that.isLoading = false;
                        that.isLoaded = true;
                        clearInterval(checkImage);
                        that.trigger({
                            type: 'imagesComplete.' + NS,
                            index: that.index,
                            contentSize: that.getContentSize()
                        });
                    }
                }, 100);
            } else {
                this.isLoaded = true;
            }

            return status;
        },

        /*
        	Attach an event handler to the panel
        */
        on: function (type, callback) {
            return this.$panel.on(type, callback);
        },

        /*
        	Detach an event handler to the panel
        */
        off: function (type) {
            return this.$panel.off(type);
        },

        /*
        	Trigger an event on the panel
        */
        trigger: function (data) {
            return this.$panel.triggerHandler(data);
        }
    };

    window.AccordionSlider = AccordionSlider;
    window.AccordionSliderPanel = AccordionSliderPanel;

    $.fn.accordionSlider = function (options) {
        var args = Array.prototype.slice.call(arguments, 1);

        return this.each(function () {
            // instantiate the accordion or alter it
            if (typeof $(this).data('accordionSlider') === 'undefined') {
                var newInstance = new AccordionSlider(this, options);

                // store a reference to the instance created
                $(this).data('accordionSlider', newInstance);
            } else if (typeof options !== 'undefined') {
                var currentInstance = $(this).data('accordionSlider');

                // check the type of argument passed
                if (typeof currentInstance[options] === 'function') {
                    currentInstance[options].apply(currentInstance, args);
                } else if (typeof currentInstance.settings[options] !== 'undefined') {
                    var obj = {};
                    obj[options] = args[0];
                    currentInstance._setProperties(obj);
                } else if (typeof options === 'object') {
                    currentInstance._setProperties(options);
                } else {
                    $.error(options + ' does not exist in accordionSlider.');
                }
            }
        });
    };

})(window, jQuery);

/*
	Autoplay module for Accordion Slider

	Adds autoplay functionality to the accordion
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var Autoplay = {

        autoplayIndex: -1,

        autoplayTimer: null,

        isTimerRunning: false,

        isTimerPaused: false,

        initAutoplay: function () {
            var that = this;

            if (this.settings.autoplay === true)
                this.startAutoplay();

            // start the autoplay timer each time the panel opens
            this.on('panelOpen.Autoplay.' + NS, function (event) {
                that.autoplayIndex = event.index;

                if (that.settings.autoplay === true) {
                    // stop previous timers before starting a new one
                    if (that.isTimerRunning === true)
                        that.stopAutoplay();

                    if (that.isTimerPaused === false)
                        that.startAutoplay();
                }
            });

            // store the index of the previously opened panel
            this.on('panelsClose.Autoplay.' + NS, function (event) {
                if (event.previousIndex !== -1)
                    that.autoplayIndex = event.previousIndex;
            });

            // store the index of the first panel from the new page
            this.on('pageScroll.Autoplay.' + NS, function (event) {
                that.autoplayIndex = that._getFirstPanelFromPage() - 1;
            });

            // on accordion hover stop the autoplay if autoplayOnHover is set to pause or stop
            this.on('mouseenter.Autoplay.' + NS, function (event) {
                if (that.settings.autoplay === true && that.isTimerRunning && (that.settings.autoplayOnHover === 'pause' || that.settings.autoplayOnHover === 'stop')) {
                    that.stopAutoplay();
                    that.isTimerPaused = true;
                }
            });

            // on accordion hover out restart the autoplay
            this.on('mouseleave.Autoplay.' + NS, function (event) {
                if (that.settings.autoplay === true && that.isTimerRunning === false && that.settings.autoplayOnHover !== 'stop') {
                    that.startAutoplay();
                    that.isTimerPaused = false;
                }
            });
        },

        startAutoplay: function () {
            var that = this;
            this.isTimerRunning = true;

            this.autoplayTimer = setTimeout(function () {
                // check if there is a stored index from which the autoplay needs to continue
                if (that.autoplayIndex !== -1) {
                    that.currentIndex = that.autoplayIndex;
                    that.autoplayIndex = -1;
                }

                if (that.settings.autoplayDirection === 'normal') {
                    that.nextPanel();
                } else if (that.settings.autoplayDirection === 'backwards') {
                    that.previousPanel();
                }
            }, this.settings.autoplayDelay);
        },

        stopAutoplay: function () {
            this.isTimerRunning = false;

            clearTimeout(this.autoplayTimer);
        },

        destroyAutoplay: function () {
            clearTimeout(this.autoplayTimer);

            this.off('panelOpen.Autoplay.' + NS);
            this.off('pageScroll.Autoplay.' + NS);
            this.off('mouseenter.Autoplay.' + NS);
            this.off('mouseleave.Autoplay.' + NS);
        },

        autoplayDefaults: {
            autoplay: true,
            autoplayDelay: 5000,
            autoplayDirection: 'normal',
            autoplayOnHover: 'pause'
        }
    };

    $.AccordionSlider.addModule('Autoplay', Autoplay, 'accordion');

})(window, jQuery);

/*
	Deep Linking module for Accordion Slider

	Adds the possibility to access the accordion using hyperlinks
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var DeepLinking = {

        initDeepLinking: function () {
            var that = this;

            // ignore the startPanel setting if there is a 
            if (this._parseHash(window.location.hash) !== false)
                this.options.startPanel = -1;

            // parse the initial hash
            this.on('init.DeepLinking.' + NS, function () {
                that._gotoHash(window.location.hash);
            });

            // check when the hash changes
            $(window).on('hashchange.DeepLinking.' + this.uniqueId + '.' + NS, function () {
                that._gotoHash(window.location.hash);
            });
        },

        _parseHash: function (hash) {
            if (hash !== '') {
                // eliminate the # symbol
                hash = hash.substring(1);

                // get the specified accordion id and panel id
                var values = hash.split('/'),
                    panelId = values.pop(),
                    accordionId = hash.slice(0, -panelId.toString().length - 1);

                if (this.$accordion.attr('id') === accordionId)
                    return {
                        'accordionID': accordionId,
                        'panelId': panelId
                    };
            }

            return false;
        },

        _gotoHash: function (hash) {
            var result = this._parseHash(hash);

            if (result === false)
                return;

            var panelId = result.panelId,
                panelIdNumber = parseInt(panelId, 10);

            // check if the specified panel id is a number or string
            if (isNaN(panelIdNumber)) {
                // get the index of the panel based on the specified id
                var panelIndex = this.$accordion.find('.as-panel#' + panelId).index();

                if (panelIndex !== -1)
                    this.openPanel(panelIndex);
            } else {
                this.openPanel(panelIdNumber);
            }

        },

        destroyDeepLinking: function () {
            $(window).off('hashchange.DeepLinking.' + this.uniqueId + '.' + NS);
        }
    };

    $.AccordionSlider.addModule('DeepLinking', DeepLinking, 'accordion');

})(window, jQuery);

/*
	JSON module for Accordion Slider

	Creates the panels based on JSON data
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var JSON = {

        JSONDataAttributesMap: {
            'width': 'data-width',
            'height': 'data-height',
            'depth': 'data-depth',
            'position': 'data-position',
            'horizontal': 'data-horizontal',
            'vertical': 'data-vertical',
            'showTransition': 'data-show-transition',
            'showOffset': 'data-show-offset',
            'showDelay': 'data-show-delay',
            'showDuration': 'data-show-duration',
            'showEasing': 'data-show-easing',
            'hideTransition': 'data-hide-transition',
            'hideOffset': 'data-',
            'hideDelay': 'data-hide-delay',
            'hideDuration': 'data-hide-duration',
            'hideEasing': 'data-hide-easing'
        },

        initJSON: function () {
            if (this.settings.JSONSource !== null)
                this.updateJSON();
        },

        updateJSON: function () {
            var that = this;

            // clear existing content and data
            this.removePanels();
            this.$panelsContainer.empty();
            this.off('JSONReady.' + NS);

            // parse the JSON data and construct the panels
            this.on('JSONReady.' + NS, function (event) {
                var jsonData = event.jsonData,
                    panels = jsonData.accordion.panels;

                // check if lazy loading is enabled
                var lazyLoading = jsonData.accordion.lazyLoading;

                $.each(panels, function (index, value) {
                    var panel = value,
                        backgroundLink,
                        backgroundOpenedLink;

                    // create the panel element
                    var panelElement = $('<div class="as-panel"></div>').appendTo(that.$panelsContainer);

                    // create the background image and link
                    if (typeof panel.backgroundLink !== 'undefined') {
                        backgroundLink = $('<a href="' + panel.backgroundLink.address + '"></a>');

                        $.each(panel.backgroundLink, function (name, value) {
                            if (name !== 'address')
                                backgroundLink.attr(name, value);
                        });

                        backgroundLink.appendTo(panelElement);
                    }

                    if (typeof panel.background !== 'undefined') {
                        var background = $('<img class="as-background"/>');

                        // check if the image will be lazy loaded
                        if (typeof lazyLoading !== 'undefined')
                            background.attr({
                                'src': lazyLoading,
                                'data-src': panel.background.source
                            });
                        else
                            background.attr({
                                'src': panel.background.source
                            });

                        // check if a retina image was specified
                        if (typeof panel.backgroundRetina !== 'undefined')
                            background.attr({
                                'data-retina': panel.backgroundRetina.source
                            });

                        $.each(panel.background, function (name, value) {
                            if (name !== 'source')
                                background.attr(name, value);
                        });

                        background.appendTo(typeof backgroundLink !== 'undefined' ? backgroundLink : panelElement);
                    }

                    // create the background image and link for the opened state of the panel
                    if (typeof panel.backgroundOpenedLink !== 'undefined') {
                        backgroundOpenedLink = $('<a href="' + panel.backgroundOpenedLink.address + '"></a>');

                        $.each(panel.backgroundOpenedLink, function (name, value) {
                            if (name !== 'address')
                                backgroundOpenedLink.attr(name, value);
                        });

                        backgroundOpenedLink.appendTo(panelElement);
                    }

                    if (typeof panel.backgroundOpened !== 'undefined') {
                        var backgroundOpened = $('<img class="as-background-opened"/>');

                        // check if the image will be lazy loaded
                        if (typeof lazyLoading !== 'undefined')
                            backgroundOpened.attr({
                                'src': lazyLoading,
                                'data-src': panel.backgroundOpened.source
                            });
                        else
                            backgroundOpened.attr({
                                'src': panel.backgroundOpened.source
                            });

                        // check if a retina image was specified
                        if (typeof panel.backgroundOpenedRetina !== 'undefined')
                            backgroundOpened.attr({
                                'data-retina': panel.backgroundOpenedRetina.source
                            });

                        $.each(panel.backgroundOpened, function (name, value) {
                            if (name !== 'source')
                                backgroundOpened.attr(name, value);
                        });

                        backgroundOpened.appendTo(typeof backgroundOpenedLink !== 'undefined' ? backgroundOpenedLink : panelElement);
                    }

                    // parse the layers recursively 
                    if (typeof panel.layers !== 'undefined')
                        that._parseLayers(panel.layers, panelElement);
                });

                that.update();
            });

            this._loadJSON();
        },

        _parseLayers: function (target, parent) {
            var that = this;

            $.each(target, function (index, value) {
                var layer = value,
                    classes = '',
                    dataAttributes = '';

                // parse the data specified for the layer and extract the classes and data attributes
                $.each(layer, function (name, value) {
                    if (name === 'style') {
                        var classList = value.split(' ');

                        $.each(classList, function (classIndex, className) {
                            classes += ' as-' + className;
                        });
                    } else if (name !== 'content' && name !== 'layers') {
                        dataAttributes += ' ' + that.JSONDataAttributesMap[name] + '="' + value + '"';
                    }
                });

                // create the layer element
                var layerElement = $('<div class="as-layer' + classes + '"' + dataAttributes + '></div>').appendTo(parent);

                // check if there are inner layers and parse those
                if (typeof value.layers !== 'undefined')
                    that._parseLayers(value.layers, layerElement);
                else
                    layerElement.html(layer.content);
            });
        },

        _loadJSON: function () {
            var that = this;

            if (this.settings.JSONSource.slice(-5) === '.json') {
                $.getJSON(this.settings.JSONSource, function (result) {
                    that.trigger({
                        type: 'JSONReady.' + NS,
                        jsonData: result
                    });
                });
            } else {
                var jsonData = $.parseJSON(this.settings.JSONSource);
                that.trigger({
                    type: 'JSONReady.' + NS,
                    jsonData: jsonData
                });
            }
        },

        destroyJSON: function () {
            this.off('JSONReady.' + NS);
        },

        JSONDefaults: {
            JSONSource: null
        }
    };

    $.AccordionSlider.addModule('JSON', JSON, 'accordion');

})(window, jQuery);

/*
	Keyboard module for Accordion Slider

	Adds keyboard navigation support to the accordion
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var Keyboard = {

        initKeyboard: function () {
            var that = this,
                hasFocus = false;

            if (this.settings.keyboard === false)
                return;

            this.$accordion.on('focus.Keyboard.' + NS, function () {
                hasFocus = true;
            });

            this.$accordion.on('blur.Keyboard.' + NS, function () {
                hasFocus = false;
            });

            $(document).on('keydown.Keyboard.' + this.uniqueId + '.' + NS, function (event) {
                if (that.settings.keyboardOnlyOnFocus === true && hasFocus === false)
                    return;

                if (event.which === 37) {
                    if (that.settings.keyboardTarget === 'page')
                        that.previousPage();
                    else
                        that.previousPanel();
                } else if (event.which === 39) {
                    if (that.settings.keyboardTarget === 'page')
                        that.nextPage();
                    else
                        that.nextPanel();
                } else if (event.which === 13) {
                    //that.$accordion.find('.as-panel').eq(that.currentIndex).children('a')[0].click();

                }
            });
        },

        destroyKeyboard: function () {
            this.$accordion.off('focus.Keyboard.' + NS);
            this.$accordion.off('blur.Keyboard.' + NS);
            $(document).off('keydown.Keyboard.' + this.uniqueId + '.' + NS);
        },

        keyboardDefaults: {
            keyboard: true,
            keyboardOnlyOnFocus: false,
            keyboardTarget: 'panel'
        }
    };

    $.AccordionSlider.addModule('Keyboard', Keyboard, 'accordion');

})(window, jQuery);

/*
	Layers module for Accordion Slider

	Adds support for animated and static layers.
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace,

        // detect the current browser name and version
        userAgent = window.navigator.userAgent.toLowerCase(),
        rmsie = /(msie) ([\w.]+)/,
        browserDetect = rmsie.exec(userAgent) || [],
        browserName = browserDetect[1],
        browserVersion = browserDetect[2];

    var Layers = {

        initLayers: function () {

            // holds references to the layers
            this.layers = [];

            // reference to the panel object
            var that = this;

            // iterate through the panel's layer jQuery objects
            // and create Layer instances for each object
            this.$panel.find('.as-layer').each(function () {
                var layer = new Layer($(this));

                that.layers.push(layer);
            });

            // check the index pf the panel against the index of the selected/opened panel
            if (this.index === this.accordion.getCurrentIndex())
                this._handleLayersInOpenedState();
            else
                this._handleLayersInClosedState();

            // listen when a panel is opened and when the panels are closed, and handle 
            // the layer's behavior based on the state of the panel
            this.accordion.on('panelOpen.Layers.' + this.panelNS, function (event) {
                if (event.index === event.previousIndex)
                    return;

                if (that.index === event.previousIndex)
                    that._handleLayersInClosedState();

                if (that.index === event.index)
                    that._handleLayersInOpenedState();
            });

            this.accordion.on('panelsClose.Layers.' + this.panelNS, function (event) {
                if (that.index === event.previousIndex)
                    that._handleLayersInClosedState();
            });
        },

        _handleLayersInOpenedState: function () {
            // show 'opened' layers and close 'closed' layers
            $.each(this.layers, function (index, layer) {
                if (layer.visibleOn === 'opened')
                    layer.show();

                if (layer.visibleOn === 'closed')
                    layer.hide();
            });
        },

        _handleLayersInClosedState: function () {
            // hide 'opened' layers and show 'closed' layers
            $.each(this.layers, function (index, layer) {
                if (layer.visibleOn === 'opened')
                    layer.hide();

                if (layer.visibleOn === 'closed')
                    layer.show();
            });
        },

        destroyLayers: function () {
            this.accordion.off('panelOpen.Layers.' + this.panelNS);
            this.accordion.off('panelsClose.Layers.' + this.panelNS);

            $.each(this.layers, function (index, layer) {
                layer.destroy();
            });
        }
    };

    var Layer = function (layer) {

        // reference to the layer jQuery object
        this.$layer = layer;

        // indicates when will the layer be visible
        // can be visible when the panel is opened, when the panel is closed or always
        this.visibleOn = 'n/a';

        // indicates whether a layer is currently visible (or hidden)
        this.isVisible = false;

        // indicates whether the layer was styled
        this.styled = false;

        this._init();
    };

    Layer.prototype = {

        _init: function () {
            // hide the layer by default
            this.$layer.css({
                'visibility': 'hidden',
                'display': 'none'
            });

            if (this.$layer.hasClass('as-opened')) {
                this.visibleOn = 'opened';
            } else if (this.$layer.hasClass('as-closed')) {
                this.visibleOn = 'closed';
            } else {
                this.visibleOn = 'always';
                this.show();
            }
        },

        /*
        	Set the size and position of the layer
        */
        _setStyle: function () {
            this.styled = true;

            this.$layer.css({
                'display': '',
                'margin': 0
            });

            // get the data attributes specified in HTML
            this.data = this.$layer.data();

            if (typeof this.data.width !== 'undefined')
                this.$layer.css('width', this.data.width);

            if (typeof this.data.height !== 'undefined')
                this.$layer.css('height', this.data.height);

            if (typeof this.data.depth !== 'undefined')
                this.$layer.css('z-index', this.data.depth);

            this.position = this.data.position ? (this.data.position).toLowerCase() : 'topleft';
            this.horizontalPosition = this.position.indexOf('right') !== -1 ? 'right' : 'left';
            this.verticalPosition = this.position.indexOf('bottom') !== -1 ? 'bottom' : 'top';

            this._setPosition();
        },

        /*
        	Set the position of the layer
        */
        _setPosition: function () {
            // set the horizontal position of the layer based on the data set
            if (typeof this.data.horizontal !== 'undefined') {
                if (this.data.horizontal === 'center') {
                    // prevent content wrapping while setting the width
                    if (this.$layer.attr('style').indexOf('width') === -1 && this.$layer.is('img') === false) {
                        this.$layer.css('white-space', 'nowrap');
                        this.$layer.css('width', this.$layer.outerWidth(true));
                    }
                    // center horizontally
                    this.$layer.css({
                        'marginLeft': 'auto',
                        'marginRight': 'auto',
                        'left': 0,
                        'right': 0
                    });
                } else {
                    this.$layer.css(this.horizontalPosition, this.data.horizontal);
                }
            } else {
                this.$layer.css(this.horizontalPosition, 0);
            }

            // set the vertical position of the layer based on the data set
            if (typeof this.data.vertical !== 'undefined') {
                if (this.data.vertical === 'center') {
                    // prevent content wrapping while setting the height
                    if (this.$layer.attr('style').indexOf('height') === -1 && this.$layer.is('img') === false) {
                        this.$layer.css('white-space', 'nowrap');
                        this.$layer.css('height', this.$layer.outerHeight(true));
                    }
                    // center vertically
                    this.$layer.css({
                        'marginTop': 'auto',
                        'marginBottom': 'auto',
                        'top': 0,
                        'bottom': 0
                    });
                } else {
                    this.$layer.css(this.verticalPosition, this.data.vertical);
                }
            } else {
                this.$layer.css(this.verticalPosition, 0);
            }
        },

        /*
        	Show the layer
        */
        show: function () {
            if (this.isVisible === true)
                return;

            this.isVisible = true;

            if (this.styled === false)
                this._setStyle();

            var that = this,
                offset = typeof this.data.showOffset !== 'undefined' ? this.data.showOffset : 50,
                duration = typeof this.data.showDuration !== 'undefined' ? this.data.showDuration / 1000 : 0.4,
                delay = typeof this.data.showDelay !== 'undefined' ? this.data.showDelay : 10;

            if (this.visibleOn === 'always' || browserName === 'msie' && parseInt(browserVersion, 10) <= 7) {
                this.$layer.css('visibility', 'visible');
            } else if (browserName === 'msie' && parseInt(browserVersion, 10) <= 9) {
                this.$layer.stop()
                    .delay(delay)
                    .css({
                        'opacity': 0,
                        'visibility': 'visible'
                    })
                    .animate({
                        'opacity': 1
                    }, duration * 1000);
            } else {
                var start = {
                        'opacity': 0,
                        'visibility': 'visible'
                    },
                    transformValues = '';

                if (this.data.showTransition === 'left')
                    transformValues = offset + 'px, 0';
                else if (this.data.showTransition === 'right')
                    transformValues = '-' + offset + 'px, 0';
                else if (this.data.showTransition === 'up')
                    transformValues = '0, ' + offset + 'px';
                else if (this.data.showTransition === 'down')
                    transformValues = '0, -' + offset + 'px';

                start.transform = LayersHelper.useTransforms() === '3d' ? 'translate3d(' + transformValues + ', 0)' : 'translate(' + transformValues + ')';
                start['-webkit-transform'] = start['-ms-transform'] = start.transform;

                var target = {
                    'opacity': 1,
                    'transition': 'all ' + duration + 's'
                };

                if (typeof this.data.showTransition !== 'undefined') {
                    target.transform = LayersHelper.useTransforms() === '3d' ? 'translate3d(0, 0, 0)' : 'translate(0, 0)';
                    target['-webkit-transform'] = target['-ms-transform'] = target.transform;
                }

                // listen when the layer animation is complete
                this.$layer.on('transitionend webkitTransitionEnd oTransitionEnd msTransitionEnd', function () {
                    that.$layer.off('transitionend webkitTransitionEnd oTransitionEnd msTransitionEnd');

                    // remove the transition property in order to prevent other animations of the element
                    that.$layer.css('transition', '');
                });

                this.$layer.css(start)
                    .delay(delay)
                    .queue(function () {
                        that.$layer.css(target);
                        $(this).dequeue();
                    });
            }
        },

        /*
        	Hide the layer
        */
        hide: function () {
            if (this.isVisible === false)
                return;

            this.isVisible = false;

            var that = this,
                offset = typeof this.data.hideOffset !== 'undefined' ? this.data.hideOffset : 50,
                duration = typeof this.data.hideDuration !== 'undefined' ? this.data.hideDuration / 1000 : 0.4,
                delay = typeof this.data.hideDelay !== 'undefined' ? this.data.hideDelay : 10;

            if (this.visibleOn === 'always' || browserName === 'msie' && parseInt(browserVersion, 10) <= 7) {
                this.$layer.css('visibility', 'hidden');
            } else if (browserName === 'msie' && parseInt(browserVersion, 10) <= 9) {
                this.$layer.stop()
                    .delay(delay)
                    .animate({
                        'opacity': 0
                    }, duration * 1000, function () {
                        $(this).css({
                            'visibility': 'hidden'
                        });
                    });
            } else {
                var target = {
                        'opacity': 0,
                        'transition': 'all ' + duration + 's'
                    },
                    transformValues = '';

                if (this.data.hideTransition === 'left')
                    transformValues = '-' + offset + 'px, 0';
                else if (this.data.hideTransition === 'right')
                    transformValues = offset + 'px, 0';
                else if (this.data.hideTransition === 'up')
                    transformValues = '0, -' + offset + 'px';
                else if (this.data.hideTransition === 'down')
                    transformValues = '0, ' + offset + 'px';

                target.transform = LayersHelper.useTransforms() === '3d' ? 'translate3d(' + transformValues + ', 0)' : 'translate(' + transformValues + ')';
                target['-webkit-transform'] = target['-ms-transform'] = target.transform;

                // listen when the layer animation is complete
                this.$layer.on('transitionend webkitTransitionEnd oTransitionEnd msTransitionEnd', function () {
                    that.$layer.off('transitionend webkitTransitionEnd oTransitionEnd msTransitionEnd');

                    // remove the transition property in order to prevent other animations of the element
                    that.$layer.css('transition', '');

                    // hide the layer after transition
                    if (that.isVisible === false)
                        that.$layer.css('visibility', 'hidden');
                });

                this.$layer.delay(delay)
                    .queue(function () {
                        that.$layer.css(target);
                        $(this).dequeue();
                    });
            }
        },

        destroy: function () {
            this.$layer.attr('style', '');
        }
    };

    $.AccordionSlider.addModule('Layers', Layers, 'panel');

    var LayersHelper = {

        checked: false,

        transforms: '',

        /*
        	Check if 2D and 3D transforms are supported
        	Inspired by Modernizr
        */
        useTransforms: function () {
            if (this.checked === true)
                return this.transforms;

            this.checked = true;

            var div = document.createElement('div');

            // check if 3D transforms are supported
            if (typeof div.style.WebkitPerspective !== 'undefined' || typeof div.style.perspective !== 'undefined')
                this.transforms = '3d';

            // additional checks for Webkit
            if (this.transforms === '3d' && typeof div.styleWebkitPerspective !== 'undefined') {
                var style = document.createElement('style');
                style.textContent = '@media (transform-3d),(-webkit-transform-3d){#test-3d{left:9px;position:absolute;height:5px;margin:0;padding:0;border:0;}}';
                document.getElementsByTagName('head')[0].appendChild(style);

                div.id = 'test-3d';
                document.body.appendChild(div);

                if (!(div.offsetLeft === 9 && div.offsetHeight === 5))
                    this.transforms = '';

                style.parentNode.removeChild(style);
                div.parentNode.removeChild(div);
            }

            // check if 2D transforms are supported
            if (this.transforms === '' && (typeof div.style['-webkit-transform'] !== 'undefined' || typeof div.style.transform !== 'undefined'))
                this.transforms = '2d';

            return this.transforms;
        }
    };

})(window, jQuery);

/*
	Lazy Loading module for Accordion Slider

	Loads marked images only when they are in the view
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var LazyLoading = {

        initLazyLoading: function () {
            // listen when the page changes or when the accordion is updated (because the number of visible panels might change)
            this.on('update.LazyLoading.' + NS, $.proxy(this._checkImages, this));
            this.on('pageScroll.LazyLoading.' + NS, $.proxy(this._checkImages, this));
        },

        _checkImages: function () {
            var that = this,
                firstVisiblePanel = this._getFirstPanelFromPage(),
                lastVisiblePanel = this._getLastPanelFromPage(),

                // get all panels that are currently visible
                panelsToCheck = lastVisiblePanel !== this.getTotalPanels() - 1 ? this.panels.slice(firstVisiblePanel, lastVisiblePanel + 1) : this.panels.slice(firstVisiblePanel);

            // loop through all the visible panels, verify if there are unloaded images, and load them
            $.each(panelsToCheck, function (index, element) {
                var $panel = element.$panel;

                if (typeof $panel.attr('data-loaded') === 'undefined') {
                    $panel.attr('data-loaded', true);

                    $panel.find('img').each(function () {
                        var image = $(this);
                        that._loadImage(image, element);
                    });
                }
            });
        },

        _loadImage: function (image, panel) {
            if (typeof image.attr('data-src') !== 'undefined') {
                // create a new image element
                var newImage = $(new Image());

                // copy the class(es) and inline style
                newImage.attr('class', image.attr('class'));
                newImage.attr('style', image.attr('style'));

                // copy the data attributes
                $.each(image.data(), function (name, value) {
                    newImage.attr('data-' + name, value);
                });

                // copy the width and height attributes if they exist
                if (typeof image.attr('width') !== 'undefined')
                    newImage.attr('width', image.attr('width'));

                if (typeof image.attr('height') !== 'undefined')
                    newImage.attr('height', image.attr('height'));

                if (typeof image.attr('alt') !== 'undefined')
                    newImage.attr('alt', image.attr('alt'));

                if (typeof image.attr('title') !== 'undefined')
                    newImage.attr('title', image.attr('title'));

                // assign the source of the image
                newImage.attr('src', image.attr('data-src'));
                newImage.removeAttr('data-src');

                // add the new image in the same container and remove the older image
                newImage.insertAfter(image);
                image.remove();
            }
        },

        destroyLazyLoading: function () {
            this.off('update.LazyLoading.' + NS);
            this.off('pageScroll.LazyLoading.' + NS);
        }
    };

    $.AccordionSlider.addModule('LazyLoading', LazyLoading, 'accordion');

})(window, jQuery);

/*
	MouseWheel module for Accordion Slider

	Adds mouse wheel support for scrolling through pages or individual panels
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var MouseWheel = {

        mouseWheelEventType: '',

        allowMouseWheelScroll: true,

        initMouseWheel: function () {
            var that = this;

            if (this.settings.mouseWheel === false)
                return;

            // get the current mouse wheel event used in the browser
            if ('onwheel' in document)
                this.mouseWheelEventType = 'wheel';
            else if ('onmousewheel' in document)
                this.mouseWheelEventType = 'mousewheel';
            else if ('onDomMouseScroll' in document)
                this.mouseWheelEventType = 'DomMouseScroll';
            else if ('onMozMousePixelScroll' in document)
                this.mouseWheelEventType = 'MozMousePixelScroll';

            this.on(this.mouseWheelEventType + '.' + NS, function (event) {
                event.preventDefault();

                var eventObject = event.originalEvent,
                    delta;

                // get the movement direction and speed indicated in the delta property
                if (typeof eventObject.detail !== 'undefined')
                    delta = eventObject.detail;

                if (typeof eventObject.wheelDelta !== 'undefined')
                    delta = eventObject.wheelDelta;

                if (typeof eventObject.deltaY !== 'undefined')
                    delta = eventObject.deltaY * -1;

                if (that.allowMouseWheelScroll === true && Math.abs(delta) >= that.settings.mouseWheelSensitivity) {
                    that.allowMouseWheelScroll = false;

                    setTimeout(function () {
                        that.allowMouseWheelScroll = true;
                    }, 500);

                    if (delta <= -that.settings.mouseWheelSensitivity)
                        if (that.settings.mouseWheelTarget === 'page')
                            that.nextPage();
                        else
                            that.nextPanel();
                    else if (delta >= that.settings.mouseWheelSensitivity)
                        if (that.settings.mouseWheelTarget === 'page')
                            that.previousPage();
                        else
                            that.previousPanel();
                }
            });
        },

        destroyMouseWheel: function () {
            this.off(this.mouseWheelEventType + '.' + NS);
        },

        mouseWheelDefaults: {
            mouseWheel: true,
            mouseWheelSensitivity: 10,
            mouseWheelTarget: 'panel'
        }
    };

    $.AccordionSlider.addModule('MouseWheel', MouseWheel, 'accordion');

})(window, jQuery);

/*
	Retina module for Accordion Slider

	Checks if a high resolution image was specified and replaces the default image with the high DPI one
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var Retina = {

        initRetina: function () {
            var that = this;

            // check if the current display supports high PPI
            if (this._isRetina() === false)
                return;

            // check if the Lazy Loading module is enabled and overwrite its loading method
            // if not, check all images from the accordion
            if (typeof this._loadImage !== 'undefined') {
                this._loadImage = this._loadRetinaImage;
            } else {
                this.on('update.Retina.' + NS, $.proxy(this._checkRetinaImages, this));
            }
        },

        _isRetina: function () {
            if (window.devicePixelRatio >= 2)
                return true;

            if (window.matchMedia && (window.matchMedia("(-webkit-min-device-pixel-ratio: 2),(min-resolution: 2dppx)").matches))
                return true;

            return false;
        },

        _checkRetinaImages: function () {
            var that = this;

            this.off('update.Retina.' + NS);

            $.each(this.panels, function (index, element) {
                var $panel = element.$panel;

                if (typeof $panel.attr('data-loaded') === 'undefined') {
                    $panel.attr('data-loaded', true);

                    $panel.find('img').each(function () {
                        var image = $(this);
                        that._loadRetinaImage(image, element);
                    });
                }
            });
        },

        _loadRetinaImage: function (image, panel) {
            var retinaFound = false,
                newImagePath = '';

            // check if there is a retina image specified
            if (typeof image.attr('data-retina') !== 'undefined') {
                retinaFound = true;

                newImagePath = image.attr('data-retina');
                image.removeAttr('data-retina');
            }

            // check if there is a lazy loaded, non-retina, image specified
            if (typeof image.attr('data-src') !== 'undefined') {
                if (retinaFound === false)
                    newImagePath = image.attr('data-src');

                image.removeAttr('data-src');
            }

            // replace the image
            if (newImagePath !== '') {
                // create a new image element
                var newImage = $(new Image());

                // copy the class(es) and inline style
                newImage.attr('class', image.attr('class'));
                newImage.attr('style', image.attr('style'));

                // copy the data attributes
                $.each(image.data(), function (name, value) {
                    newImage.attr('data-' + name, value);
                });

                // copy the width and height attributes if they exist
                if (typeof image.attr('width') !== 'undefined')
                    newImage.attr('width', image.attr('width'));

                if (typeof image.attr('height') !== 'undefined')
                    newImage.attr('height', image.attr('height'));

                if (typeof image.attr('alt') !== 'undefined')
                    newImage.attr('alt', image.attr('alt'));

                if (typeof image.attr('title') !== 'undefined')
                    newImage.attr('title', image.attr('title'));

                // assign the source of the image
                newImage.attr('src', newImagePath);

                // add the new image in the same container and remove the older image
                newImage.insertAfter(image);
                image.remove();
            }
        },

        destroyRetina: function () {

        }
    };

    $.AccordionSlider.addModule('Retina', Retina, 'accordion');

})(window, jQuery);

/*
	Smart Video module for Accordion Slider

	Adds automatic control for several video players and providers
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace,

        // detect the current browser name and version
        userAgent = window.navigator.userAgent.toLowerCase();

    var SmartVideo = {

        initSmartVideo: function () {
            this._setupVideos();
        },

        _setupVideos: function () {
            var that = this;

            // find all video elements from the accordion, instantiate the SmartVideo for each of the video,
            // and trigger the set actions for the videos' events
            this.$accordion.find('.as-video').each(function () {
                var video = $(this);

                video.videoController();

                video.on('videoPlay.SmartVideo', function () {
                    if (that.settings.playVideoAction === 'stopAutoplay' && typeof that.stopAutoplay !== 'undefined') {
                        that.stopAutoplay();
                        that.settings.autoplay = false;
                    }

                    var eventObject = {
                        type: 'videoPlay',
                        video: video
                    };
                    that.trigger(eventObject);
                    if ($.isFunction(that.settings.videoPlay))
                        that.settings.videoPlay.call(that, eventObject);
                });

                video.on('videoPause.SmartVideo', function () {
                    if (that.settings.pauseVideoAction === 'startAutoplay' && typeof that.startAutoplay !== 'undefined') {
                        that.startAutoplay();
                        that.settings.autoplay = true;
                    }

                    var eventObject = {
                        type: 'videoPause',
                        video: video
                    };
                    that.trigger(eventObject);
                    if ($.isFunction(that.settings.videoPause))
                        that.settings.videoPause.call(that, eventObject);
                });

                video.on('videoEnded.SmartVideo', function () {
                    if (that.settings.endVideoAction === 'startAutoplay' && typeof that.startAutoplay !== 'undefined') {
                        that.startAutoplay();
                        that.settings.autoplay = true;
                    } else if (that.settings.endVideoAction === 'nextPanel') {
                        that.nextPanel();
                    } else if (that.settings.endVideoAction === 'replayVideo') {
                        video.videoController('replay');
                    }

                    var eventObject = {
                        type: 'videoEnd',
                        video: video
                    };
                    that.trigger(eventObject);
                    if ($.isFunction(that.settings.videoEnd))
                        that.settings.videoEnd.call(that, eventObject);
                });
            });

            // when a panel opens, check to see if there are video actions associated 
            // with the opening an closing of individual panels
            this.on('panelOpen.SmartVideo.' + NS, function (event) {
                // handle the video from the closed panel
                if (event.previousIndex !== -1 && that.$panelsContainer.find('.as-panel').eq(event.previousIndex).find('.as-video').length !== 0) {
                    var previousVideo = that.$panelsContainer.find('.as-panel').eq(event.previousIndex).find('.as-video');

                    if (that.settings.closePanelVideoAction === 'stopVideo')
                        previousVideo.videoController('stop');
                    else if (that.settings.closePanelVideoAction === 'pauseVideo')
                        previousVideo.videoController('pause');
                }

                // handle the video from the opened panel
                if (that.$panelsContainer.find('.as-panel').eq(event.index).find('.as-video').length !== 0) {
                    var currentVideo = that.$panelsContainer.find('.as-panel').eq(event.index).find('.as-video');

                    if (that.settings.openPanelVideoAction === 'playVideo')
                        currentVideo.videoController('play');
                }
            });

            // when all panels close, check to see if there is a video in the 
            // previously opened panel and handle it
            this.on('panelsClose.SmartVideo.' + NS, function (event) {
                // handle the video from the closed panel
                if (event.previousIndex !== -1 && that.$panelsContainer.find('.as-panel').eq(event.previousIndex).find('.as-video').length !== 0) {
                    var previousVideo = that.$panelsContainer.find('.as-panel').eq(event.previousIndex).find('.as-video');

                    if (that.settings.closePanelVideoAction === 'stopVideo')
                        previousVideo.videoController('stop');
                    else if (that.settings.closePanelVideoAction === 'pauseVideo')
                        previousVideo.videoController('pause');
                }
            });
        },

        destroySmartVideo: function () {
            this.$accordion.find('.as-video').each(function () {
                var video = $(this);

                video.off('SmartVideo');
                $(this).videoController('destroy');
            });

            this.off('panelOpen.SmartVideo.' + NS);
            this.off('panelsClose.SmartVideo.' + NS);
        },

        smartVideoDefaults: {
            openPanelVideoAction: 'playVideo',
            closePanelVideoAction: 'pauseVideo',
            playVideoAction: 'stopAutoplay',
            pauseVideoAction: 'none',
            endVideoAction: 'none',
            videoPlay: function () {},
            videoPause: function () {},
            videoEnd: function () {}
        }
    };

    $.AccordionSlider.addModule('SmartVideo', SmartVideo, 'accordion');

})(window, jQuery);

// Video Controller jQuery plugin
// Creates a universal controller for multiple video types and providers
;
(function ($) {

    "use strict";

    // Check if an iOS device is used.
    // This information is important because a video can not be
    // controlled programmatically unless the user has started the video manually.
    var isIOS = window.navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;

    var VideoController = function (instance, options) {
        this.$video = $(instance);
        this.options = options;
        this.settings = {};
        this.player = null;

        this._init();
    };

    VideoController.prototype = {

        _init: function () {
            this.settings = $.extend({}, this.defaults, this.options);

            var that = this,
                players = $.VideoController.players,
                videoID = this.$video.attr('id');

            // Loop through the available video players
            // and check if the targeted video element is supported by one of the players.
            // If a compatible type is found, store the video type.
            for (var name in players) {
                if (typeof players[name] !== 'undefined' && players[name].isType(this.$video)) {
                    this.player = new players[name](this.$video);
                    break;
                }
            }

            // Return if the player could not be instantiated
            if (this.player === null) {
                return;
            }

            // Add event listeners
            var events = ['ready', 'start', 'play', 'pause', 'ended'];

            $.each(events, function (index, element) {
                var event = 'video' + element.charAt(0).toUpperCase() + element.slice(1);

                that.player.on(element, function () {
                    that.trigger({
                        type: event,
                        video: videoID
                    });
                    if ($.isFunction(that.settings[event])) {
                        that.settings[event].call(that, {
                            type: event,
                            video: videoID
                        });
                    }
                });
            });
        },

        play: function () {
            if (isIOS === true && this.player.isStarted() === false || this.player.getState() === 'playing') {
                return;
            }

            this.player.play();
        },

        stop: function () {
            if (isIOS === true && this.player.isStarted() === false || this.player.getState() === 'stopped') {
                return;
            }

            this.player.stop();
        },

        pause: function () {
            if (isIOS === true && this.player.isStarted() === false || this.player.getState() === 'paused') {
                return;
            }

            this.player.pause();
        },

        replay: function () {
            if (isIOS === true && this.player.isStarted() === false) {
                return;
            }

            this.player.replay();
        },

        on: function (type, callback) {
            return this.$video.on(type, callback);
        },

        off: function (type) {
            return this.$video.off(type);
        },

        trigger: function (data) {
            return this.$video.triggerHandler(data);
        },

        destroy: function () {
            if (this.player.isStarted() === true) {
                this.stop();
            }

            this.player.off('ready');
            this.player.off('start');
            this.player.off('play');
            this.player.off('pause');
            this.player.off('ended');

            this.$video.removeData('videoController');
        },

        defaults: {
            videoReady: function () {},
            videoStart: function () {},
            videoPlay: function () {},
            videoPause: function () {},
            videoEnded: function () {}
        }
    };

    $.VideoController = {
        players: {},

        addPlayer: function (name, player) {
            this.players[name] = player;
        }
    };

    $.fn.videoController = function (options) {
        var args = Array.prototype.slice.call(arguments, 1);

        return this.each(function () {
            // Instantiate the video controller or call a function on the current instance
            if (typeof $(this).data('videoController') === 'undefined') {
                var newInstance = new VideoController(this, options);

                // Store a reference to the instance created
                $(this).data('videoController', newInstance);
            } else if (typeof options !== 'undefined') {
                var currentInstance = $(this).data('videoController');

                // Check the type of argument passed
                if (typeof currentInstance[options] === 'function') {
                    currentInstance[options].apply(currentInstance, args);
                } else {
                    $.error(options + ' does not exist in videoController.');
                }
            }
        });
    };

    // Base object for the video players
    var Video = function (video) {
        this.$video = video;
        this.player = null;
        this.ready = false;
        this.started = false;
        this.state = '';
        this.events = $({});

        this._init();
    };

    Video.prototype = {
        _init: function () {},

        play: function () {},

        pause: function () {},

        stop: function () {},

        replay: function () {},

        isType: function () {},

        isReady: function () {
            return this.ready;
        },

        isStarted: function () {
            return this.started;
        },

        getState: function () {
            return this.state;
        },

        on: function (type, callback) {
            return this.events.on(type, callback);
        },

        off: function (type) {
            return this.events.off(type);
        },

        trigger: function (data) {
            return this.events.triggerHandler(data);
        }
    };

    // YouTube video
    var YoutubeVideoHelper = {
        youtubeAPIAdded: false,
        youtubeVideos: []
    };

    var YoutubeVideo = function (video) {
        this.init = false;
        var youtubeAPILoaded = window.YT && window.YT.Player;

        if (typeof youtubeAPILoaded !== 'undefined') {
            Video.call(this, video);
        } else {
            YoutubeVideoHelper.youtubeVideos.push({
                'video': video,
                'scope': this
            });

            if (YoutubeVideoHelper.youtubeAPIAdded === false) {
                YoutubeVideoHelper.youtubeAPIAdded = true;

                var tag = document.createElement('script');
                tag.src = "http://www.youtube.com/player_api";
                var firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

                window.onYouTubePlayerAPIReady = function () {
                    $.each(YoutubeVideoHelper.youtubeVideos, function (index, element) {
                        Video.call(element.scope, element.video);
                    });
                };
            }
        }
    };

    YoutubeVideo.prototype = new Video();
    YoutubeVideo.prototype.constructor = YoutubeVideo;
    $.VideoController.addPlayer('YoutubeVideo', YoutubeVideo);

    YoutubeVideo.isType = function (video) {
        if (video.is('iframe')) {
            var src = video.attr('src');

            if (src.indexOf('youtube.com') !== -1 || src.indexOf('youtu.be') !== -1) {
                return true;
            }
        }

        return false;
    };

    YoutubeVideo.prototype._init = function () {
        this.init = true;
        this._setup();
    };

    YoutubeVideo.prototype._setup = function () {
        var that = this;

        // Get a reference to the player
        this.player = new YT.Player(this.$video[0], {
            events: {
                'onReady': function () {
                    that.trigger({
                        type: 'ready'
                    });
                    that.ready = true;
                },

                'onStateChange': function (event) {
                    switch (event.data) {
                        case YT.PlayerState.PLAYING:
                            if (that.started === false) {
                                that.started = true;
                                that.trigger({
                                    type: 'start'
                                });
                            }

                            that.state = 'playing';
                            that.trigger({
                                type: 'play'
                            });
                            break;

                        case YT.PlayerState.PAUSED:
                            that.state = 'paused';
                            that.trigger({
                                type: 'pause'
                            });
                            break;

                        case YT.PlayerState.ENDED:
                            that.state = 'ended';
                            that.trigger({
                                type: 'ended'
                            });
                            break;
                    }
                }
            }
        });
    };

    YoutubeVideo.prototype.play = function () {
        var that = this;

        if (this.ready === true) {
            this.player.playVideo();
        } else {
            var timer = setInterval(function () {
                if (that.ready === true) {
                    clearInterval(timer);
                    that.player.playVideo();
                }
            }, 100);
        }
    };

    YoutubeVideo.prototype.pause = function () {
        // On iOS, simply pausing the video can make other videos unresponsive
        // so we stop the video instead.
        if (isIOS === true) {
            this.stop();
        } else {
            this.player.pauseVideo();
        }
    };

    YoutubeVideo.prototype.stop = function () {
        this.player.seekTo(1);
        this.player.stopVideo();
        this.state = 'stopped';
    };

    YoutubeVideo.prototype.replay = function () {
        this.player.seekTo(1);
        this.player.playVideo();
    };

    YoutubeVideo.prototype.on = function (type, callback) {
        var that = this;

        if (this.init === true) {
            Video.prototype.on.call(this, type, callback);
        } else {
            var timer = setInterval(function () {
                if (that.init === true) {
                    clearInterval(timer);
                    Video.prototype.on.call(that, type, callback);
                }
            }, 100);
        }
    };

    // Vimeo video
    var VimeoVideoHelper = {
        vimeoAPIAdded: false,
        vimeoVideos: []
    };

    var VimeoVideo = function (video) {
        this.init = false;

        if (typeof window.Froogaloop !== 'undefined') {
            Video.call(this, video);
        } else {
            VimeoVideoHelper.vimeoVideos.push({
                'video': video,
                'scope': this
            });

            if (VimeoVideoHelper.vimeoAPIAdded === false) {
                VimeoVideoHelper.vimeoAPIAdded = true;

                var tag = document.createElement('script');
                tag.src = "http://a.vimeocdn.com/js/froogaloop2.min.js";
                var firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

                var checkVimeoAPITimer = setInterval(function () {
                    if (typeof window.Froogaloop !== 'undefined') {
                        clearInterval(checkVimeoAPITimer);

                        $.each(VimeoVideoHelper.vimeoVideos, function (index, element) {
                            Video.call(element.scope, element.video);
                        });
                    }
                }, 100);
            }
        }
    };

    VimeoVideo.prototype = new Video();
    VimeoVideo.prototype.constructor = VimeoVideo;
    $.VideoController.addPlayer('VimeoVideo', VimeoVideo);

    VimeoVideo.isType = function (video) {
        if (video.is('iframe')) {
            var src = video.attr('src');

            if (src.indexOf('vimeo.com') !== -1) {
                return true;
            }
        }

        return false;
    };

    VimeoVideo.prototype._init = function () {
        this.init = true;
        this._setup();
    };

    VimeoVideo.prototype._setup = function () {
        var that = this;

        // Get a reference to the player
        this.player = $f(this.$video[0]);

        this.player.addEvent('ready', function () {
            that.ready = true;
            that.trigger({
                type: 'ready'
            });

            that.player.addEvent('play', function () {
                if (that.started === false) {
                    that.started = true;
                    that.trigger({
                        type: 'start'
                    });
                }

                that.state = 'playing';
                that.trigger({
                    type: 'play'
                });
            });

            that.player.addEvent('pause', function () {
                that.state = 'paused';
                that.trigger({
                    type: 'pause'
                });
            });

            that.player.addEvent('finish', function () {
                that.state = 'ended';
                that.trigger({
                    type: 'ended'
                });
            });
        });
    };

    VimeoVideo.prototype.play = function () {
        var that = this;

        if (this.ready === true) {
            this.player.api('play');
        } else {
            var timer = setInterval(function () {
                if (that.ready === true) {
                    clearInterval(timer);
                    that.player.api('play');
                }
            }, 100);
        }
    };

    VimeoVideo.prototype.pause = function () {
        this.player.api('pause');
    };

    VimeoVideo.prototype.stop = function () {
        this.player.api('seekTo', 0);
        this.player.api('pause');
        this.state = 'stopped';
    };

    VimeoVideo.prototype.replay = function () {
        this.player.api('seekTo', 0);
        this.player.api('play');
    };

    VimeoVideo.prototype.on = function (type, callback) {
        var that = this;

        if (this.init === true) {
            Video.prototype.on.call(this, type, callback);
        } else {
            var timer = setInterval(function () {
                if (that.init === true) {
                    clearInterval(timer);
                    Video.prototype.on.call(that, type, callback);
                }
            }, 100);
        }
    };

    // HTML5 video
    var HTML5Video = function (video) {
        Video.call(this, video);
    };

    HTML5Video.prototype = new Video();
    HTML5Video.prototype.constructor = HTML5Video;
    $.VideoController.addPlayer('HTML5Video', HTML5Video);

    HTML5Video.isType = function (video) {
        if (video.is('video') && video.hasClass('video-js') === false && video.hasClass('sublime') === false) {
            return true;
        }

        return false;
    };

    HTML5Video.prototype._init = function () {
        var that = this;

        // Get a reference to the player
        this.player = this.$video[0];
        this.ready = true;

        this.player.addEventListener('play', function () {
            if (that.started === false) {
                that.started = true;
                that.trigger({
                    type: 'start'
                });
            }

            that.state = 'playing';
            that.trigger({
                type: 'play'
            });
        });

        this.player.addEventListener('pause', function () {
            that.state = 'paused';
            that.trigger({
                type: 'pause'
            });
        });

        this.player.addEventListener('ended', function () {
            that.state = 'ended';
            that.trigger({
                type: 'ended'
            });
        });
    };

    HTML5Video.prototype.play = function () {
        this.player.play();
    };

    HTML5Video.prototype.pause = function () {
        this.player.pause();
    };

    HTML5Video.prototype.stop = function () {
        this.player.currentTime = 0;
        this.player.pause();
        this.state = 'stopped';
    };

    HTML5Video.prototype.replay = function () {
        this.player.currentTime = 0;
        this.player.play();
    };

    // VideoJS video
    var VideoJSVideo = function (video) {
        Video.call(this, video);
    };

    VideoJSVideo.prototype = new Video();
    VideoJSVideo.prototype.constructor = VideoJSVideo;
    $.VideoController.addPlayer('VideoJSVideo', VideoJSVideo);

    VideoJSVideo.isType = function (video) {
        if ((typeof video.attr('data-videojs-id') !== 'undefined' || video.hasClass('video-js')) && typeof videojs !== 'undefined') {
            return true;
        }

        return false;
    };

    VideoJSVideo.prototype._init = function () {
        var that = this,
            videoID = this.$video.hasClass('video-js') ? this.$video.attr('id') : this.$video.attr('data-videojs-id');

        this.player = videojs(videoID);

        this.player.ready(function () {
            that.ready = true;
            that.trigger({
                type: 'ready'
            });

            that.player.on('play', function () {
                if (that.started === false) {
                    that.started = true;
                    that.trigger({
                        type: 'start'
                    });
                }

                that.state = 'playing';
                that.trigger({
                    type: 'play'
                });
            });

            that.player.on('pause', function () {
                that.state = 'paused';
                that.trigger({
                    type: 'pause'
                });
            });

            that.player.on('ended', function () {
                that.state = 'ended';
                that.trigger({
                    type: 'ended'
                });
            });
        });
    };

    VideoJSVideo.prototype.play = function () {
        this.player.play();
    };

    VideoJSVideo.prototype.pause = function () {
        this.player.pause();
    };

    VideoJSVideo.prototype.stop = function () {
        this.player.currentTime(0);
        this.player.pause();
        this.state = 'stopped';
    };

    VideoJSVideo.prototype.replay = function () {
        this.player.currentTime(0);
        this.player.play();
    };

    // Sublime video
    var SublimeVideo = function (video) {
        Video.call(this, video);
    };

    SublimeVideo.prototype = new Video();
    SublimeVideo.prototype.constructor = SublimeVideo;
    $.VideoController.addPlayer('SublimeVideo', SublimeVideo);

    SublimeVideo.isType = function (video) {
        if (video.hasClass('sublime') && typeof sublime !== 'undefined') {
            return true;
        }

        return false;
    };

    SublimeVideo.prototype._init = function () {
        var that = this;

        sublime.ready(function () {
            // Get a reference to the player
            that.player = sublime.player(that.$video.attr('id'));

            that.ready = true;
            that.trigger({
                type: 'ready'
            });

            that.player.on('play', function () {
                if (that.started === false) {
                    that.started = true;
                    that.trigger({
                        type: 'start'
                    });
                }

                that.state = 'playing';
                that.trigger({
                    type: 'play'
                });
            });

            that.player.on('pause', function () {
                that.state = 'paused';
                that.trigger({
                    type: 'pause'
                });
            });

            that.player.on('stop', function () {
                that.state = 'stopped';
                that.trigger({
                    type: 'stop'
                });
            });

            that.player.on('end', function () {
                that.state = 'ended';
                that.trigger({
                    type: 'ended'
                });
            });
        });
    };

    SublimeVideo.prototype.play = function () {
        this.player.play();
    };

    SublimeVideo.prototype.pause = function () {
        this.player.pause();
    };

    SublimeVideo.prototype.stop = function () {
        this.player.stop();
    };

    SublimeVideo.prototype.replay = function () {
        this.player.stop();
        this.player.play();
    };

    // JWPlayer video
    var JWPlayerVideo = function (video) {
        Video.call(this, video);
    };

    JWPlayerVideo.prototype = new Video();
    JWPlayerVideo.prototype.constructor = JWPlayerVideo;
    $.VideoController.addPlayer('JWPlayerVideo', JWPlayerVideo);

    JWPlayerVideo.isType = function (video) {
        if ((typeof video.attr('data-jwplayer-id') !== 'undefined' || video.hasClass('jwplayer') || video.find("object[data*='jwplayer']").length !== 0) &&
            typeof jwplayer !== 'undefined') {
            return true;
        }

        return false;
    };

    JWPlayerVideo.prototype._init = function () {
        var that = this,
            videoID;

        if (this.$video.hasClass('jwplayer')) {
            videoID = this.$video.attr('id');
        } else if (typeof this.$video.attr('data-jwplayer-id') !== 'undefined') {
            videoID = this.$video.attr('data-jwplayer-id');
        } else if (this.$video.find("object[data*='jwplayer']").length !== 0) {
            videoID = this.$video.find('object').attr('id');
        }

        // Get a reference to the player
        this.player = jwplayer(videoID);

        this.player.onReady(function () {
            that.ready = true;
            that.trigger({
                type: 'ready'
            });

            that.player.onPlay(function () {
                if (that.started === false) {
                    that.started = true;
                    that.trigger({
                        type: 'start'
                    });
                }

                that.state = 'playing';
                that.trigger({
                    type: 'play'
                });
            });

            that.player.onPause(function () {
                that.state = 'paused';
                that.trigger({
                    type: 'pause'
                });
            });

            that.player.onComplete(function () {
                that.state = 'ended';
                that.trigger({
                    type: 'ended'
                });
            });
        });
    };

    JWPlayerVideo.prototype.play = function () {
        this.player.play(true);
    };

    JWPlayerVideo.prototype.pause = function () {
        this.player.pause(true);
    };

    JWPlayerVideo.prototype.stop = function () {
        this.player.stop();
        this.state = 'stopped';
    };

    JWPlayerVideo.prototype.replay = function () {
        this.player.seek(0);
        this.player.play(true);
    };

})(jQuery);

/*
	Swap Background module for Accordion Slider

	Allows a different image to be displayed as the panel's background
	when the panel is selected
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var SwapBackgroundHelper = {
        cssTransitions: null,

        cssTransitionEndEvents: 'transitionend webkitTransitionEnd oTransitionEnd msTransitionEnd',

        checkCSSTransitions: function () {
            if (this.cssTransitions !== null)
                return this.cssTransitions;

            var element = document.body || document.documentElement,
                elementStyle = element.style;

            if (typeof elementStyle.transition !== 'undefined' ||
                typeof elementStyle.WebkitTransition !== 'undefined' ||
                typeof elementStyle.MozTransition !== 'undefined' ||
                typeof elementStyle.OTransition !== 'undefined')
                this.cssTransitions = true;
            else
                this.cssTransitions = false;

            return this.cssTransitions;
        }
    };

    var SwapBackground = {

        initSwapBackground: function () {
            var that = this;

            this.on('panelOpen.SwapBackground.' + NS, function (event) {
                // get the currently opened panel
                var panel = that.getPanelAt(event.index),
                    background = panel.$panel.find('.as-background'),
                    opened = panel.$panel.find('.as-background-opened');

                // fade in the opened content
                if (opened.length !== 0) {
                    opened.css({
                        'visibility': 'visible',
                        'opacity': 0
                    });
                    that._fadeInBackground(opened);

                    if (background.length !== 0 && that.settings.fadeOutBackground === true)
                        that._fadeOutBackground(background);
                }

                if (event.previousIndex !== -1 && event.index !== event.previousIndex) {
                    // get the previously opened panel
                    var previousPanel = that.getPanelAt(event.previousIndex),
                        previousBackground = previousPanel.$panel.find('.as-background'),
                        previousOpened = previousPanel.$panel.find('.as-background-opened');

                    // fade out the opened content
                    if (previousOpened.length !== 0) {
                        that._fadeOutBackground(previousOpened);

                        if (previousBackground.length !== 0 && that.settings.fadeOutBackground === true)
                            that._fadeInBackground(previousBackground);
                    }
                }
            });

            this.on('panelsClose.SwapBackground.' + NS, function (event) {
                if (event.previousIndex === -1)
                    return;

                // get the previously opened panel
                var panel = that.getPanelAt(event.previousIndex),
                    background = panel.$panel.find('.as-background'),
                    opened = panel.$panel.find('.as-background-opened');

                // fade out the opened content
                if (opened.length !== 0) {
                    that._fadeOutBackground(opened);

                    if (background.length !== 0 && that.settings.fadeOutBackground === true)
                        that._fadeInBackground(background);
                }
            });
        },

        _fadeInBackground: function (target) {
            var duration = this.settings.swapBackgroundDuration;

            target.css({
                'visibility': 'visible'
            });

            if (SwapBackgroundHelper.checkCSSTransitions() === true) {
                // remove the transition property after the animation completes
                target.off(SwapBackgroundHelper.cssTransitionEndEvents).on(SwapBackgroundHelper.cssTransitionEndEvents, function (event) {
                    if (event.target !== event.currentTarget) {
                        return;
                    }

                    target.off(SwapBackgroundHelper.cssTransitionEndEvents);
                    target.css({
                        'transition': ''
                    });
                });

                setTimeout(function () {
                    target.css({
                        'opacity': 1,
                        'transition': 'all ' + duration / 1000 + 's'
                    });
                }, 100);
            } else {
                target.stop().animate({
                    'opacity': 1
                }, duration);
            }
        },

        _fadeOutBackground: function (target) {
            var duration = this.settings.swapBackgroundDuration;

            if (SwapBackgroundHelper.checkCSSTransitions() === true) {
                // remove the transition property and make the image invisible after the animation completes
                target.off(SwapBackgroundHelper.cssTransitionEndEvents).on(SwapBackgroundHelper.cssTransitionEndEvents, function (event) {
                    if (event.target !== event.currentTarget) {
                        return;
                    }

                    target.off(SwapBackgroundHelper.cssTransitionEndEvents);
                    target.css({
                        'visibility': 'hidden',
                        'transition': ''
                    });
                });

                setTimeout(function () {
                    target.css({
                        'opacity': 0,
                        'transition': 'all ' + duration / 1000 + 's'
                    });
                }, 100);
            } else {
                target.stop().animate({
                    'opacity': 0
                }, duration, function () {
                    target.css({
                        'visibility': 'hidden'
                    });
                });
            }
        },

        destroySwapBackground: function () {
            this.off('panelOpen.SwapBackground.' + NS);
            this.off('panelsClose.SwapBackground.' + NS);
        },

        swapBackgroundDefaults: {
            swapBackgroundDuration: 700,
            fadeOutBackground: false
        }
    };

    $.AccordionSlider.addModule('SwapBackground', SwapBackground, 'accordion');

})(window, jQuery);

/*
	TouchSwipe module for Accordion Slider

	Adds touch swipe support for scrolling through pages
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace;

    var TouchSwipe = {

        touchStartPoint: {
            x: 0,
            y: 0
        },

        touchEndPoint: {
            x: 0,
            y: 0
        },

        touchDistance: {
            x: 0,
            y: 0
        },

        touchStartPosition: 0,

        isTouchMoving: false,

        touchSwipeEvents: {
            startEvent: '',
            moveEvent: '',
            endEvent: ''
        },

        initTouchSwipe: function () {
            var that = this;

            // check if touch swipe is enabled
            if (this.settings.touchSwipe === false)
                return;

            this.touchSwipeEvents.startEvent = 'touchstart' + '.' + NS + ' mousedown' + '.' + NS;
            this.touchSwipeEvents.moveEvent = 'touchmove' + '.' + NS + ' mousemove' + '.' + NS;
            this.touchSwipeEvents.endEvent = 'touchend' + '.' + this.uniqueId + '.' + NS + ' mouseup' + '.' + this.uniqueId + '.' + NS;

            this.$panelsContainer.on(this.touchSwipeEvents.startEvent, $.proxy(this._onTouchStart, this));

            this.on('update.TouchSwipe.' + NS, function () {
                // add or remove grabbing icon
                if (that.getTotalPages() > 1)
                    that.$panelsContainer.addClass('as-grab');
                else
                    that.$panelsContainer.removeClass('as-grab');
            });
        },

        _onTouchStart: function (event) {
            var that = this,
                eventObject = typeof event.originalEvent.touches !== 'undefined' ? event.originalEvent.touches[0] : event.originalEvent;

            // disable dragging if the element is set to allow selections
            if ($(event.target).closest('.as-selectable').length >= 1 || (typeof event.originalEvent.touches === 'undefined' && this.getTotalPages() === 1))
                return;

            // prevent default behavior only for mouse events
            if (typeof event.originalEvent.touches === 'undefined')
                event.preventDefault();

            // get the initial position of the mouse pointer and the initial position of the panels' container
            this.touchStartPoint.x = eventObject.pageX || eventObject.clientX;
            this.touchStartPoint.y = eventObject.pageY || eventObject.clientY;
            this.touchStartPosition = parseInt(this.$panelsContainer.css(this.positionProperty), 10);

            // clear the distance
            this.touchDistance.x = this.touchDistance.y = 0;

            // listen for move and end events
            this.$panelsContainer.on(this.touchSwipeEvents.moveEvent, $.proxy(this._onTouchMove, this));
            $(document).on(this.touchSwipeEvents.endEvent, $.proxy(this._onTouchEnd, this));

            // swap grabbing icons
            this.$panelsContainer.removeClass('as-grab').addClass('as-grabbing');

            // disable links (mostly needed for mobile devices)
            $(event.target).parents('.as-panel').find('a').one('click.TouchSwipe', function (event) {
                event.preventDefault();
            });

            this.$accordion.addClass('as-swiping');
        },

        _onTouchMove: function (event) {
            var eventObject = typeof event.originalEvent.touches !== 'undefined' ? event.originalEvent.touches[0] : event.originalEvent;

            // indicate that the move event is being fired
            this.isTouchMoving = true;

            // get the current position of the mouse pointer
            this.touchEndPoint.x = eventObject.pageX || eventObject.clientX;
            this.touchEndPoint.y = eventObject.pageY || eventObject.clientY;

            // calculate the distance of the movement on both axis
            this.touchDistance.x = this.touchEndPoint.x - this.touchStartPoint.x;
            this.touchDistance.y = this.touchEndPoint.y - this.touchStartPoint.y;

            var distance = this.settings.orientation === 'horizontal' ? this.touchDistance.x : this.touchDistance.y,
                oppositeDistance = this.settings.orientation === 'horizontal' ? this.touchDistance.y : this.touchDistance.x;

            if (Math.abs(distance) > Math.abs(oppositeDistance))
                event.preventDefault();
            else
                return;

            // get the current position of panels' container
            var currentPanelsPosition = parseInt(this.$panelsContainer.css(this.positionProperty), 10);

            // reduce the movement speed if the panels' container is outside its bounds
            if ((currentPanelsPosition >= 0 && this.currentPage === 0) || (currentPanelsPosition <= -this.totalPanelsSize + this.totalSize && this.currentPage === this.getTotalPages() - 1))
                distance = distance * 0.2;

            // move the panels' container
            this.$panelsContainer.css(this.positionProperty, this.touchStartPosition + distance);
        },

        _onTouchEnd: function (event) {
            // remove the move and end listeners
            var that = this;

            this.$panelsContainer.off(this.touchSwipeEvents.moveEvent);
            $(document).off(this.touchSwipeEvents.endEvent);

            // swap grabbing icons
            this.$panelsContainer.removeClass('as-grabbing').addClass('as-grab');

            // check if there is intention for a tap
            if (typeof event.originalEvent.touches !== 'undefined' && (this.isTouchMoving === false || this.isTouchMoving === true && Math.abs(this.touchDistance.x) < 10 && Math.abs(this.touchDistance.y) < 10)) {
                var index = $(event.target).parents('.as-panel').index();

                if (index !== this.currentIndex && index !== -1) {
                    event.preventDefault();
                    this.openPanel(index);
                } else {
                    // re-enable click events on links
                    $(event.target).parents('.as-panel').find('a').off('click.TouchSwipe');
                    this.$accordion.removeClass('as-swiping');
                }

                return;
            }

            // return if there was no movement and re-enable click events on links
            if (this.isTouchMoving === false) {
                $(event.target).parents('.as-panel').find('a').off('click.TouchSwipe');
                this.$accordion.removeClass('as-swiping');
                return;
            }

            $(event.target).parents('.as-panel').one('click', function (event) {
                event.preventDefault();
            });

            this.isTouchMoving = false;

            // remove the 'as-swiping' class but with a delay
            // because there might be other event listeners that check
            // the existence of this class, and this class should still be 
            // applied for those listeners, since there was a swipe event
            setTimeout(function () {
                that.$accordion.removeClass('as-swiping');
            }, 1);

            var noScrollAnimObj = {};
            noScrollAnimObj[this.positionProperty] = this.touchStartPosition;

            // set the accordion's page based on the distance of the movement and the accordion's settings
            if (this.settings.orientation === 'horizontal') {
                if (this.touchDistance.x > this.settings.touchSwipeThreshold) {
                    if (this.currentPage > 0) {
                        this.previousPage();
                    } else {
                        this.$panelsContainer.stop().animate(noScrollAnimObj, 300);
                    }
                } else if (-this.touchDistance.x > this.settings.touchSwipeThreshold) {
                    if (this.currentPage < this.getTotalPages() - 1) {
                        this.nextPage();
                    } else {
                        this.gotoPage(this.currentPage);
                    }
                } else if (Math.abs(this.touchDistance.x) < this.settings.touchSwipeThreshold) {
                    this.$panelsContainer.stop().animate(noScrollAnimObj, 300);
                }
            } else if (this.settings.orientation === 'vertical') {
                if (this.touchDistance.y > this.settings.touchSwipeThreshold) {
                    if (this.currentPage > 0) {
                        this.previousPage();
                    } else {
                        this.$panelsContainer.stop().animate(noScrollAnimObj, 300);
                    }
                } else if (-this.touchDistance.y > this.settings.touchSwipeThreshold) {
                    if (this.currentPage < this.getTotalPages() - 1) {
                        this.nextPage();
                    } else {
                        this.$panelsContainer.animate(noScrollAnimObj, 300);
                    }
                } else if (Math.abs(this.touchDistance.y) < this.settings.touchSwipeThreshold) {
                    this.$panelsContainer.stop().animate(noScrollAnimObj, 300);
                }
            }
        },

        destroyTouchSwipe: function () {
            this.$panelsContainer.off(this.touchSwipeEvents.startEvent);
            $(document).off(this.touchSwipeEvents.endEvent);
            this.$panelsContainer.off(this.touchSwipeEvents.moveEvent);
            this.off('update.TouchSwipe.' + NS);
        },

        touchSwipeDefaults: {
            touchSwipe: true,
            touchSwipeThreshold: 50
        }
    };

    $.AccordionSlider.addModule('TouchSwipe', TouchSwipe, 'accordion');

})(window, jQuery);

/*
	XML module for Accordion Slider

	Creates the panels based on XML data
*/
;
(function (window, $) {

    "use strict";

    var NS = $.AccordionSlider.namespace,

        // detect the current browser name and version
        userAgent = window.navigator.userAgent.toLowerCase(),
        rmsie = /(msie) ([\w.]+)/,
        browserDetect = rmsie.exec(userAgent) || [],
        browserName = browserDetect[1];

    var XML = {

        XMLDataAttributesMap: {
            'width': 'data-width',
            'height': 'data-height',
            'depth': 'data-depth',
            'position': 'data-position',
            'horizontal': 'data-horizontal',
            'vertical': 'data-vertical',
            'showTransition': 'data-show-transition',
            'showOffset': 'data-show-offset',
            'showDelay': 'data-show-delay',
            'showDuration': 'data-show-duration',
            'showEasing': 'data-show-easing',
            'hideTransition': 'data-hide-transition',
            'hideOffset': 'data-',
            'hideDelay': 'data-hide-delay',
            'hideDuration': 'data-hide-duration',
            'hideEasing': 'data-hide-easing'
        },

        initXML: function () {
            if (this.settings.XMLSource !== null)
                this.updateXML();
        },

        updateXML: function () {
            var that = this;

            // clear existing content and data
            this.removePanels();
            this.$panelsContainer.empty();
            this.off('XMLReady.' + NS);

            // parse the XML data and construct the panels
            this.on('XMLReady.' + NS, function (event) {
                var xmlData = $(event.xmlData);

                // check if lazy loading is enabled
                var lazyLoading = xmlData.find('accordion')[0].attributes.lazyLoading;

                if (typeof lazyLoading !== 'undefined')
                    lazyLoading = lazyLoading.nodeValue;

                // parse the panel node
                xmlData.find('panel').each(function () {
                    var xmlPanel = $(this),
                        xmlBackground = xmlPanel.find('background'),
                        xmlBackgroundRetina = xmlPanel.find('backgroundRetina'),
                        xmlBackgroundLink = xmlPanel.find('backgroundLink'),
                        xmlBackgroundOpened = xmlPanel.find('backgroundOpened'),
                        xmlBackgroundOpenedRetina = xmlPanel.find('backgroundOpenedRetina'),
                        xmlBackgroundOpenedLink = xmlPanel.find('backgroundOpenedLink'),
                        xmlLayer = xmlPanel.find('layer'),
                        backgroundLink,
                        backgroundOpenedLink;

                    // create the panel element
                    var panel = $('<div class="as-panel"></div>').appendTo(that.$panelsContainer);

                    // create the background image and link
                    if (xmlBackgroundLink.length >= 1) {
                        backgroundLink = $('<a href="' + xmlBackgroundLink.text() + '"></a>');

                        $.each(xmlBackgroundLink[0].attributes, function (index, attribute) {
                            backgroundLink.attr(attribute.nodeName, attribute.nodeValue);
                        });

                        backgroundLink.appendTo(panel);
                    }

                    if (xmlBackground.length >= 1) {
                        var background = $('<img class="as-background"/>');

                        if (typeof lazyLoading !== 'undefined')
                            background.attr({
                                'src': lazyLoading,
                                'data-src': xmlBackground.text()
                            });
                        else
                            background.attr({
                                'src': xmlBackground.text()
                            });

                        if (xmlBackgroundRetina.length >= 1)
                            background.attr({
                                'data-retina': xmlBackgroundRetina.text()
                            });

                        $.each(xmlBackground[0].attributes, function (index, attribute) {
                            background.attr(attribute.nodeName, attribute.nodeValue);
                        });

                        background.appendTo(xmlBackgroundLink.length ? backgroundLink : panel);
                    }

                    // create the background image and link for the opened state of the panel
                    if (xmlBackgroundOpenedLink.length >= 1) {
                        backgroundOpenedLink = $('<a href="' + xmlBackgroundOpenedLink.text() + '"></a>');

                        $.each(xmlBackgroundOpenedLink[0].attributes, function (index, attribute) {
                            backgroundOpenedLink.attr(attribute.nodeName, attribute.nodeValue);
                        });

                        backgroundOpenedLink.appendTo(panel);
                    }

                    if (xmlBackgroundOpened.length >= 1) {
                        var backgroundOpened = $('<img class="as-background-opened"/>');

                        if (typeof lazyLoading !== 'undefined')
                            backgroundOpened.attr({
                                'src': lazyLoading,
                                'data-src': xmlBackgroundOpened.text()
                            });
                        else
                            backgroundOpened.attr({
                                'src': xmlBackgroundOpened.text()
                            });

                        if (xmlBackgroundOpenedRetina.length >= 1)
                            backgroundOpened.attr({
                                'data-retina': xmlBackgroundOpenedRetina.text()
                            });

                        $.each(xmlBackgroundOpened[0].attributes, function (index, attribute) {
                            backgroundOpened.attr(attribute.nodeName, attribute.nodeValue);
                        });

                        backgroundOpened.appendTo(xmlBackgroundOpenedLink.length ? backgroundOpenedLink : panel);
                    }

                    // parse the layer(s)
                    if (xmlLayer.length >= 1)
                        $.each(xmlLayer, function () {
                            var xmlLayerItem = $(this),
                                classes = '',
                                dataAttributes = '',
                                parent = panel;

                            // parse the attributes specified for the layer and extract the classes and data attributes
                            $.each(xmlLayerItem[0].attributes, function (attributeIndex, attribute) {
                                if (attribute.nodeName === 'style') {
                                    var classList = attribute.nodeValue.split(' ');

                                    $.each(classList, function (classIndex, className) {
                                        classes += ' as-' + className;
                                    });
                                } else {
                                    dataAttributes += ' ' + that.XMLDataAttributesMap[attribute.nodeName] + '="' + attribute.nodeValue + '"';
                                }
                            });

                            // create the layer element
                            var layer = $('<div class="as-layer' + classes + '"' + dataAttributes + '"></div>');

                            // check if the layer is a container for other layers and if so
                            // assign it a unique class in order to target it when the child layers
                            // are added
                            if (xmlLayerItem.find('layer').length >= 1) {
                                var id = new Date().valueOf();

                                xmlLayerItem.attr('parentID', id);
                                layer.attr('class', layer.attr('class') + ' ' + id);
                            } else {
                                layer.html(xmlLayerItem.text());
                            }

                            // check if the XML parent element is a layer and 
                            // find the corresponding HTML parent
                            if (xmlLayerItem.parent().is('layer'))
                                parent = panel.find('.' + xmlLayerItem.parent().attr('parentID'));

                            // add the layer to its parent
                            layer.appendTo(parent);
                        });
                });

                that.update();
            });

            // load the XML
            this._loadXML();
        },

        _loadXML: function () {
            var that = this;

            if (this.settings.XMLSource.slice(-4) === '.xml') {
                $.ajax({
                    type: 'GET',
                    url: this.settings.XMLSource,
                    dataType: browserName === 'msie' ? 'text' : 'xml',
                    success: function (result) {
                        var xmlData;

                        if (browserName === 'msie') {
                            xmlData = new ActiveXObject('Microsoft.XMLDOM');
                            xmlData.async = false;
                            xmlData.loadXML(result);
                        } else {
                            xmlData = result;
                        }

                        that.trigger({
                            type: 'XMLReady.' + NS,
                            xmlData: xmlData
                        });
                    }
                });
            } else {
                var xmlData = $.parseXML(this.settings.XMLSource);
                that.trigger({
                    type: 'XMLReady.' + NS,
                    xmlData: xmlData
                });
            }
        },

        destroyXML: function () {
            this.off('XMLReady.' + NS);
        },

        XMLDefaults: {
            XMLSource: null
        }
    };

    $.AccordionSlider.addModule('XML', XML, 'accordion');

})(window, jQuery);
! function (t, n, i, s) {
    var e = function (s, e) {
        this.elem = s, this.$elem = t(s), this.options = e, this.metadata = this.$elem.data("plugin-options"), this.$win = t(n), this.sections = {}, this.didScroll = !1, this.$doc = t(i), this.docHeight = this.$doc.height()
    };
    e.prototype = {
        defaults: {
            navItems: "a",
            currentClass: "current",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 750,
            scrollThreshold: .5,
            begin: !1,
            end: !1,
            scrollChange: !1
        },
        init: function () {
            return this.config = t.extend({}, this.defaults, this.options, this.metadata), this.$nav = this.$elem.find(this.config.navItems), "" !== this.config.filter && (this.$nav = this.$nav.filter(this.config.filter)), this.$nav.on("click.onePageNav", t.proxy(this.handleClick, this)), this.getPositions(), this.bindInterval(), this.$win.on("resize.onePageNav", t.proxy(this.getPositions, this)), this
        },
        adjustNav: function (t, n) {
            t.$elem.find("." + t.config.currentClass).removeClass(t.config.currentClass), n.addClass(t.config.currentClass)
        },
        bindInterval: function () {
            var t, n = this;
            n.$win.on("scroll.onePageNav", function () {
                n.didScroll = !0
            }), n.t = setInterval(function () {
                t = n.$doc.height(), n.didScroll && (n.didScroll = !1, n.scrollChange()), t !== n.docHeight && (n.docHeight = t, n.getPositions())
            }, 250)
        },
        getHash: function (t) {
            return t.attr("href").split("#")[1]
        },
        getPositions: function () {
            var n, i, s, e = this;
            e.$nav.each(function () {
                n = e.getHash(t(this)), s = t("#" + n), s.length && (i = s.offset().top, e.sections[n] = Math.round(i))
            })
        },
        getSection: function (t) {
            var n = null,
                i = Math.round(this.$win.height() * this.config.scrollThreshold);
            for (var s in this.sections) this.sections[s] - i < t && (n = s);
            return n
        },
        handleClick: function (i) {
            var s = this,
                e = t(i.currentTarget),
                o = e.parent(),
                a = "#" + s.getHash(e);
            o.hasClass(s.config.currentClass) || (s.config.begin && s.config.begin(), s.adjustNav(s, o), s.unbindInterval(), s.scrollTo(a, function () {
                s.config.changeHash && (n.location.hash = a), s.bindInterval(), s.config.end && s.config.end()
            })), i.preventDefault()
        },
        scrollChange: function () {
            var t, n = this.$win.scrollTop(),
                i = this.getSection(n);
            null !== i && (t = this.$elem.find('a[href$="#' + i + '"]').parent(), t.hasClass(this.config.currentClass) || (this.adjustNav(this, t), this.config.scrollChange && this.config.scrollChange(t)))
        },
        scrollTo: function (n, i) {
            var s = t(n).offset().top;
            t("html, body").animate({
                scrollTop: s
            }, this.config.scrollSpeed, this.config.easing, i)
        },
        unbindInterval: function () {
            clearInterval(this.t), this.$win.unbind("scroll.onePageNav")
        }
    }, e.defaults = e.prototype.defaults, t.fn.onePageNav = function (t) {
        return this.each(function () {
            new e(this, t).init()
        })
    }
}(jQuery, window, document);
$(document).ready(function () {
    var switched = false;
    var updateTables = function () {
        if (($(window).width() < 767) && !switched) {
            switched = true;
            $("table.responsive").each(function (i, element) {
                splitTable($(element));
            });
            return true;
        } else if (switched && ($(window).width() > 767)) {
            switched = false;
            $("table.responsive").each(function (i, element) {
                unsplitTable($(element));
            });
        }
    };

    $(window).load(updateTables);
    $(window).on("redraw", function () {
        switched = false;
        updateTables();
    }); // An event to listen for
    $(window).on("resize", updateTables);


    function splitTable(original) {
        original.wrap("<div class='table-wrapper' />");

        var copy = original.clone();
        copy.find("td:not(:first-child), th:not(:first-child)").css("display", "none");
        copy.removeClass("responsive");

        original.closest(".table-wrapper").append(copy);
        copy.wrap("<div class='pinned' />");
        original.wrap("<div class='scrollable' />");

        setCellHeights(original, copy);
    }

    function unsplitTable(original) {
        original.closest(".table-wrapper").find(".pinned").remove();
        original.unwrap();
        original.unwrap();
    }

    function setCellHeights(original, copy) {
        var tr = original.find('tr'),
            tr_copy = copy.find('tr'),
            heights = [];

        tr.each(function (index) {
            var self = $(this),
                tx = self.find('th, td');

            tx.each(function () {
                var height = $(this).outerHeight(true);
                heights[index] = heights[index] || 0;
                if (height > heights[index]) heights[index] = height;
            });

        });

        tr_copy.each(function (index) {
            $(this).height(heights[index]);
        });
    }

});

/** Abstract base class for collection plugins v1.0.1.
	Written by Keith Wood (kbwood{at}iinet.com.au) December 2013.
	Licensed under the MIT (http://keith-wood.name/licence.html) license. */
(function () {
    var j = false;
    window.JQClass = function () {};
    JQClass.classes = {};
    JQClass.extend = function extender(f) {
        var g = this.prototype;
        j = true;
        var h = new this();
        j = false;
        for (var i in f) {
            h[i] = typeof f[i] == 'function' && typeof g[i] == 'function' ? (function (d, e) {
                return function () {
                    var b = this._super;
                    this._super = function (a) {
                        return g[d].apply(this, a || [])
                    };
                    var c = e.apply(this, arguments);
                    this._super = b;
                    return c
                }
            })(i, f[i]) : f[i]
        }

        function JQClass() {
            if (!j && this._init) {
                this._init.apply(this, arguments)
            }
        }
        JQClass.prototype = h;
        JQClass.prototype.constructor = JQClass;
        JQClass.extend = extender;
        return JQClass
    }
})();
(function ($) {
    JQClass.classes.JQPlugin = JQClass.extend({
        name: 'plugin',
        defaultOptions: {},
        regionalOptions: {},
        _getters: [],
        _getMarker: function () {
            return 'is-' + this.name
        },
        _init: function () {
            $.extend(this.defaultOptions, (this.regionalOptions && this.regionalOptions['']) || {});
            var c = camelCase(this.name);
            $[c] = this;
            $.fn[c] = function (a) {
                var b = Array.prototype.slice.call(arguments, 1);
                if ($[c]._isNotChained(a, b)) {
                    return $[c][a].apply($[c], [this[0]].concat(b))
                }
                return this.each(function () {
                    if (typeof a === 'string') {
                        if (a[0] === '_' || !$[c][a]) {
                            throw 'Unknown method: ' + a;
                        }
                        $[c][a].apply($[c], [this].concat(b))
                    } else {
                        $[c]._attach(this, a)
                    }
                })
            }
        },
        setDefaults: function (a) {
            $.extend(this.defaultOptions, a || {})
        },
        _isNotChained: function (a, b) {
            if (a === 'option' && (b.length === 0 || (b.length === 1 && typeof b[0] === 'string'))) {
                return true
            }
            return $.inArray(a, this._getters) > -1
        },
        _attach: function (a, b) {
            a = $(a);
            if (a.hasClass(this._getMarker())) {
                return
            }
            a.addClass(this._getMarker());
            b = $.extend({}, this.defaultOptions, this._getMetadata(a), b || {});
            var c = $.extend({
                name: this.name,
                elem: a,
                options: b
            }, this._instSettings(a, b));
            a.data(this.name, c);
            this._postAttach(a, c);
            this.option(a, b)
        },
        _instSettings: function (a, b) {
            return {}
        },
        _postAttach: function (a, b) {},
        _getMetadata: function (d) {
            try {
                var f = d.data(this.name.toLowerCase()) || '';
                f = f.replace(/'/g, '"');
                f = f.replace(/([a-zA-Z0-9]+):/g, function (a, b, i) {
                    var c = f.substring(0, i).match(/"/g);
                    return (!c || c.length % 2 === 0 ? '"' + b + '":' : b + ':')
                });
                f = $.parseJSON('{' + f + '}');
                for (var g in f) {
                    var h = f[g];
                    if (typeof h === 'string' && h.match(/^new Date\((.*)\)$/)) {
                        f[g] = eval(h)
                    }
                }
                return f
            } catch (e) {
                return {}
            }
        },
        _getInst: function (a) {
            return $(a).data(this.name) || {}
        },
        option: function (a, b, c) {
            a = $(a);
            var d = a.data(this.name);
            if (!b || (typeof b === 'string' && c == null)) {
                var e = (d || {}).options;
                return (e && b ? e[b] : e)
            }
            if (!a.hasClass(this._getMarker())) {
                return
            }
            var e = b || {};
            if (typeof b === 'string') {
                e = {};
                e[b] = c
            }
            this._optionsChanged(a, d, e);
            $.extend(d.options, e)
        },
        _optionsChanged: function (a, b, c) {},
        destroy: function (a) {
            a = $(a);
            if (!a.hasClass(this._getMarker())) {
                return
            }
            this._preDestroy(a, this._getInst(a));
            a.removeData(this.name).removeClass(this._getMarker())
        },
        _preDestroy: function (a, b) {}
    });

    function camelCase(c) {
        return c.replace(/-([a-z])/g, function (a, b) {
            return b.toUpperCase()
        })
    }
    $.JQPlugin = {
        createPlugin: function (a, b) {
            if (typeof a === 'object') {
                b = a;
                a = 'JQPlugin'
            }
            a = camelCase(a);
            var c = camelCase(b.name);
            JQClass.classes[c] = JQClass.classes[a].extend(b);
            new JQClass.classes[c]()
        }
    }
})(jQuery);

/** http://keith-wood.name/datepick.html
   Date picker for jQuery v5.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) February 2010.
   Licensed under the MIT (http://keith-wood.name/licence.html) licence. 
   Please attribute the author if you use it. */
(function ($) {
    var E = 'datepick';
    $.JQPlugin.createPlugin({
        name: E,
        defaultRenderer: {
            picker: '<div class="datepick">' + '<div class="datepick-nav">{link:prev}{link:today}{link:next}</div>{months}' + '{popup:start}<div class="datepick-ctrl">{link:clear}{link:close}</div>{popup:end}' + '<div class="datepick-clear-fix"></div></div>',
            monthRow: '<div class="datepick-month-row">{months}</div>',
            month: '<div class="datepick-month"><div class="datepick-month-header">{monthHeader}</div>' + '<table><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
            weekHeader: '<tr>{days}</tr>',
            dayHeader: '<th>{day}</th>',
            week: '<tr>{days}</tr>',
            day: '<td>{day}</td>',
            monthSelector: '.datepick-month',
            daySelector: 'td',
            rtlClass: 'datepick-rtl',
            multiClass: 'datepick-multi',
            defaultClass: '',
            selectedClass: 'datepick-selected',
            highlightedClass: 'datepick-highlight',
            todayClass: 'datepick-today',
            otherMonthClass: 'datepick-other-month',
            weekendClass: 'datepick-weekend',
            commandClass: 'datepick-cmd',
            commandButtonClass: '',
            commandLinkClass: '',
            disabledClass: 'datepick-disabled'
        },
        commands: {
            prev: {
                text: 'prevText',
                status: 'prevStatus',
                keystroke: {
                    keyCode: 33
                },
                enabled: function (a) {
                    var b = a.curMinDate();
                    return (!b || F.add(F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), 1 - a.options.monthsToStep, 'm'), a), 1), -1, 'd').getTime() >= b.getTime())
                },
                date: function (a) {
                    return F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), -a.options.monthsToStep, 'm'), a), 1)
                },
                action: function (a) {
                    F.changeMonth(this, -a.options.monthsToStep)
                }
            },
            prevJump: {
                text: 'prevJumpText',
                status: 'prevJumpStatus',
                keystroke: {
                    keyCode: 33,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.curMinDate();
                    return (!b || F.add(F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), 1 - a.options.monthsToJump, 'm'), a), 1), -1, 'd').getTime() >= b.getTime())
                },
                date: function (a) {
                    return F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), -a.options.monthsToJump, 'm'), a), 1)
                },
                action: function (a) {
                    F.changeMonth(this, -a.options.monthsToJump)
                }
            },
            next: {
                text: 'nextText',
                status: 'nextStatus',
                keystroke: {
                    keyCode: 34
                },
                enabled: function (a) {
                    var b = a.get('maxDate');
                    return (!b || F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), a.options.monthsToStep, 'm'), a), 1).getTime() <= b.getTime())
                },
                date: function (a) {
                    return F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), a.options.monthsToStep, 'm'), a), 1)
                },
                action: function (a) {
                    F.changeMonth(this, a.options.monthsToStep)
                }
            },
            nextJump: {
                text: 'nextJumpText',
                status: 'nextJumpStatus',
                keystroke: {
                    keyCode: 34,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.get('maxDate');
                    return (!b || F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), a.options.monthsToJump, 'm'), a), 1).getTime() <= b.getTime())
                },
                date: function (a) {
                    return F.day(F._applyMonthsOffset(F.add(F.newDate(a.drawDate), a.options.monthsToJump, 'm'), a), 1)
                },
                action: function (a) {
                    F.changeMonth(this, a.options.monthsToJump)
                }
            },
            current: {
                text: 'currentText',
                status: 'currentStatus',
                keystroke: {
                    keyCode: 36,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.curMinDate();
                    var c = a.get('maxDate');
                    var d = a.selectedDates[0] || F.today();
                    return (!b || d.getTime() >= b.getTime()) && (!c || d.getTime() <= c.getTime())
                },
                date: function (a) {
                    return a.selectedDates[0] || F.today()
                },
                action: function (a) {
                    var b = a.selectedDates[0] || F.today();
                    F.showMonth(this, b.getFullYear(), b.getMonth() + 1)
                }
            },
            today: {
                text: 'todayText',
                status: 'todayStatus',
                keystroke: {
                    keyCode: 36,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.curMinDate();
                    var c = a.get('maxDate');
                    return (!b || F.today().getTime() >= b.getTime()) && (!c || F.today().getTime() <= c.getTime())
                },
                date: function (a) {
                    return F.today()
                },
                action: function (a) {
                    F.showMonth(this)
                }
            },
            clear: {
                text: 'clearText',
                status: 'clearStatus',
                keystroke: {
                    keyCode: 35,
                    ctrlKey: true
                },
                enabled: function (a) {
                    return true
                },
                date: function (a) {
                    return null
                },
                action: function (a) {
                    F.clear(this)
                }
            },
            close: {
                text: 'closeText',
                status: 'closeStatus',
                keystroke: {
                    keyCode: 27
                },
                enabled: function (a) {
                    return true
                },
                date: function (a) {
                    return null
                },
                action: function (a) {
                    F.hide(this)
                }
            },
            prevWeek: {
                text: 'prevWeekText',
                status: 'prevWeekStatus',
                keystroke: {
                    keyCode: 38,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.curMinDate();
                    return (!b || F.add(F.newDate(a.drawDate), -7, 'd').getTime() >= b.getTime())
                },
                date: function (a) {
                    return F.add(F.newDate(a.drawDate), -7, 'd')
                },
                action: function (a) {
                    F.changeDay(this, -7)
                }
            },
            prevDay: {
                text: 'prevDayText',
                status: 'prevDayStatus',
                keystroke: {
                    keyCode: 37,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.curMinDate();
                    return (!b || F.add(F.newDate(a.drawDate), -1, 'd').getTime() >= b.getTime())
                },
                date: function (a) {
                    return F.add(F.newDate(a.drawDate), -1, 'd')
                },
                action: function (a) {
                    F.changeDay(this, -1)
                }
            },
            nextDay: {
                text: 'nextDayText',
                status: 'nextDayStatus',
                keystroke: {
                    keyCode: 39,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.get('maxDate');
                    return (!b || F.add(F.newDate(a.drawDate), 1, 'd').getTime() <= b.getTime())
                },
                date: function (a) {
                    return F.add(F.newDate(a.drawDate), 1, 'd')
                },
                action: function (a) {
                    F.changeDay(this, 1)
                }
            },
            nextWeek: {
                text: 'nextWeekText',
                status: 'nextWeekStatus',
                keystroke: {
                    keyCode: 40,
                    ctrlKey: true
                },
                enabled: function (a) {
                    var b = a.get('maxDate');
                    return (!b || F.add(F.newDate(a.drawDate), 7, 'd').getTime() <= b.getTime())
                },
                date: function (a) {
                    return F.add(F.newDate(a.drawDate), 7, 'd')
                },
                action: function (a) {
                    F.changeDay(this, 7)
                }
            }
        },
        defaultOptions: {
            pickerClass: '',
            showOnFocus: true,
            showTrigger: null,
            showAnim: 'show',
            showOptions: {},
            showSpeed: 'normal',
            popupContainer: null,
            alignment: 'bottom',
            fixedWeeks: false,
            firstDay: 0,
            calculateWeek: null,
            monthsToShow: 1,
            monthsOffset: 0,
            monthsToStep: 1,
            monthsToJump: 12,
            useMouseWheel: true,
            changeMonth: true,
            yearRange: 'c-10:c+10',
            shortYearCutoff: '+10',
            showOtherMonths: false,
            selectOtherMonths: false,
            defaultDate: null,
            selectDefaultDate: false,
            minDate: null,
            maxDate: null,
            dateFormat: 'mm/dd/yyyy',
            autoSize: false,
            rangeSelect: false,
            rangeSeparator: ' - ',
            multiSelect: 0,
            multiSeparator: ',',
            onDate: null,
            onShow: null,
            onChangeMonthYear: null,
            onSelect: null,
            onClose: null,
            altField: null,
            altFormat: null,
            constrainInput: true,
            commandsAsDateFormat: false,
            commands: {}
        },
        regionalOptions: {
            '': {
                monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
                dateFormat: 'mm/dd/yyyy',
                firstDay: 0,
                renderer: {},
                prevText: '&lt;Prev',
                prevStatus: 'Show the previous month',
                prevJumpText: '&lt;&lt;',
                prevJumpStatus: 'Show the previous year',
                nextText: 'Next&gt;',
                nextStatus: 'Show the next month',
                nextJumpText: '&gt;&gt;',
                nextJumpStatus: 'Show the next year',
                currentText: 'Current',
                currentStatus: 'Show the current month',
                todayText: 'Today',
                todayStatus: 'Show today\'s month',
                clearText: 'Clear',
                clearStatus: 'Clear all the dates',
                closeText: 'Close',
                closeStatus: 'Close the datepicker',
                yearStatus: 'Change the year',
                earlierText: '&#160;&#160;▲',
                laterText: '&#160;&#160;▼',
                monthStatus: 'Change the month',
                weekText: 'Wk',
                weekStatus: 'Week of the year',
                dayStatus: 'Select DD, M d, yyyy',
                defaultStatus: 'Select a date',
                isRTL: false
            }
        },
        _getters: ['getDate', 'isDisabled', 'isSelectable', 'retrieveDate'],
        _disabled: [],
        _popupClass: E + '-popup',
        _triggerClass: E + '-trigger',
        _disableClass: E + '-disable',
        _monthYearClass: E + '-month-year',
        _curMonthClass: E + '-month-',
        _anyYearClass: E + '-any-year',
        _curDoWClass: E + '-dow-',
        _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
        _msPerDay: 24 * 60 * 60 * 1000,
        ATOM: 'yyyy-mm-dd',
        COOKIE: 'D, dd M yyyy',
        FULL: 'DD, MM d, yyyy',
        ISO_8601: 'yyyy-mm-dd',
        JULIAN: 'J',
        RFC_822: 'D, d M yy',
        RFC_850: 'DD, dd-M-yy',
        RFC_1036: 'D, d M yy',
        RFC_1123: 'D, d M yyyy',
        RFC_2822: 'D, d M yyyy',
        RSS: 'D, d M yy',
        TICKS: '!',
        TIMESTAMP: '@',
        W3C: 'yyyy-mm-dd',
        formatDate: function (f, g, h) {
            if (typeof f !== 'string') {
                h = g;
                g = f;
                f = ''
            }
            if (!g) {
                return ''
            }
            f = f || this.defaultOptions.dateFormat;
            h = h || {};
            var i = h.dayNamesShort || this.defaultOptions.dayNamesShort;
            var j = h.dayNames || this.defaultOptions.dayNames;
            var k = h.monthNamesShort || this.defaultOptions.monthNamesShort;
            var l = h.monthNames || this.defaultOptions.monthNames;
            var m = h.calculateWeek || this.defaultOptions.calculateWeek;
            var n = function (a, b) {
                var c = 1;
                while (s + c < f.length && f.charAt(s + c) === a) {
                    c++
                }
                s += c - 1;
                return Math.floor(c / (b || 1)) > 1
            };
            var o = function (a, b, c, d) {
                var e = '' + b;
                if (n(a, d)) {
                    while (e.length < c) {
                        e = '0' + e
                    }
                }
                return e
            };
            var p = function (a, b, c, d) {
                return (n(a) ? d[b] : c[b])
            };
            var q = '';
            var r = false;
            for (var s = 0; s < f.length; s++) {
                if (r) {
                    if (f.charAt(s) === "'" && !n("'")) {
                        r = false
                    } else {
                        q += f.charAt(s)
                    }
                } else {
                    switch (f.charAt(s)) {
                        case 'd':
                            q += o('d', g.getDate(), 2);
                            break;
                        case 'D':
                            q += p('D', g.getDay(), i, j);
                            break;
                        case 'o':
                            q += o('o', this.dayOfYear(g), 3);
                            break;
                        case 'w':
                            q += o('w', m(g), 2);
                            break;
                        case 'm':
                            q += o('m', g.getMonth() + 1, 2);
                            break;
                        case 'M':
                            q += p('M', g.getMonth(), k, l);
                            break;
                        case 'y':
                            q += (n('y', 2) ? g.getFullYear() : (g.getFullYear() % 100 < 10 ? '0' : '') + g.getFullYear() % 100);
                            break;
                        case '@':
                            q += Math.floor(g.getTime() / 1000);
                            break;
                        case '!':
                            q += g.getTime() * 10000 + this._ticksTo1970;
                            break;
                        case "'":
                            if (n("'")) {
                                q += "'"
                            } else {
                                r = true
                            }
                            break;
                        default:
                            q += f.charAt(s)
                    }
                }
            }
            return q
        },
        parseDate: function (g, h, j) {
            if (h == null) {
                throw 'Invalid arguments';
            }
            h = (typeof h === 'object' ? h.toString() : h + '');
            if (h === '') {
                return null
            }
            g = g || this.defaultOptions.dateFormat;
            j = j || {};
            var k = j.shortYearCutoff || this.defaultOptions.shortYearCutoff;
            k = (typeof k !== 'string' ? k : this.today().getFullYear() % 100 + parseInt(k, 10));
            var l = j.dayNamesShort || this.defaultOptions.dayNamesShort;
            var m = j.dayNames || this.defaultOptions.dayNames;
            var n = j.monthNamesShort || this.defaultOptions.monthNamesShort;
            var o = j.monthNames || this.defaultOptions.monthNames;
            var p = -1;
            var q = -1;
            var r = -1;
            var s = -1;
            var t = false;
            var u = false;
            var v = function (a, b) {
                var c = 1;
                while (A + c < g.length && g.charAt(A + c) === a) {
                    c++
                }
                A += c - 1;
                return Math.floor(c / (b || 1)) > 1
            };
            var w = function (a, b) {
                var c = v(a, b);
                var d = [2, 3, c ? 4 : 2, 11, 20]['oy@!'.indexOf(a) + 1];
                var e = new RegExp('^-?\\d{1,' + d + '}');
                var f = h.substring(z).match(e);
                if (!f) {
                    throw 'Missing number at position {0}'.replace(/\{0\}/, z);
                }
                z += f[0].length;
                return parseInt(f[0], 10);
            };
            var x = function (a, b, c, d) {
                var e = (v(a, d) ? c : b);
                for (var i = 0; i < e.length; i++) {
                    if (h.substr(z, e[i].length).toLowerCase() === e[i].toLowerCase()) {
                        z += e[i].length;
                        return i + 1;
                    }
                }
                throw 'Unknown name at position {0}'.replace(/\{0\}/, z);
            };
            var y = function () {
                if (h.charAt(z) !== g.charAt(A)) {
                    throw 'Unexpected literal at position {0}'.replace(/\{0\}/, z);
                }
                z++;
            };
            var z = 0;
            for (var A = 0; A < g.length; A++) {
                if (u) {
                    if (g.charAt(A) === "'" && !v("'")) {
                        u = false;
                    } else {
                        y();
                    }
                } else {
                    switch (g.charAt(A)) {
                        case 'd':
                            r = w('d');
                            break;
                        case 'D':
                            x('D', l, m);
                            break;
                        case 'o':
                            s = w('o');
                            break;
                        case 'w':
                            w('w');
                            break;
                        case 'm':
                            q = w('m');
                            break;
                        case 'M':
                            q = x('M', n, o);
                            break;
                        case 'y':
                            var B = A;
                            t = !v('y', 2);
                            A = B;
                            p = w('y', 2);
                            break;
                        case '@':
                            var C = this._normaliseDate(new Date(w('@') * 1000));
                            p = C.getFullYear();
                            q = C.getMonth() + 1;
                            r = C.getDate();
                            break;
                        case '!':
                            var C = this._normaliseDate(new Date((w('!') - this._ticksTo1970) / 10000));
                            p = C.getFullYear();
                            q = C.getMonth() + 1;
                            r = C.getDate();
                            break;
                        case '*':
                            z = h.length;
                            break;
                        case "'":
                            if (v("'")) {
                                y();
                            } else {
                                u = true;
                            }
                            break;
                        default:
                            y();
                    }
                }
            }
            if (z < h.length) {
                throw 'Additional text found at end';
            }
            if (p === -1) {
                p = this.today().getFullYear();
            } else if (p < 100 && t) {
                p += (k === -1 ? 1900 : this.today().getFullYear() - this.today().getFullYear() % 100 - (p <= k ? 0 : 100));
            }
            if (s > -1) {
                q = 1;
                r = s;
                for (var D = this.daysInMonth(p, q); r > D; D = this.daysInMonth(p, q)) {
                    q++;
                    r -= D;
                }
            }
            var C = this.newDate(p, q, r);
            if (C.getFullYear() !== p || C.getMonth() + 1 !== q || C.getDate() !== r) {
                throw 'Invalid date';
            }
            return C;
        },
        determineDate: function (f, g, h, i, j) {
            if (h && typeof h !== 'object') {
                j = i;
                i = h;
                h = null;
            }
            if (typeof i !== 'string') {
                j = i;
                i = '';
            }
            var k = function (a) {
                try {
                    return F.parseDate(i, a, j);
                } catch (e) {}
                a = a.toLowerCase();
                var b = (a.match(/^c/) && h ? F.newDate(h) : null) || F.today();
                var c = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
                var d = null;
                while (d = c.exec(a)) {
                    b = F.add(b, parseInt(d[1], 10), d[2] || 'd');
                }
                return b;
            };
            g = (g ? F.newDate(g) : null);
            f = (f == null ? g : (typeof f === 'string' ? k(f) : (typeof f === 'number' ? (isNaN(f) || f === Infinity || f === -Infinity ? g : F.add(F.today(), f, 'd')) : F.newDate(f))));
            return f;
        },
        daysInMonth: function (a, b) {
            b = (a.getFullYear ? a.getMonth() + 1 : b);
            a = (a.getFullYear ? a.getFullYear() : a);
            return this.newDate(a, b + 1, 0).getDate();
        },
        dayOfYear: function (a, b, c) {
            var d = (a.getFullYear ? a : F.newDate(a, b, c));
            var e = F.newDate(d.getFullYear(), 1, 1);
            return Math.floor((d.getTime() - e.getTime()) / F._msPerDay) + 1;
        },
        iso8601Week: function (a, b, c) {
            var d = (a.getFullYear ? new Date(a.getTime()) : F.newDate(a, b, c));
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            var e = d.getTime();
            d.setMonth(0, 1);
            return Math.floor(Math.round((e - d) / F._msPerDay) / 7) + 1;
        },
        today: function () {
            return this._normaliseDate(new Date());
        },
        newDate: function (a, b, c) {
            return (!a ? null : (a.getFullYear ? this._normaliseDate(new Date(a.getTime())) : new Date(a, b - 1, c, 12)));
        },
        _normaliseDate: function (a) {
            if (a) {
                a.setHours(12, 0, 0, 0);
            }
            return a;
        },
        year: function (a, b) {
            a.setFullYear(b);
            return this._normaliseDate(a);
        },
        month: function (a, b) {
            a.setMonth(b - 1);
            return this._normaliseDate(a);
        },
        day: function (a, b) {
            a.setDate(b);
            return this._normaliseDate(a);
        },
        add: function (a, b, c) {
            if (c === 'd' || c === 'w') {
                this._normaliseDate(a);
                a.setDate(a.getDate() + b * (c === 'w' ? 7 : 1));
            } else {
                var d = a.getFullYear() + (c === 'y' ? b : 0);
                var e = a.getMonth() + (c === 'm' ? b : 0);
                a.setTime(F.newDate(d, e + 1, Math.min(a.getDate(), this.daysInMonth(d, e + 1))).getTime());
            }
            return a;
        },
        _applyMonthsOffset: function (a, b) {
            var c = b.options.monthsOffset;
            if ($.isFunction(c)) {
                c = c.apply(b.elem[0], [a]);
            }
            return F.add(a, -c, 'm');
        },
        _init: function () {
            this.defaultOptions.commands = this.commands;
            this.defaultOptions.calculateWeek = this.iso8601Week;
            this.regionalOptions[''].renderer = this.defaultRenderer;
            this._super();
        },
        _instSettings: function (b, c) {
            return {
                selectedDates: [],
                drawDate: null,
                pickingRange: false,
                inline: ($.inArray(b[0].nodeName.toLowerCase(), ['div', 'span']) > -1),
                get: function (a) {
                    if ($.inArray(a, ['defaultDate', 'minDate', 'maxDate']) > -1) {
                        return F.determineDate(this.options[a], null, this.selectedDates[0], this.options.dateFormat, this.getConfig());
                    }
                    return this.options[a];
                },
                curMinDate: function () {
                    return (this.pickingRange ? this.selectedDates[0] : this.get('minDate'));
                },
                getConfig: function () {
                    return {
                        dayNamesShort: this.options.dayNamesShort,
                        dayNames: this.options.dayNames,
                        monthNamesShort: this.options.monthNamesShort,
                        monthNames: this.options.monthNames,
                        calculateWeek: this.options.calculateWeek,
                        shortYearCutoff: this.options.shortYearCutoff
                    };
                }
            };
        },
        _postAttach: function (a, b) {
            if (b.inline) {
                b.drawDate = F._checkMinMax(F.newDate(b.selectedDates[0] || b.get('defaultDate') || F.today()), b);
                b.prevDate = F.newDate(b.drawDate);
                this._update(a[0]);
                if ($.fn.mousewheel) {
                    a.mousewheel(this._doMouseWheel);
                }
            } else {
                this._attachments(a, b);
                a.on('keydown.' + b.name, this._keyDown).on('keypress.' + b.name, this._keyPress).on('keyup.' + b.name, this._keyUp);
                if (a.attr('disabled')) {
                    this.disable(a[0]);
                }
            }
        },
        _optionsChanged: function (b, c, d) {
            if (d.calendar && d.calendar !== c.options.calendar) {
                var e = function (a) {
                    return (typeof c.options[a] === 'object' ? null : c.options[a]);
                };
                d = $.extend({
                    defaultDate: e('defaultDate'),
                    minDate: e('minDate'),
                    maxDate: e('maxDate')
                }, d);
                c.selectedDates = [];
                c.drawDate = null;
            }
            var f = c.selectedDates;
            $.extend(c.options, d);
            this.setDate(b[0], f, null, false, true);
            c.pickingRange = false;
            c.drawDate = F.newDate(this._checkMinMax((c.options.defaultDate ? c.get('defaultDate') : c.drawDate) || c.get('defaultDate') || F.today(), c));
            if (!c.inline) {
                this._attachments(b, c);
            }
            if (c.inline || c.div) {
                this._update(b[0]);
            }
        },
        _attachments: function (a, b) {
            a.off('focus.' + b.name);
            if (b.options.showOnFocus) {
                a.on('focus.' + b.name, this.show);
            }
            if (b.trigger) {
                b.trigger.remove();
            }
            var c = b.options.showTrigger;
            b.trigger = (!c ? $([]) : $(c).clone().removeAttr('id').addClass(this._triggerClass)[b.options.isRTL ? 'insertBefore' : 'insertAfter'](a).click(function () {
                if (!F.isDisabled(a[0])) {
                    F[F.curInst === b ? 'hide' : 'show'](a[0]);
                }
            }));
            this._autoSize(a, b);
            var d = this._extractDates(b, a.val());
            if (d) {
                this.setDate(a[0], d, null, true);
            }
            var e = b.get('defaultDate');
            if (b.options.selectDefaultDate && e && b.selectedDates.length === 0) {
                this.setDate(a[0], F.newDate(e || F.today()));
            }
        },
        _autoSize: function (d, e) {
            if (e.options.autoSize && !e.inline) {
                var f = F.newDate(2009, 10, 20);
                var g = e.options.dateFormat;
                if (g.match(/[DM]/)) {
                    var h = function (a) {
                        var b = 0;
                        var c = 0;
                        for (var i = 0; i < a.length; i++) {
                            if (a[i].length > b) {
                                b = a[i].length;
                                c = i;
                            }
                        }
                        return c;
                    };
                    f.setMonth(h(e.options[g.match(/MM/) ? 'monthNames' : 'monthNamesShort']));
                    f.setDate(h(e.options[g.match(/DD/) ? 'dayNames' : 'dayNamesShort']) + 20 - f.getDay());
                }
                e.elem.attr('size', F.formatDate(g, f, e.getConfig()).length);
            }
        },
        _preDestroy: function (a, b) {
            if (b.trigger) {
                b.trigger.remove();
            }
            a.empty().off('.' + b.name);
            if (b.inline && $.fn.mousewheel) {
                a.unmousewheel();
            }
            if (!b.inline && b.options.autoSize) {
                a.removeAttr('size');
            }
        },
        multipleEvents: function (b) {
            var c = arguments;
            return function (a) {
                for (var i = 0; i < c.length; i++) {
                    c[i].apply(this, arguments);
                }
            };
        },
        enable: function (b) {
            b = $(b);
            if (!b.hasClass(this._getMarker())) {
                return;
            }
            var c = this._getInst(b);
            if (c.inline) {
                b.children('.' + this._disableClass).remove().end().find('button,select').prop('disabled', false).end().find('a').attr('href', 'javascript:void(0)');
            } else {
                b.prop('disabled', false);
                c.trigger.filter('button.' + this._triggerClass).prop('disabled', false).end().filter('img.' + this._triggerClass).css({
                    opacity: '1.0',
                    cursor: ''
                });
            }
            this._disabled = $.map(this._disabled, function (a) {
                return (a === b[0] ? null : a);
            });
        },
        disable: function (b) {
            b = $(b);
            if (!b.hasClass(this._getMarker())) {
                return;
            }
            var c = this._getInst(b);
            if (c.inline) {
                var d = b.children(':last');
                var e = d.offset();
                var f = {
                    left: 0,
                    top: 0
                };
                d.parents().each(function () {
                    if ($(this).css('position') === 'relative') {
                        f = $(this).offset();
                        return false;
                    }
                });
                var g = b.css('zIndex');
                g = (g === 'auto' ? 0 : parseInt(g, 10)) + 1;
                b.prepend('<div class="' + this._disableClass + '" style="' + 'width: ' + d.outerWidth() + 'px; height: ' + d.outerHeight() + 'px; left: ' + (e.left - f.left) + 'px; top: ' + (e.top - f.top) + 'px; z-index: ' + g + '"></div>').find('button,select').prop('disabled', true).end().find('a').removeAttr('href');
            } else {
                b.prop('disabled', true);
                c.trigger.filter('button.' + this._triggerClass).prop('disabled', true).end().filter('img.' + this._triggerClass).css({
                    opacity: '0.5',
                    cursor: 'default'
                });
            }
            this._disabled = $.map(this._disabled, function (a) {
                return (a === b[0] ? null : a);
            });
            this._disabled.push(b[0]);
        },
        isDisabled: function (a) {
            return (a && $.inArray(a, this._disabled) > -1);
        },
        show: function (a) {
            a = $(a.target || a);
            var b = F._getInst(a);
            if (F.curInst === b) {
                return;
            }
            if (F.curInst) {
                F.hide(F.curInst, true);
            }
            if (!$.isEmptyObject(b)) {
                b.lastVal = null;
                b.selectedDates = F._extractDates(b, a.val());
                b.pickingRange = false;
                b.drawDate = F._checkMinMax(F.newDate(b.selectedDates[0] || b.get('defaultDate') || F.today()), b);
                b.prevDate = F.newDate(b.drawDate);
                F.curInst = b;
                F._update(a[0], true);
                var c = F._checkOffset(b);
                b.div.css({
                    left: c.left,
                    top: c.top
                });
                var d = b.options.showAnim;
                var e = b.options.showSpeed;
                e = (e === 'normal' && $.ui && parseInt($.ui.version.substring(2)) >= 8 ? '_default' : e);
                if ($.effects && ($.effects[d] || ($.effects.effect && $.effects.effect[d]))) {
                    var f = b.div.data();
                    for (var g in f) {
                        if (g.match(/^ec\.storage\./)) {
                            f[g] = b._mainDiv.css(g.replace(/ec\.storage\./, ''));
                        }
                    }
                    b.div.data(f).show(d, b.options.showOptions, e);
                } else {
                    b.div[d || 'show'](d ? e : 0);
                }
            }
        },
        _extractDates: function (a, b) {
            if (b === a.lastVal) {
                return;
            }
            a.lastVal = b;
            b = b.split(a.options.multiSelect ? a.options.multiSeparator : (a.options.rangeSelect ? a.options.rangeSeparator : '\x00'));
            var c = [];
            for (var i = 0; i < b.length; i++) {
                try {
                    var d = F.parseDate(a.options.dateFormat, b[i], a.getConfig());
                    if (d) {
                        var f = false;
                        for (var j = 0; j < c.length; j++) {
                            if (c[j].getTime() === d.getTime()) {
                                f = true;
                                break;
                            }
                        }
                        if (!f) {
                            c.push(d);
                        }
                    }
                } catch (e) {}
            }
            c.splice(a.options.multiSelect || (a.options.rangeSelect ? 2 : 1), c.length);
            if (a.options.rangeSelect && c.length === 1) {
                c[1] = c[0];
            }
            return c;
        },
        _update: function (a, b) {
            a = $(a.target || a);
            var c = F._getInst(a);
            if (!$.isEmptyObject(c)) {
                if (c.inline || F.curInst === c) {
                    if ($.isFunction(c.options.onChangeMonthYear) && (!c.prevDate || c.prevDate.getFullYear() !== c.drawDate.getFullYear() || c.prevDate.getMonth() !== c.drawDate.getMonth())) {
                        c.options.onChangeMonthYear.apply(a[0], [c.drawDate.getFullYear(), c.drawDate.getMonth() + 1]);
                    }
                }
                if (c.inline) {
                    var d = $('a, :input', a).index($(':focus', a));
                    a.html(this._generateContent(a[0], c));
                    var e = a.find('a, :input');
                    e.eq(Math.max(Math.min(d, e.length - 1), 0)).focus();
                } else if (F.curInst === c) {
                    if (!c.div) {
                        c.div = $('<div></div>').addClass(this._popupClass).css({
                            display: (b ? 'none' : 'static'),
                            position: 'absolute',
                            left: a.offset().left,
                            top: a.offset().top + a.outerHeight()
                        }).appendTo($(c.options.popupContainer || 'body'));
                        if ($.fn.mousewheel) {
                            c.div.mousewheel(this._doMouseWheel);
                        }
                    }
                    c.div.html(this._generateContent(a[0], c));
                    a.focus();
                }
            }
        },
        _updateInput: function (a, b) {
            var c = this._getInst(a);
            if (!$.isEmptyObject(c)) {
                var d = '';
                var e = '';
                var f = (c.options.multiSelect ? c.options.multiSeparator : c.options.rangeSeparator);
                var g = c.options.altFormat || c.options.dateFormat;
                for (var i = 0; i < c.selectedDates.length; i++) {
                    d += (b ? '' : (i > 0 ? f : '') + F.formatDate(c.options.dateFormat, c.selectedDates[i], c.getConfig()));
                    e += (i > 0 ? f : '') + F.formatDate(g, c.selectedDates[i], c.getConfig());
                }
                if (!c.inline && !b) {
                    $(a).val(d);
                }
                $(c.options.altField).val(e);
                if ($.isFunction(c.options.onSelect) && !b && !c.inSelect) {
                    c.inSelect = true;
                    c.options.onSelect.apply(a, [c.selectedDates]);
                    c.inSelect = false;
                }
            }
        },
        _getBorders: function (b) {
            var c = function (a) {
                return {
                    thin: 1,
                    medium: 3,
                    thick: 5
                } [a] || a;
            };
            return [parseFloat(c(b.css('border-left-width'))), parseFloat(c(b.css('border-top-width')))];
        },
        _checkOffset: function (a) {
            var b = (a.elem.is(':hidden') && a.trigger ? a.trigger : a.elem);
            var c = b.offset();
            var d = $(window).width();
            var e = $(window).height();
            if (d === 0) {
                return c;
            }
            var f = false;
            $(a.elem).parents().each(function () {
                f |= $(this).css('position') === 'fixed';
                return !f;
            });
            var g = document.documentElement.scrollLeft || document.body.scrollLeft;
            var h = document.documentElement.scrollTop || document.body.scrollTop;
            var i = c.top - (f ? h : 0) - a.div.outerHeight();
            var j = c.top - (f ? h : 0) + b.outerHeight();
            var k = c.left - (f ? g : 0);
            var l = c.left - (f ? g : 0) + b.outerWidth() - a.div.outerWidth();
            var m = (c.left - g + a.div.outerWidth()) > d;
            var n = (c.top - h + a.elem.outerHeight() + a.div.outerHeight()) > e;
            a.div.css('position', f ? 'fixed' : 'absolute');
            var o = a.options.alignment;
            if (o === 'topLeft') {
                c = {
                    left: k,
                    top: i
                };
            } else if (o === 'topRight') {
                c = {
                    left: l,
                    top: i
                };
            } else if (o === 'bottomLeft') {
                c = {
                    left: k,
                    top: j
                };
            } else if (o === 'bottomRight') {
                c = {
                    left: l,
                    top: j
                };
            } else if (o === 'top') {
                c = {
                    left: (a.options.isRTL || m ? l : k),
                    top: i
                };
            } else {
                c = {
                    left: (a.options.isRTL || m ? l : k),
                    top: (n ? i : j)
                };
            }
            c.left = Math.max((f ? 0 : g), c.left);
            c.top = Math.max((f ? 0 : h), c.top);
            return c;
        },
        _checkExternalClick: function (a) {
            if (!F.curInst) {
                return;
            }
            var b = $(a.target);
            if (b.closest('.' + F._popupClass + ',.' + F._triggerClass).length === 0 && !b.hasClass(F._getMarker())) {
                F.hide(F.curInst);
            }
        },
        hide: function (a, b) {
            if (!a) {
                return;
            }
            var c = this._getInst(a);
            if ($.isEmptyObject(c)) {
                c = a;
            }
            if (c && c === F.curInst) {
                var d = (b ? '' : c.options.showAnim);
                var e = c.options.showSpeed;
                e = (e === 'normal' && $.ui && parseInt($.ui.version.substring(2)) >= 8 ? '_default' : e);
                var f = function () {
                    if (!c.div) {
                        return;
                    }
                    c.div.remove();
                    c.div = null;
                    F.curInst = null;
                    if ($.isFunction(c.options.onClose)) {
                        c.options.onClose.apply(a, [c.selectedDates]);
                    }
                };
                c.div.stop();
                if ($.effects && ($.effects[d] || ($.effects.effect && $.effects.effect[d]))) {
                    c.div.hide(d, c.options.showOptions, e, f);
                } else {
                    var g = (d === 'slideDown' ? 'slideUp' : (d === 'fadeIn' ? 'fadeOut' : 'hide'));
                    c.div[g]((d ? e : ''), f);
                }
                if (!d) {
                    f();
                }
            }
        },
        _keyDown: function (a) {
            var b = (a.data && a.data.elem) || a.target;
            var c = F._getInst(b);
            var d = false;
            if (c.inline || c.div) {
                if (a.keyCode === 9) {
                    F.hide(b);
                } else if (a.keyCode === 13) {
                    F.selectDate(b, $('a.' + c.options.renderer.highlightedClass, c.div)[0]);
                    d = true;
                } else {
                    var e = c.options.commands;
                    for (var f in e) {
                        var g = e[f];
                        if (g.keystroke.keyCode === a.keyCode && !!g.keystroke.ctrlKey === !!(a.ctrlKey || a.metaKey) && !!g.keystroke.altKey === a.altKey && !!g.keystroke.shiftKey === a.shiftKey) {
                            F.performAction(b, f);
                            d = true;
                            break;
                        }
                    }
                }
            } else {
                var g = c.options.commands.current;
                if (g.keystroke.keyCode === a.keyCode && !!g.keystroke.ctrlKey === !!(a.ctrlKey || a.metaKey) && !!g.keystroke.altKey === a.altKey && !!g.keystroke.shiftKey === a.shiftKey) {
                    F.show(b);
                    d = true;
                }
            }
            c.ctrlKey = ((a.keyCode < 48 && a.keyCode !== 32) || a.ctrlKey || a.metaKey);
            if (d) {
                a.preventDefault();
                a.stopPropagation();
            }
            return !d;
        },
        _keyPress: function (a) {
            var b = F._getInst((a.data && a.data.elem) || a.target);
            if (!$.isEmptyObject(b) && b.options.constrainInput) {
                var c = String.fromCharCode(a.keyCode || a.charCode);
                var d = F._allowedChars(b);
                return (a.metaKey || b.ctrlKey || c < ' ' || !d || d.indexOf(c) > -1);
            }
            return true;
        },
        _allowedChars: function (a) {
            var b = (a.options.multiSelect ? a.options.multiSeparator : (a.options.rangeSelect ? a.options.rangeSeparator : ''));
            var c = false;
            var d = false;
            var e = a.options.dateFormat;
            for (var i = 0; i < e.length; i++) {
                var f = e.charAt(i);
                if (c) {
                    if (f === "'" && e.charAt(i + 1) !== "'") {
                        c = false;
                    } else {
                        b += f;
                    }
                } else {
                    switch (f) {
                        case 'd':
                        case 'm':
                        case 'o':
                        case 'w':
                            b += (d ? '' : '0123456789');
                            d = true;
                            break;
                        case 'y':
                        case '@':
                        case '!':
                            b += (d ? '' : '0123456789') + '-';
                            d = true;
                            break;
                        case 'J':
                            b += (d ? '' : '0123456789') + '-.';
                            d = true;
                            break;
                        case 'D':
                        case 'M':
                        case 'Y':
                            return null;
                        case "'":
                            if (e.charAt(i + 1) === "'") {
                                b += "'";
                            } else {
                                c = true;
                            }
                            break;
                        default:
                            b += f;
                    }
                }
            }
            return b;
        },
        _keyUp: function (a) {
            var b = (a.data && a.data.elem) || a.target;
            var c = F._getInst(b);
            if (!$.isEmptyObject(c) && !c.ctrlKey && c.lastVal !== c.elem.val()) {
                try {
                    var d = F._extractDates(c, c.elem.val());
                    if (d.length > 0) {
                        F.setDate(b, d, null, true);
                    }
                } catch (a) {}
            }
            return true;
        },
        _doMouseWheel: function (a, b) {
            var c = (F.curInst && F.curInst.elem[0]) || $(a.target).closest('.' + F._getMarker())[0];
            if (F.isDisabled(c)) {
                return;
            }
            var d = F._getInst(c);
            if (d.options.useMouseWheel) {
                b = (b < 0 ? -1 : +1);
                F.changeMonth(c, -d.options[a.ctrlKey ? 'monthsToJump' : 'monthsToStep'] * b);
            }
            a.preventDefault();
        },
        clear: function (a) {
            var b = this._getInst(a);
            if (!$.isEmptyObject(b)) {
                b.selectedDates = [];
                this.hide(a);
                var c = b.get('defaultDate');
                if (b.options.selectDefaultDate && c) {
                    this.setDate(a, F.newDate(c || F.today()));
                } else {
                    this._updateInput(a);
                }
            }
        },
        getDate: function (a) {
            var b = this._getInst(a);
            return (!$.isEmptyObject(b) ? b.selectedDates : []);
        },
        setDate: function (a, b, c, d, e) {
            var f = this._getInst(a);
            if (!$.isEmptyObject(f)) {
                if (!$.isArray(b)) {
                    b = [b];
                    if (c) {
                        b.push(c);
                    }
                }
                var g = f.get('minDate');
                var h = f.get('maxDate');
                var k = f.selectedDates[0];
                f.selectedDates = [];
                for (var i = 0; i < b.length; i++) {
                    var l = F.determineDate(b[i], null, k, f.options.dateFormat, f.getConfig());
                    if (l) {
                        if ((!g || l.getTime() >= g.getTime()) && (!h || l.getTime() <= h.getTime())) {
                            var m = false;
                            for (var j = 0; j < f.selectedDates.length; j++) {
                                if (f.selectedDates[j].getTime() === l.getTime()) {
                                    m = true;
                                    break;
                                }
                            }
                            if (!m) {
                                f.selectedDates.push(l);
                            }
                        }
                    }
                }
                f.selectedDates.splice(f.options.multiSelect || (f.options.rangeSelect ? 2 : 1), f.selectedDates.length);
                if (f.options.rangeSelect) {
                    switch (f.selectedDates.length) {
                        case 1:
                            f.selectedDates[1] = f.selectedDates[0];
                            break;
                        case 2:
                            f.selectedDates[1] = (f.selectedDates[0].getTime() > f.selectedDates[1].getTime() ? f.selectedDates[0] : f.selectedDates[1]);
                            break;
                    }
                    f.pickingRange = false;
                }
                f.prevDate = (f.drawDate ? F.newDate(f.drawDate) : null);
                f.drawDate = this._checkMinMax(F.newDate(f.selectedDates[0] || f.get('defaultDate') || F.today()), f);
                if (!e) {
                    this._update(a);
                    this._updateInput(a, d);
                }
            }
        },
        isSelectable: function (a, b) {
            var c = this._getInst(a);
            if ($.isEmptyObject(c)) {
                return false;
            }
            b = F.determineDate(b, c.selectedDates[0] || this.today(), null, c.options.dateFormat, c.getConfig());
            return this._isSelectable(a, b, c.options.onDate, c.get('minDate'), c.get('maxDate'));
        },
        _isSelectable: function (a, b, c, d, e) {
            var f = (typeof c === 'boolean' ? {
                selectable: c
            } : (!$.isFunction(c) ? {} : c.apply(a, [b, true])));
            return (f.selectable !== false) && (!d || b.getTime() >= d.getTime()) && (!e || b.getTime() <= e.getTime());
        },
        performAction: function (a, b) {
            var c = this._getInst(a);
            if (!$.isEmptyObject(c) && !this.isDisabled(a)) {
                var d = c.options.commands;
                if (d[b] && d[b].enabled.apply(a, [c])) {
                    d[b].action.apply(a, [c]);
                }
            }
        },
        showMonth: function (a, b, c, d) {
            var e = this._getInst(a);
            if (!$.isEmptyObject(e) && (d != null || (e.drawDate.getFullYear() !== b || e.drawDate.getMonth() + 1 !== c))) {
                e.prevDate = F.newDate(e.drawDate);
                var f = this._checkMinMax((b != null ? F.newDate(b, c, 1) : F.today()), e);
                e.drawDate = F.newDate(f.getFullYear(), f.getMonth() + 1, (d != null ? d : Math.min(e.drawDate.getDate(), F.daysInMonth(f.getFullYear(), f.getMonth() + 1))));
                this._update(a);
            }
        },
        changeMonth: function (a, b) {
            var c = this._getInst(a);
            if (!$.isEmptyObject(c)) {
                var d = F.add(F.newDate(c.drawDate), b, 'm');
                this.showMonth(a, d.getFullYear(), d.getMonth() + 1);
            }
        },
        changeDay: function (a, b) {
            var c = this._getInst(a);
            if (!$.isEmptyObject(c)) {
                var d = F.add(F.newDate(c.drawDate), b, 'd');
                this.showMonth(a, d.getFullYear(), d.getMonth() + 1, d.getDate());
            }
        },
        _checkMinMax: function (a, b) {
            var c = b.get('minDate');
            var d = b.get('maxDate');
            a = (c && a.getTime() < c.getTime() ? F.newDate(c) : a);
            a = (d && a.getTime() > d.getTime() ? F.newDate(d) : a);
            return a;
        },
        retrieveDate: function (a, b) {
            var c = this._getInst(a);
            return ($.isEmptyObject(c) ? null : this._normaliseDate(new Date(parseInt(b.className.replace(/^.*dp(-?\d+).*$/, '$1'), 10))));
        },
        selectDate: function (a, b) {
            var c = this._getInst(a);
            if (!$.isEmptyObject(c) && !this.isDisabled(a)) {
                var d = this.retrieveDate(a, b);
                if (c.options.multiSelect) {
                    var e = false;
                    for (var i = 0; i < c.selectedDates.length; i++) {
                        if (d.getTime() === c.selectedDates[i].getTime()) {
                            c.selectedDates.splice(i, 1);
                            e = true;
                            break;
                        }
                    }
                    if (!e && c.selectedDates.length < c.options.multiSelect) {
                        c.selectedDates.push(d);
                    }
                } else if (c.options.rangeSelect) {
                    if (c.pickingRange) {
                        c.selectedDates[1] = d;
                    } else {
                        c.selectedDates = [d, d];
                    }
                    c.pickingRange = !c.pickingRange;
                } else {
                    c.selectedDates = [d];
                }
                c.prevDate = c.drawDate = F.newDate(d);
                this._updateInput(a);
                if (c.inline || c.pickingRange || c.selectedDates.length < (c.options.multiSelect || (c.options.rangeSelect ? 2 : 1))) {
                    this._update(a);
                } else {
                    this.hide(a);
                }
            }
        },
        _generateContent: function (h, i) {
            var j = i.options.monthsToShow;
            j = ($.isArray(j) ? j : [1, j]);
            i.drawDate = this._checkMinMax(i.drawDate || i.get('defaultDate') || F.today(), i);
            var k = F._applyMonthsOffset(F.newDate(i.drawDate), i);
            var l = '';
            for (var m = 0; m < j[0]; m++) {
                var n = '';
                for (var o = 0; o < j[1]; o++) {
                    n += this._generateMonth(h, i, k.getFullYear(), k.getMonth() + 1, i.options.renderer, (m === 0 && o === 0));
                    F.add(k, 1, 'm');
                }
                l += this._prepare(i.options.renderer.monthRow, i).replace(/\{months\}/, n);
            }
            var p = this._prepare(i.options.renderer.picker, i).replace(/\{months\}/, l).replace(/\{weekHeader\}/g, this._generateDayHeaders(i, i.options.renderer));
            var q = function (a, b, c, d, e) {
                if (p.indexOf('{' + a + ':' + d + '}') === -1) {
                    return;
                }
                var f = i.options.commands[d];
                var g = (i.options.commandsAsDateFormat ? f.date.apply(h, [i]) : null);
                p = p.replace(new RegExp('\\{' + a + ':' + d + '\\}', 'g'), '<' + b + (f.status ? ' title="' + i.options[f.status] + '"' : '') + ' class="' + i.options.renderer.commandClass + ' ' + i.options.renderer.commandClass + '-' + d + ' ' + e + (f.enabled(i) ? '' : ' ' + i.options.renderer.disabledClass) + '">' + (g ? F.formatDate(i.options[f.text], g, i.getConfig()) : i.options[f.text]) + '</' + c + '>');
            };
            for (var r in i.options.commands) {
                q('button', 'button type="button"', 'button', r, i.options.renderer.commandButtonClass);
                q('link', 'a href="javascript:void(0)"', 'a', r, i.options.renderer.commandLinkClass);
            }
            p = $(p);
            if (j[1] > 1) {
                var s = 0;
                $(i.options.renderer.monthSelector, p).each(function () {
                    var a = ++s % j[1];
                    $(this).addClass(a === 1 ? 'first' : (a === 0 ? 'last' : ''));
                });
            }
            var t = this;

            function removeHighlight() {
                (i.inline ? $(this).closest('.' + t._getMarker()) : i.div).find(i.options.renderer.daySelector + ' a').removeClass(i.options.renderer.highlightedClass);
            }
            p.find(i.options.renderer.daySelector + ' a').hover(function () {
                removeHighlight.apply(this);
                $(this).addClass(i.options.renderer.highlightedClass);
            }, removeHighlight).click(function () {
                t.selectDate(h, this);
            }).end().find('select.' + this._monthYearClass + ':not(.' + this._anyYearClass + ')').change(function () {
                var a = $(this).val().split('/');
                t.showMonth(h, parseInt(a[1], 10), parseInt(a[0], 10));
            }).end().find('select.' + this._anyYearClass).click(function () {
                $(this).css('visibility', 'hidden').next('input').css({
                    left: this.offsetLeft,
                    top: this.offsetTop,
                    width: this.offsetWidth,
                    height: this.offsetHeight
                }).show().focus();
            }).end().find('input.' + t._monthYearClass).change(function () {
                try {
                    var a = parseInt($(this).val(), 10);
                    a = (isNaN(a) ? i.drawDate.getFullYear() : a);
                    t.showMonth(h, a, i.drawDate.getMonth() + 1, i.drawDate.getDate());
                } catch (e) {
                    alert(e);
                }
            }).keydown(function (a) {
                if (a.keyCode === 13) {
                    $(a.elem).change();
                } else if (a.keyCode === 27) {
                    $(a.elem).hide().prev('select').css('visibility', 'visible');
                    i.elem.focus();
                }
            });
            var u = {
                elem: i.elem[0]
            };
            p.keydown(u, this._keyDown).keypress(u, this._keyPress).keyup(u, this._keyUp);
            p.find('.' + i.options.renderer.commandClass).click(function () {
                if (!$(this).hasClass(i.options.renderer.disabledClass)) {
                    var a = this.className.replace(new RegExp('^.*' + i.options.renderer.commandClass + '-([^ ]+).*$'), '$1');
                    F.performAction(h, a);
                }
            });
            if (i.options.isRTL) {
                p.addClass(i.options.renderer.rtlClass);
            }
            if (j[0] * j[1] > 1) {
                p.addClass(i.options.renderer.multiClass);
            }
            if (i.options.pickerClass) {
                p.addClass(i.options.pickerClass);
            }
            $('body').append(p);
            var v = 0;
            p.find(i.options.renderer.monthSelector).each(function () {
                v += $(this).outerWidth();
            });
            p.width(v / j[0]);
            if ($.isFunction(i.options.onShow)) {
                i.options.onShow.apply(h, [p, i]);
            }
            return p;
        },
        _generateMonth: function (a, b, c, d, e, f) {
            var g = F.daysInMonth(c, d);
            var h = b.options.monthsToShow;
            h = ($.isArray(h) ? h : [1, h]);
            var j = b.options.fixedWeeks || (h[0] * h[1] > 1);
            var k = b.options.firstDay;
            var l = (F.newDate(c, d, 1).getDay() - k + 7) % 7;
            var m = (j ? 6 : Math.ceil((l + g) / 7));
            var n = b.options.selectOtherMonths && b.options.showOtherMonths;
            var o = (b.pickingRange ? b.selectedDates[0] : b.get('minDate'));
            var p = b.get('maxDate');
            var q = e.week.indexOf('{weekOfYear}') > -1;
            var r = F.today();
            var s = F.newDate(c, d, 1);
            F.add(s, -l - (j && (s.getDay() === k) ? 7 : 0), 'd');
            var t = s.getTime();
            var u = '';
            for (var v = 0; v < m; v++) {
                var w = (!q ? '' : '<span class="dp' + t + '">' + ($.isFunction(b.options.calculateWeek) ? b.options.calculateWeek(s) : 0) + '</span>');
                var x = '';
                for (var y = 0; y < 7; y++) {
                    var z = false;
                    if (b.options.rangeSelect && b.selectedDates.length > 0) {
                        z = (s.getTime() >= b.selectedDates[0] && s.getTime() <= b.selectedDates[1]);
                    } else {
                        for (var i = 0; i < b.selectedDates.length; i++) {
                            if (b.selectedDates[i].getTime() === s.getTime()) {
                                z = true;
                                break;
                            }
                        }
                    }
                    var A = (!$.isFunction(b.options.onDate) ? {} : b.options.onDate.apply(a, [s, s.getMonth() + 1 === d]));
                    var B = (n || s.getMonth() + 1 === d) && this._isSelectable(a, s, A.selectable, o, p);
                    x += this._prepare(e.day, b).replace(/\{day\}/g, (B ? '<a href="javascript:void(0)"' : '<span') + ' class="dp' + t + ' ' + (A.dateClass || '') + (z && (n || s.getMonth() + 1 === d) ? ' ' + e.selectedClass : '') + (B ? ' ' + e.defaultClass : '') + ((s.getDay() || 7) < 6 ? '' : ' ' + e.weekendClass) + (s.getMonth() + 1 === d ? '' : ' ' + e.otherMonthClass) + (s.getTime() === r.getTime() && (s.getMonth() + 1) === d ? ' ' + e.todayClass : '') + (s.getTime() === b.drawDate.getTime() && (s.getMonth() + 1) === d ? ' ' + e.highlightedClass : '') + '"' + (A.title || (b.options.dayStatus && B) ? ' title="' + (A.title || F.formatDate(b.options.dayStatus, s, b.getConfig())) + '"' : '') + '>' + (b.options.showOtherMonths || (s.getMonth() + 1) === d ? A.content || s.getDate() : '&#160;') + (B ? '</a>' : '</span>'));
                    F.add(s, 1, 'd');
                    t = s.getTime();
                }
                u += this._prepare(e.week, b).replace(/\{days\}/g, x).replace(/\{weekOfYear\}/g, w);
            }
            var C = this._prepare(e.month, b).match(/\{monthHeader(:[^\}]+)?\}/);
            C = (C[0].length <= 13 ? 'MM yyyy' : C[0].substring(13, C[0].length - 1));
            C = (f ? this._generateMonthSelection(b, c, d, o, p, C, e) : F.formatDate(C, F.newDate(c, d, 1), b.getConfig()));
            var D = this._prepare(e.weekHeader, b).replace(/\{days\}/g, this._generateDayHeaders(b, e));
            return this._prepare(e.month, b).replace(/\{monthHeader(:[^\}]+)?\}/g, C).replace(/\{weekHeader\}/g, D).replace(/\{weeks\}/g, u);
        },
        _generateDayHeaders: function (a, b) {
            var c = '';
            for (var d = 0; d < 7; d++) {
                var e = (d + a.options.firstDay) % 7;
                c += this._prepare(b.dayHeader, a).replace(/\{day\}/g, '<span class="' + this._curDoWClass + e + '" title="' + a.options.dayNames[e] + '">' + a.options.dayNamesMin[e] + '</span>');
            }
            return c;
        },
        _generateMonthSelection: function (b, c, d, e, f, g) {
            if (!b.options.changeMonth) {
                return F.formatDate(g, F.newDate(c, d, 1), b.getConfig());
            }
            var h = b.options['monthNames' + (g.match(/mm/i) ? '' : 'Short')];
            var i = g.replace(/m+/i, '\\x2E').replace(/y+/i, '\\x2F');
            var j = '<select class="' + this._monthYearClass + '" title="' + b.options.monthStatus + '">';
            for (var m = 1; m <= 12; m++) {
                if ((!e || F.newDate(c, m, F.daysInMonth(c, m)).getTime() >= e.getTime()) && (!f || F.newDate(c, m, 1).getTime() <= f.getTime())) {
                    j += '<option value="' + m + '/' + c + '"' + (d === m ? ' selected="selected"' : '') + '>' + h[m - 1] + '</option>';
                }
            }
            j += '</select>';
            i = i.replace(/\\x2E/, j);
            var k = b.options.yearRange;
            if (k === 'any') {
                j = '<select class="' + this._monthYearClass + ' ' + this._anyYearClass + '" title="' + b.options.yearStatus + '">' + '<option>' + c + '</option></select>' + '<input class="' + this._monthYearClass + ' ' + this._curMonthClass + d + '" value="' + c + '">';
            } else {
                k = k.split(':');
                var l = F.today().getFullYear();
                var n = (k[0].match('c[+-].*') ? c + parseInt(k[0].substring(1), 10) : ((k[0].match('[+-].*') ? l : 0) + parseInt(k[0], 10)));
                var o = (k[1].match('c[+-].*') ? c + parseInt(k[1].substring(1), 10) : ((k[1].match('[+-].*') ? l : 0) + parseInt(k[1], 10)));
                j = '<select class="' + this._monthYearClass + '" title="' + b.options.yearStatus + '">';
                n = F.add(F.newDate(n + 1, 1, 1), -1, 'd');
                o = F.newDate(o, 1, 1);
                var p = function (y, a) {
                    if (y !== 0) {
                        j += '<option value="' + d + '/' + y + '"' + (c === y ? ' selected="selected"' : '') + '>' + (a || y) + '</option>';
                    }
                };
                if (n.getTime() < o.getTime()) {
                    n = (e && e.getTime() > n.getTime() ? e : n).getFullYear();
                    o = (f && f.getTime() < o.getTime() ? f : o).getFullYear();
                    var q = Math.floor((o - n) / 2);
                    if (!e || e.getFullYear() < n) {
                        p(n - q, b.options.earlierText);
                    }
                    for (var y = n; y <= o; y++) {
                        p(y);
                    }
                    if (!f || f.getFullYear() > o) {
                        p(o + q, b.options.laterText);
                    }
                } else {
                    n = (f && f.getTime() < n.getTime() ? f : n).getFullYear();
                    o = (e && e.getTime() > o.getTime() ? e : o).getFullYear();
                    var q = Math.floor((n - o) / 2);
                    if (!f || f.getFullYear() > n) {
                        p(n + q, b.options.earlierText);
                    }
                    for (var y = n; y >= o; y--) {
                        p(y);
                    }
                    if (!e || e.getFullYear() < o) {
                        p(o - q, b.options.laterText);
                    }
                }
                j += '</select>';
            }
            i = i.replace(/\\x2F/, j);
            return i;
        },
        _prepare: function (e, f) {
            var g = function (a, b) {
                while (true) {
                    var c = e.indexOf('{' + a + ':start}');
                    if (c === -1) {
                        return;
                    }
                    var d = e.substring(c).indexOf('{' + a + ':end}');
                    if (d > -1) {
                        e = e.substring(0, c) + (b ? e.substr(c + a.length + 8, d - a.length - 8) : '') + e.substring(c + d + a.length + 6);
                    }
                }
            };
            g('inline', f.inline);
            g('popup', !f.inline);
            var h = /\{l10n:([^\}]+)\}/;
            var i = null;
            while (i = h.exec(e)) {
                e = e.replace(i[0], f.options[i[1]]);
            }
            return e;
        }
    });
    var F = $.datepick;
    $(function () {
        $(document).on('mousedown.' + E, F._checkExternalClick).on('resize.' + E, function () {
            F.hide(F.curInst)
        })
    })
})(jQuery);


/** http://keith-wood.name/datepick.html
   Datepicker extensions for jQuery v5.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Licensed under the MIT (http://keith-wood.name/licence.html) licence. 
   Please attribute the author if you use it. */
(function ($) {
    var p = {
        picker: '<div{popup:start} id="ui-datepicker-div"{popup:end} class="ui-datepicker ui-widget ' + 'ui-widget-content ui-helper-clearfix ui-corner-all{inline:start} ui-datepicker-inline{inline:end}">' + '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ui-corner-all">' + '{link:prev}{link:today}{link:next}</div>{months}' + '{popup:start}<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ' + 'ui-corner-all">{button:clear}{button:close}</div>{popup:end}' + '<div class="ui-helper-clearfix"></div></div>',
        monthRow: '<div class="ui-datepicker-row-break">{months}</div>',
        month: '<div class="ui-datepicker-group">' + '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ui-corner-all">{monthHeader:MM yyyy}</div>' + '<table class="ui-datepicker-calendar"><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
        weekHeader: '<tr>{days}</tr>',
        dayHeader: '<th>{day}</th>',
        week: '<tr>{days}</tr>',
        day: '<td>{day}</td>',
        monthSelector: '.ui-datepicker-group',
        daySelector: 'td',
        rtlClass: 'ui-datepicker-rtl',
        multiClass: 'ui-datepicker-multi',
        defaultClass: 'ui-state-default',
        selectedClass: 'ui-state-active',
        highlightedClass: 'ui-state-hover',
        todayClass: 'ui-state-highlight',
        otherMonthClass: 'ui-datepicker-other-month',
        weekendClass: 'ui-datepicker-week-end',
        commandClass: 'ui-datepicker-cmd',
        commandButtonClass: 'ui-state-default ui-corner-all',
        commandLinkClass: '',
        disabledClass: 'ui-datepicker-disabled'
    };
    $.extend($.datepick, {
        weekOfYearRenderer: $.extend({}, $.datepick.defaultRenderer, {
            weekHeader: '<tr><th class="datepick-week">' + '<span title="{l10n:weekStatus}">{l10n:weekText}</span></th>{days}</tr>',
            week: '<tr><td class="datepick-week">{weekOfYear}</td>{days}</tr>'
        }),
        themeRollerRenderer: p,
        themeRollerWeekOfYearRenderer: $.extend({}, p, {
            weekHeader: '<tr><th class="ui-state-hover"><span>{l10n:weekText}</span></th>{days}</tr>',
            week: '<tr><td class="ui-state-hover">{weekOfYear}</td>{days}</tr>'
        }),
        noWeekends: function (a) {
            return {
                selectable: (a.getDay() || 7) < 6
            }
        },
        changeFirstDay: function (c, d) {
            var e = $(this);
            c.find('th span').each(function () {
                var b = $(this).parent();
                if (b.is('.datepick-week') || b.is('.ui-state-hover')) {
                    return
                }
                $('<a href="javascript:void(0)" class="' + this.className + '" title="Change first day of the week">' + $(this).text() + '</a>').click(function () {
                    var a = parseInt(this.className.replace(/^.*datepick-dow-(\d+).*$/, '$1'), 10);
                    e.datepick('option', {
                        firstDay: a
                    })
                }).replaceAll(this)
            })
        },
        hoverCallback: function (e) {
            return function (a, b) {
                var c = this;
                var d = b.get('renderer');
                a.find(d.daySelector + ' a, ' + d.daySelector + ' span').hover(function () {
                    e.apply(c, [$.datepick.retrieveDate(c, this), this.nodeName.toLowerCase() === 'a'])
                }, function () {
                    e.apply(c, [])
                })
            }
        },
        highlightWeek: function (a, b) {
            var c = this;
            var d = b.get('renderer');
            a.find(d.daySelector + ' a, ' + d.daySelector + ' span').hover(function () {
                $(this).parents('tr').find(d.daySelector + ' *').addClass(d.highlightedClass)
            }, function () {
                $(this).parents('tr').find(d.daySelector + ' *').removeClass(d.highlightedClass)
            })
        },
        showStatus: function (b, c) {
            var d = c.get('renderer');
            var e = (d.selectedClass === p.selectedClass);
            var f = c.get('defaultStatus') || '&#160;';
            var g = $('<div class="' + (!e ? 'datepick-status' : 'ui-datepicker-status ui-widget-header ui-helper-clearfix ui-corner-all') + '">' + f + '</div>').insertAfter(b.find('.datepick-month-row:last,.ui-datepicker-row-break:last'));
            b.find('*[title]').each(function () {
                var a = $(this).attr('title');
                $(this).removeAttr('title').hover(function () {
                    g.text(a || f)
                }, function () {
                    g.text(f)
                })
            })
        },
        monthNavigation: function (b, c) {
            var d = $(this);
            var e = c.get('renderer');
            var f = (e.selectedClass === p.selectedClass);
            var g = c.curMinDate();
            var h = c.get('maxDate');
            var j = c.get('monthNames');
            var k = c.get('monthNamesShort');
            var l = c.drawDate.getMonth();
            var m = c.drawDate.getFullYear();
            var n = '<div class="' + (!f ? 'datepick-month-nav' : 'ui-datepicker-month-nav') + '"' + ' style="display: none;">';
            for (var i = 0; i < j.length; i++) {
                var o = ((!g || new Date(m, i + 1, 0).getTime() >= g.getTime()) && (!h || new Date(m, i, 1).getTime() <= h.getTime()));
                n += '<div>' + (o ? '<a href="#" class="dp' + new Date(m, i, 1).getTime() + '"' : '<span') + ' title="' + j[i] + '">' + k[i] + (o ? '</a>' : '</span>') + '</div>'
            }
            for (var i = -6; i <= 6; i++) {
                if (i === 0) {
                    continue
                }
                var o = ((!g || new Date(m + i, 12 - 1, 31).getTime() >= g.getTime()) && (!h || new Date(m + i, 1 - 1, 1).getTime() <= h.getTime()));
                n += '<div>' + (o ? '<a href="#" class="dp' + new Date(m + i, l, 1).getTime() + '"' : '<span') + ' title="' + (m + i) + '">' + (m + i) + (o ? '</a>' : '</span>') + '</div>'
            }
            n += '</div>';
            n = $(n).insertAfter(b.find('div.datepick-nav,div.ui-datepicker-header:first'));
            n.find('a').click(function () {
                var a = $.datepick.retrieveDate(d[0], this);
                n.slideToggle(function () {
                    d.datepick('showMonth', a.getFullYear(), a.getMonth() + 1)
                });
                return false
            });
            b.find('div.datepick-month-header,div.ui-datepicker-month-header').click(function () {
                n.slideToggle()
            }).css('cursor', 'pointer')
        },
        selectWeek: function (c, d) {
            var e = $(this);
            c.find('td.datepick-week span,td.ui-state-hover span').each(function () {
                $('<a href="javascript:void(0)" class="' + this.className + '" title="Select the entire week">' + $(this).text() + '</a>').click(function () {
                    var a = e.datepick('retrieveDate', this);
                    var b = [a];
                    for (var i = 1; i < 7; i++) {
                        b.push(a = $.datepick.add($.datepick.newDate(a), 1, 'd'))
                    }
                    if (d.get('rangeSelect')) {
                        b.splice(1, b.length - 2)
                    }
                    e.datepick('setDate', b).datepick('hide')
                }).replaceAll(this)
            })
        },
        selectMonth: function (d, e) {
            var f = $(this);
            d.find('th.datepick-week span,th.ui-state-hover span').each(function () {
                $('<a href="javascript:void(0)" title="Select the entire month">' + $(this).text() + '</a>').click(function () {
                    var a = f.datepick('retrieveDate', $(this).parents('table').find('td:not(.datepick-week):not(.ui-state-hover) ' + '*:not(.datepick-other-month):not(.ui-datepicker-other-month)')[0]);
                    var b = [a];
                    var c = $.datepick.daysInMonth(a);
                    for (var i = 1; i < c; i++) {
                        b.push(a = $.datepick.add($.datepick.newDate(a), 1, 'd'))
                    }
                    if (e.get('rangeSelect')) {
                        b.splice(1, b.length - 2)
                    }
                    f.datepick('setDate', b).datepick('hide')
                }).replaceAll(this)
            })
        },
        monthOnly: function (b, c) {
            var d = $(this);
            var e = $('<div style="text-align: center;"><button type="button">Select</button></div>').insertAfter(b.find('.datepick-month-row:last,.ui-datepicker-row-break:last')).children().click(function () {
                var a = b.find('.datepick-month-year:first').val().split('/');
                d.datepick('setDate', $.datepick.newDate(parseInt(a[1], 10), parseInt(a[0], 10), 1)).datepick('hide')
            });
            b.find('.datepick-month-row table,.ui-datepicker-row-break table').remove()
        }
    })
})(jQuery);


/* http://keith-wood.name/datepick.html
   German localisation for jQuery Datepicker.
   Written by Milian Wolff (mail@milianw.de). */
(function ($) {
    $.datepick.regionalOptions['de'] = {
        monthNames: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
            'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'
        ],
        monthNamesShort: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
            'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
        ],
        dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
        dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
        dayNamesMin: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
        dateFormat: 'dd.mm.yyyy',
        firstDay: 1,
        renderer: $.datepick.defaultRenderer,
        prevText: '&#x3c;zurück',
        prevStatus: 'letzten Monat zeigen',
        prevJumpText: '&#x3c;&#x3c;',
        prevJumpStatus: '',
        nextText: 'Vor&#x3e;',
        nextStatus: 'nächsten Monat zeigen',
        nextJumpText: '&#x3e;&#x3e;',
        nextJumpStatus: '',
        currentText: 'heute',
        currentStatus: '',
        todayText: 'heute',
        todayStatus: '',
        clearText: 'löschen',
        clearStatus: 'aktuelles Datum löschen',
        closeText: 'schließen',
        closeStatus: 'ohne Änderungen schließen',
        yearStatus: 'anderes Jahr anzeigen',
        monthStatus: 'anderen Monat anzeigen',
        weekText: 'Wo',
        weekStatus: 'Woche des Monats',
        dayStatus: 'Wähle D, M d',
        defaultStatus: 'Wähle ein Datum',
        isRTL: false
    };
    $.datepick.setDefaults($.datepick.regionalOptions['de']);
})(jQuery);

/*
 jquery.shopfunctions.js
 lastchange sb9945 20220301 BXW-1039
 lastchange sb4910 20220311 no login hint favorites
  
 */
if (!String.prototype.trim) {
    String.prototype.trim = function () {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
}

$('document').ready(function () {
    //sb4910: plus minus button bestellzeilen / warenkorb
    $(".bx-articlecount-input").before("<a href='' class='bx-basket-btnminus'><span class='glyphicon glyphicon-minus'></span></a>");
    $(".bx-articlecount-input").after("<a href='' class='bx-basket-btnplus'><span class='glyphicon glyphicon-plus'></a>");
    $(".bx-basket-btnminus").click(function () {
        bxIncreaseOrDecreaseArticleCount($(this).next(), false);
        return false;
    });
    $(".bx-basket-btnplus").click(function () {
        bxIncreaseOrDecreaseArticleCount($(this).prev(), true);
        return false;
    });
    $(body).append('<div id="dialog" class="modal fade" role="dialog"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button id="modal-closebtn" type="button" class="close" data-dismiss="modal">&times;</button><h4 class="modal-title">&nbsp;</h4></div><div class="modal-body" id="dialog-modalbox-inner"> <p></p></div><div class="modal-footer"> </div></div></div>');

    if ($('.bxfooternlsearchtrigger').length > 0) {
        $('.bxfooternlsearchtrigger').click(function () {
            bxTriggerNlSearchByTerm($(this).prev().val());
            return false;
        });
    }
    $('.bxfooternlsearchinput').keypress(function (e) {
        if (e.which == 13) {
            bxTriggerNlSearchByTerm($(this).val());
        }
    });


    if (typeof bxlognoticeobj != "undefined" && bxlognoticeobj != null) {
        bxSetAndShowModalBox(bxlognoticeobj.text);
    }

    if ($('#bxminilogin').length > 0) {
        $('#bxminiloginuser').keypress(function (e) {
            //if (e.which == 13){$('#bxminiloginpw').focus();e.preventDefault();return false;}
            if (e.which == 13) {
                $('#bxminilogin').submit();
                e.preventDefault();
                return false;
            }
        });
        $('#bxminiloginpw').keypress(function (e) {
            if (e.which == 13) {
                $('#bxminilogin').submit();
                e.preventDefault();
                return false;
            }
        });
    }
    if ($('.bx-colorfield-lightbox').length > 0) {
        $('.bx-colorfield-lightbox').each(function () {
            $(this).append("<a class='bx-colorfield-lightbox-trigger' onclick='return false;' href='#'></a>");
        });
        $('.bx-colorfield-lightbox-trigger').click(function () {
            bxShowColorOrTextureInformation($(this).parent().attr("title"), $(this).parent().css("background-color"), $(this).parent().css("background-image"));

        });
    }
    //Append WhatsApp Link
    if ($('.dropdown-menu .socialmedia').length > 0 && navigator.userAgent.match(/(iPhone|iPad|Android)/g)) {
        encdoctitle = document.title;
        encdoctitle = encodeURI(encdoctitle.replace(/[?&=]/g, ' '));
        $('.dropdown-menu .socialmedia').append('<a target="_blank" title="WhatsApp" href="WhatsApp://send?text=' + encdoctitle + '"><i class="fa fa-whatsapp"></i></a>');
        encdoctitle = null;
    }

    // URL-Parameter logintype=login und logintype=logout aus URL entfernen
    var currentUrl = window.location.href;
    var newUrl = removeLoginTypeUriParam(window.location.href);
    if (currentUrl !== newUrl) {
        window.history.replaceState(null, null, newUrl);
    }


    //User notification registration status
    if (typeof bxuserconf != "undefined" && bxuserconf != null) {
        var bxbxloginstatushint = "";
        if (!bxuserconf["isemp"] && !bxuserconf["isprv"]) {
            if (!bxuserconf["isadm"] && !bxuserconf["hsadm"]) {
                bxbxloginstatushint = bxuserconf["t3lblunlockinfo"];
            } else if (!bxuserconf["isadm"] && bxuserconf["hsadm"]) {
                bxbxloginstatushint = bxuserconf["t3lblnoadmininfo"];
            }
            if (bxbxloginstatushint != "") {
                $(".bxloginstatushint").html("<i class='fa fa-info-circle'></i> " + bxbxloginstatushint);
            }
        }
        if ($(".teaserinactive").length > 0 && bxuserconf["t3lbllockedinfo"].length > 0) {
            $(".teaserinactive").append("<span class='teaserinactivelbl'>" + bxuserconf["t3lbllockedinfo"] + "</span>");
        }

    }

    //Add default 'Add to favorite link' page link
    //check if fav links should be offered bxpageconf => should be defined within (tpldomain)_mod.js
    if (typeof bxpageconf !== "undefined" && bxpageconf["showfavlinks"]) {

        if ($("#bxtoolbarmenu").length) {
            $("#bxtoolbarmenu").prepend('<li id="bxtoolbarfav"><a class="bx-btnaddfav" onclick="return false;" href=""><i class="fa fa-star-o"></i> ' + ((typeof bxpageconfll !== "undefined" && typeof bxpageconfll["addtofavorites"] !== "undefined") ? bxpageconfll["addtofavorites"] : "Favorit hinzufügen") + '</a></li>');
            //$( "#bxtoolbarmenu" ).parent().after('<li class="navbar"><a style="display:inline-block;" title="'+((typeof bxpageconfll !== "undefined" && typeof bxpageconfll["addtofavorites"] !== "undefined")?bxpageconfll["addtofavorites"]:"Favorit hinzufügen")+'" class="bx-btnaddfav" onclick="return false;" href=""><i class="fa fa-star-o"></i> </a></li>');
            $("#bxtoolbarmenuwrap").after('<li id="bxtoolbarfavdirect" class="navbar-right navbar-right2"><a id="bxtoolbarfavdirectbtn" title="' + ((typeof bxpageconfll !== "undefined" && typeof bxpageconfll["addtofavorites"] !== "undefined") ? bxpageconfll["addtofavorites"] : "Favorit hinzufügen") + '" class="bx-btnaddfav" onclick="return false;" href=""><i class="fa fa-star-o"></i> </a></li>');

        }

        $('.bx-btnaddfav').click(function (e) {
            bxAddFavEntryHandler($(this));
            //TODO: change to close bxtoolbarmenu
            $(document).trigger("click");
            return false;
        });
        $('.bx-btndeletefav').click(function (e) {
            if ($(this).data("favid") && $(this).data("favid") > 0) {
                //Todo change
                $(this).parents('.bxfavlistentry').fadeOut('slow', function () {
                    $(this).remove();
                });

                bxRemoveFavEntry($(this).data("favid"));
            }
            return false;
        });

    }



});

// TYPOSCRIPT:

function saveFavorite(favValues, parentNode) {
    try {
        var save = {
            no_cache: 1,
            type: 99998,
            format: 'json',
            tx_favoriten_pi1: favValues
        };
        save.tx_favoriten_pi1.type = save.type;
        save.tx_favoriten_pi1.format = save.format;
        save.tx_favoriten_pi1.action = 'create';
        save.tx_favoriten_pi1.controller = 'Favoriten';

        var $tree = $('#bxfavfolderselecttree');

        $.ajax({
            cache: false,
            url: 'index.php',
            data: save,
            dataType: 'json',
            method: 'GET',
            contentType: 'application/javascript',
            //			url: 'index.php?type=99998&format=json&no_cache=1&tx_favoriten_pi1[type]=99998&tx_favoriten_pi1[format]=json&tx_favoriten_pi1[action]=create&tx_favoriten_pi1[controller]=Favoriten',
            //			method: 'POST',
            //			contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            success: function (data, textStatus, jqXHR) {
                /**
                 *  @param headline string 
                 *  @param content string 
                 *  @param type string (warning|info|success|error) specifies color and icon 
                 * 	@param loader if true loading bar indicates fading time of the infobox
                 */
                var lang = bxpageconfll || {};
                var content = lang.addfavsuccess || 'Favorit wurde hinzugefügt.';
                if (lang.favoriteslink != undefined && lang.favoritesroot != undefined) {
                    content += "<br><a class='bxtoastlink' href='" + lang.favoriteslink + "'>" + lang.favoritesroot + "</a>";
                }
                bxTriggerToast('', content, 'success', false);

                $tree.tree('destroy');
                bxHideModalBox();
                return;

                data.node = data.node || null;
                data.node = (data.node === null) ? (data.values || null) : (data.node);

                data.node.name = data.node.name || null;
                data.node.name = (data.node.name === null) ? (data.node.title || null) : (data.node.name);
                data.node.name = (data.node.name === null) ? (data.node.titel || null) : (data.node.name);

                //				$tree.tree('appendNode', data.node, parentNode);

                /**
                				$tree.tree('appendNode', {
                					id: nodeID, 
                					name: (data.node.name || (data.node.title || (data.node.value1 || data.node.favValue1))), 
                					title: (data.node.name || (data.node.title || (data.node.value1 || data.node.favValue1))), 
                					type: data.node.favType || data.node.type, 
                					favType: data.node.favType || data.node.type, 
                					parentID: parentNode.id || 0, 
                					position: data.node.position || 0
                				}, parentNode);
                **/
            },
            error: function (jqXHR, textStatus, errorThrown) {
                /**
                 *  @param headline string 
                 *  @param content string 
                 *  @param type string (warning|info|success|error) specifies color and icon 
                 * 	@param loader if true loading bar indicates fading time of the infobox
                 */
                var lang = bxpageconfll || {};
                var content = lang.addfaverror || 'Favorit konnte nicht hinzugefügt werden.';
                bxTriggerToast('', content, 'error', false);
            }
        });
    } catch (ex) {
        console.log({
            'saveFavorite': ex
        });
    }
};

function setFavEventListener(saveValues) {
    try {
        var saveValues = saveValues || window.saveFavValue;
        // @todo action show button [save|create]
        $('#save-fav-item').unbind('click');
        $('#save-fav-item').click(function (e) {
            var saveFavValue = this.saveFavValue;

            var lang = bxpageconfll || {};
            var content = lang.labelfavcreate || 'Titel des Favoriten'; // @todo BXW-1039

            var title = saveFavValue.title || null;
            title = (title === null) ? (saveFavValue.titel || null) : (title);
            title = (title === null) ? (saveFavValue.name || null) : (title);
            title = (title === null) ? (saveFavValue.value1 || null) : (title);
            title = (title === null) ? (saveFavValue.favValue1 || null) : (title);
            if ((favName = window.prompt(content, title)) === null) {
                e.preventDefault();
                return;
            }
            e.preventDefault();

            var $tree = $('#bxfavfolderselecttree');
            var parentNode = $tree.tree('getSelectedNode');
            parentNode = parentNode || null;
            if (parentNode === null) {
                parentNode = $tree.tree('getNodeById', 0);
            }

            var saveValues = saveFavValue;
            saveValues.name = favName;
            saveValues.title = favName;
            //			saveValues.value1 = favName;
            //			saveValues.favValue1 = favName;
            saveValues.parentID = parentNode.id || 0;
            saveValues.position = null;
            saveFavorite(saveValues, parentNode);
            return;
        }.bind({
            saveFavValue: saveValues
        }));

        $('#create-fav-folder').unbind('click');
        $('#create-fav-folder').click(function (e) {
            var saveFavValue = this.saveFavValue;
            //			var saveFavValue = window.saveFavValue;

            var lang = bxpageconfll || {};
            var content = lang.fav_tree_newfolder || "Ordner hinzufügen"; // @todo
            if ((folderName = window.prompt(content)) === null) {
                e.preventDefault();
                return;
            }
            e.preventDefault();

            $tree = $('#bxfavfolderselecttree');

            var parentNode = $tree.tree('getSelectedNode');
            parentNode = parentNode || null;
            if (parentNode === null) {
                parentNode = $tree.tree('getNodeById', 0);
                parentNode.id = 0;
            }

            var folderValues = {
                type: 99998,
                format: 'json',
                no_cache: 1,
                tx_favoriten_pi1: {
                    type: 99998,
                    format: 'json',
                    action: 'create',
                    controller: 'Favoriten',
                    name: folderName,
                    title: folderName,
                    //					value1: folderName, 
                    //					favValue1: folderName, 
                    type: 'FOLDER',
                    favType: 'FOLDER',
                    parentID: parentNode.id || 0,
                    position: null
                }
            };

            $.ajax({
                cache: false,
                url: 'index.php',
                data: folderValues,
                dataType: 'json',
                method: 'GET',
                contentType: 'application/javascript',
                //				url: 'index.php?type=99998&format=json&no_cache=1&tx_favoriten_pi1[type]=99998&tx_favoriten_pi1[format]=json&tx_favoriten_pi1[action]=create&tx_favoriten_pi1[controller]=Favoriten',
                //				method: 'POST',
                //				contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
                success: function (data, textStatus, jqXHR) {
                    data.node = data.node || null;
                    data.node = (data.node === null) ? (data.values || null) : (data.node);

                    var parentID = data.node.parentID || null;
                    parentID = (parentID === null) ? (data.node.parent_id || null) : (parentID);
                    parentID = (parentID === null) ? (data.node.parentId || null) : (parentID);
                    if (parentID === null) {
                        parentID = 0;
                    }
                    parentID = (typeof parentID == 'number' || /^\d+$/.test(parentID)) ? (parseInt(parentID)) : (0);

                    var parentNode = $tree.tree('getNodeById', parentID);

                    var nodeID = data.node.id;
                    nodeID = parseInt(nodeID);
                    data.node.name = data.node.name || null;
                    data.node.name = data.node.name || data.node.title;
                    data.node.name = (data.node.name === null) ? (data.node.titel || null) : (data.node.name);
                    $tree.tree('appendNode', data.node, parentNode);
                    $tree.tree('openNode', parentNode);
                    return;

                    var title = saveFavValue.title || null;
                    title = (title === null) ? (saveFavValue.titel || null) : (title);
                    title = (title === null) ? (saveFavValue.name || null) : (title);
                    title = (title === null) ? (saveFavValue.value1 || null) : (title);
                    title = (title === null) ? (saveFavValue.favValue1 || null) : (title);
                    title = title || '';
                    var lang = bxpageconfll || {};
                    var content = lang.addtofavorites || "Favorit hinzufügen"; // @todo
                    if ((favName = window.prompt(content, title)) === null) {
                        return;
                    }

                    parentNode = $tree.tree('getNodeById', nodeID);

                    var saveValues = saveFavValue;
                    saveValues.name = favName;
                    saveValues.title = favName;
                    //					saveValues.value1 = favName;
                    //					saveValues.favValue1 = favName;
                    //					saveValues.favValue2 = null;
                    //					saveValues.favValue3 = null;
                    saveValues.parentID = parentNode.id || 0;
                    saveValues.position = null;
                    saveFavorite(saveValues, parentNode);
                    return;
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    /**
                     *  @param headline string 
                     *  @param content string 
                     *  @param type string (warning|info|success|error) specifies color and icon 
                     * 	@param loader if true loading bar indicates fading time of the infobox
                     */
                    bxTriggerToast('', '', 'error', false);
                }
            });
        }.bind({
            saveFavValue: saveValues
        }));
    } catch (ex) {
        console.log({
            'setFavEventListener': ex
        });
    }
};

function bxAddFavEntryHandler(eventNode) {
    if (typeof bxuserconf != "undefined" && bxuserconf != null && bxuserconf["login"]) {

        try {
            var blankTitle = document.getElementsByTagName('title')[0].text.trim();
            //		blankTitle = blankTitle.replace(/[&amp;]/, '');
            var saveValues = {};
            if (window.saveFavValue === undefined) {
                //page values
                saveValues = {
                    format: 'json',
                    title: document.getElementsByTagName('title')[0].text.trim(),
                    value1: document.location.href,
                    value2: null,
                    value3: null,
                    favType: 'URL',
                    parentID: null,
                    position: null
                };
            } else {
                //global var driven values
                saveValues = window.saveFavValue;
            }
        } catch (ex) {
            console.log({
                'ex.bxAddFavEntryHandler(1)': ex
            });
        }

        try {
            if ($(eventNode).data("favtype") && $(eventNode).data("favvalue1")) {
                saveValues = {};
                if ($(eventNode).data("favtype") && $(eventNode).data("favtype") != "") {
                    saveValues.favType = $(eventNode).data("favtype").toString().trim();
                }
                if ($(eventNode).data("favtitle") && $(eventNode).data("favtitle") != "") {
                    saveValues.title = $(eventNode).data("favtitle").toString().trim();
                }
                if ($(eventNode).data("favvalue1") && $(eventNode).data("favvalue1") != "") {
                    saveValues.value1 = $(eventNode).data("favvalue1").toString().trim();
                }
                if ($(eventNode).data("favvalue2") && $(eventNode).data("favvalue2") != "") {
                    saveValues.value2 = $(eventNode).data("favvalue2").toString().trim();
                }
                if ($(eventNode).data("favvalue3") && $(eventNode).data("favvalue3") != "") {
                    saveValues.value3 = $(eventNode).data("favvalue3").toString().trim();
                }
                if ($(eventNode).data("parentid") && $(eventNode).data("parentid") != "") {
                    saveValues.parentID = $(eventNode).data("parentid").toString().trim();
                }
                if ($(eventNode).data("position") && $(eventNode).data("position") != "") {
                    saveValues.position = $(eventNode).data("position").toString().trim();
                }
            }
        } catch (ex) {
            console.log({
                'ex.bxAddFavEntryHandler(2)': ex
            });
        }

        var parentID = null;
        if (saveValues.parentID !== undefined) {
            if (typeof saveValues.parentID == 'number') {
                parentID = saveValues.parentID;
            }
            if (/^\d+$/.test(saveValues.parentID)) {
                parentID = saveValues.parentID;
                parentID = parseInt(parentID);
            }
        }
        saveValues.parentID = parentID;
        saveValues.parentID = null;

        var position = null;
        if (saveValues.position !== undefined) {
            if (typeof saveValues.position == 'number') {
                position = saveValues.position;
            }
            if (/^\d+$/.test(saveValues.position)) {
                position = saveValues.position;
                position = parseInt(position);
            }
        }
        saveValues.position = position;
        saveValues.position = null;

        var lang = bxpageconfll || {};
        var contentSaveItem = lang.buttonfavcreate || "Weiter"; // @todo BXW-1039
        var contentCreateFolder = lang.fav_tree_newfolder || "Ordner hinzufügen"; // @todo BXW-1039
        var contentHeadline = lang.addfavtreenote || "In welchem Ordner möchten Sie den neuen Eintrag ablegen?";

        var modalContent = "";
        modalContent += "<div>";
        modalContent += "<p>" + contentHeadline + "</p>";
        modalContent += "<div id='bxfavfolderselecttree' class='text-center'>";
        modalContent += "<i class='fa fa-circle-o-notch fa-spin fa-3x fa-fw margin-bottom'></i>";
        modalContent += "</div>";
        modalContent += "<br />";
        modalContent += "<br />";
        modalContent += "<div id='action-fav-item' class='col-lg-11'>";
        modalContent += "<div id='create-fav-folder' class='btn btn-default'>" + contentCreateFolder + "</div>";
        modalContent += "<div id='save-fav-item' class='float-right btn btn-default'>" + contentSaveItem + "</div>";
        modalContent += "</div>";
        modalContent += "<br />";
        modalContent += "<br />";
        modalContent += "</div>";

        var rootNodeName = bxpageconfll.favoritesroot || 'Meine Favoriten'; // @todo
        var $tree = null;

        $.ajax({
            cache: false,
            url: 'index.php',
            data: {
                no_cache: 1,
                type: 99998,
                format: 'json',
                tx_favoriten_pi1: {
                    type: 99998,
                    format: 'json',
                    action: 'tree',
                    controller: 'Favoriten'
                }
            },
            method: 'GET',
            dataType: 'json',
            contentType: 'application/javascript',
            //		url: 'index.php?type=99998&format=json&no_cache=1&tx_favoriten_pi1[type]=99998&tx_favoriten_pi1[format]=json&tx_favoriten_pi1[action]=tree&tx_favoriten_pi1[controller]=Favoriten',
            //		contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            success: function (data, textStatus, jqXHR) {
                bxSetAndShowModalBox(modalContent);

                var data = data || {
                    nodes: []
                };
                var treeNodes = [{
                    id: 0,
                    name: rootNodeName,
                    title: rootNodeName,
                    type: 'FOLDER',
                    favType: 'FOLDER',
                    children: data.nodes || []
                }];

                $tree = $('#bxfavfolderselecttree');
                $tree.tree({
                    autoOpen: true,
                    autoEscape: false,
                    selectable: true,
                    dragAndDrop: false,
                    useContextMenu: false,
                    showEmptyFolder: true,
                    data: treeNodes
                });

                $tree.on('tree.click', function (event) {
                    var node = event.node || {
                        type: null,
                        favType: null
                    };
                    var type = node.type || null;
                    type = (type === null) ? (node.favType || null) : (type);
                    if (type === null || (type !== null && type != 'FOLDER')) {
                        return;
                    }
                });
                setFavEventListener(saveValues);
            },
            error: function (jqXHR, textStatus, errorThrown) {
                bxSetAndShowModalBox(modalContent);

                $tree = $('#bxfavfolderselecttree');
                $tree.tree({
                    autoOpen: true,
                    autoEscape: false,
                    selectable: true,
                    dragAndDrop: false,
                    useContextMenu: false,
                    showEmptyFolder: true,
                    data: [{
                        id: 0,
                        name: rootNodeName,
                        title: rootNodeName,
                        type: 'FOLDER',
                        favType: 'FOLDER',
                        children: []
                    }]
                });

                $tree.on('tree.click', function (event) {
                    var node = event.node || {
                        type: null,
                        favType: null
                    };
                    var type = node.type || null;
                    type = (type === null) ? (node.favType || null) : (type);
                    if (type === null || (type !== null && type != 'FOLDER')) {
                        return;
                    }
                });
                setFavEventListener(saveValues);
            }
        });



    } else {
        //login hint 
        var tfavloginhint = "";
        if (typeof bxpageconfll !== 'undefined') {
            tfavloginhint = "<h4>" + bxpageconfll["pleaselogin"] + "</h4><p>" + bxpageconfll["favoritesloginhint"] + "</p>";
        } else {
            tfavloginhint = "<h4>Bitte einloggen / Please login</h4>";
        }
        bxSetAndShowModalBox(tfavloginhint);
        tfavloginhint = null;
    }



};


/*	bxAddFavEntry
 *	trigger Adding process for favorites by FavObject
 */
function bxAddFavEntry(favDataObj) {
    if (typeof bxuserconf != "undefined" && bxuserconf != null && bxuserconf["login"]) {
        if (favDataObj) {
            if (typeof favDataObj["tx_favoriten_pi1"]["favType"] !== 'undefined') {
                bxAjaxTriggerFavEntry(favDataObj, "create")
            }
        }
    } else {
        //login hint 
        var tfavloginhint = "";
        if (typeof bxpageconfll !== 'undefined') {
            tfavloginhint = "<h4>" + bxpageconfll["pleaselogin"] + "</h4><p>" + bxpageconfll["favoritesloginhint"] + "</p>";
        } else {
            tfavloginhint = "<h4>Bitte einloggen / Please login</h4>";
        }
        bxSetAndShowModalBox(tfavloginhint);
        tfavloginhint = null;
    }

}

/*	bxPrivSendFavAjaxCall
 *  perform delete or create fav action
 */
function bxPrivSendFavAjaxCall(favDataObj, tactsuccess, tacterror, callbacksuccess, callbackerror) {
    favDataObj.format = 'json';
    favDataObj.controller = 'Favoriten';
    favDataObj.tx_favoriten_pi1.format = 'json';
    favDataObj.tx_favoriten_pi1.controller = 'Favoriten';
    $.ajax({
        method: 'GET',
        data: favDataObj,
        dataType: 'json',
        contentType: 'application/javascript',
        url: 'index.php',
        success: function (data, textStatus, jqXHR) {
            if (data.success == false) {
                bxTriggerToast("", tacterror, "error", false);
                if (callbackerror != null) {
                    callbackerror(jqXHR, textStatus, errorThrown);
                }
            } else {
                bxTriggerToast("", tactsuccess, "success", false);
                if (callbacksuccess != null) {
                    callbacksuccess(data);
                }
            }
        },
        error: function (jqXHR, textStatus, errorThrown) {
            bxTriggerToast("", tacterror, "error", false);
            if (callbackerror != null) {
                callbackerror(jqXHR, textStatus, errorThrown);
            }

        }
    });
}
//store last fav add data obj
bxLastfavDataObj = null;
/*	bxAjaxTriggerFavEntryAdd
 *  save favDataObj and
 *	request fav folder tree for user pid selection
 */
function bxAjaxTriggerFavEntryAdd(favDataObj) {
    if (typeof bxpageconfll["addfavsuccess"] !== "undefined") {
        tactsuccess = bxpageconfll["addfavsuccess"] + "<br><a class='bxtoastlink' href='" + bxpageconfll["favoriteslink"] + "'>" + bxpageconfll["favoritesroot"] + "</a>";
    } else {
        tactsuccess = "Favorit hinzugefügt!";
    }
    if (typeof bxpageconfll["addfaverror"] !== "undefined") {
        tacterror = bxpageconfll["addfaverror"];
    } else {
        tacterror = "Favorit konnte nicht hinzugefügt werden!";
    }
    if (typeof bxpageconfll["addfavtreenote"] !== "undefined") {
        tfavfoldernote = bxpageconfll["addfavtreenote"];
    } else {
        tfavfoldernote = "In welchem Ordner möchten Sie den neuen Eintrag ablegen?";
    }
    //Ask for Folder Tree		
    $.ajax({
        url: 'index.php',
        data: {
            type: 99998,
            format: 'json',
            tx_favoriten_pi1: {
                format: 'json',
                action: 'tree',
                controller: 'Favoriten'
            }
        },
        dataType: 'json',
        contentType: 'application/javascript',
        method: 'GET',
        success: function (data, textStatus, jqXHR) {
            var data = data || {};
            var treeNodes = data.nodes || [];

            if (treeNodes.length > 0) {
                /*for(var i=0;i<100;i++) {	
                	treeNodes.push( { "name": "ORDNER "+i, "title": "ORDNER "+i,"​​type": "FOLDER"});
                }*/
                treeNodesWithRoot = [{
                    "name": ((typeof bxpageconfll["favoritesroot"] !== "undefined") ? bxpageconfll["favoritesroot"] : "Meine Favoriten1"),
                    "title": ((typeof bxpageconfll["favoritesroot"] !== "undefined") ? bxpageconfll["favoritesroot"] : "Meine Favoriten"),
                    "favType": "FOLDER",
                    "id": null,
                    "children": treeNodes
                }];

                bxLastfavDataObj = favDataObj;
                bxSetAndShowModalBox("<p>" + tfavfoldernote + "</p><div id='bxfavfolderselecttree' class='text-center'><i class='fa fa-circle-o-notch fa-spin fa-3x fa-fw margin-bottom'></i></div>");
                $('#bxfavfolderselecttree').tree({
                    autoOpen: true,
                    autoEscape: false,
                    selectable: true,
                    dragAndDrop: false,
                    useContextMenu: false,
                    showEmptyFolder: true,
                    data: treeNodesWithRoot
                });
                $('#bxfavfolderselecttree').on(
                    'tree.click',
                    function (ev) {
                        ev.preventDefault();

                        try {
                            $('#bxfavfolderselecttree .jqtree-selected').removeClass('jqtree-selected');
                            $(ev.node.element).addClass('jqtree-selected');
                        } catch (e) {

                        }
                        //console.log(ev.node);
                        if (typeof ev.node.favType !== 'undefined') {
                            if (ev.node.favType == "FOLDER") {
                                if (typeof ev.node.id == 'number' || ev.node.id == null) {
                                    if (typeof bxLastfavDataObj !== 'undefined' && bxLastfavDataObj != null) {

                                        if (typeof bxLastfavDataObj["tx_favoriten_pi1"] !== 'undefined') {
                                            //console.log(favDataObj["tx_favoriten_pi1"]["parentID"]+" => "+ev.node.id);
                                            bxLastfavDataObj["tx_favoriten_pi1"]["parentID"] = ev.node.id;
                                            bxPrivSendFavAjaxCall(bxLastfavDataObj, tactsuccess, tacterror, null, null)
                                            $('#bxfavfolderselecttree').tree('destroy');
                                            bxHideModalBox();

                                        } else {
                                            console.log("Error: latest FavObj is missing tx_favoriten_pi1");
                                        }
                                    } else {
                                        console.log("Error: Application lost the latest FavObj");
                                    }
                                } else {
                                    console.log("Error: Folder ID not a number");
                                }
                            } else {
                                console.log("Error: No valid FavFolder selected.");
                            }
                        }
                    }
                );
            } else {
                //no folders yet, no selection needed
                bxPrivSendFavAjaxCall(favDataObj, tactsuccess, tacterror, null, null);
            }
        },
        error: function (jqXHR, textStatus, errorThrown) {
            //error  no folders found, use default
            bxPrivSendFavAjaxCall(favDataObj, tactsuccess, tacterror, null, null);
            console.log("bxAjaxTriggerFavEntryAdd failed " + textStatus);
        }
    });

}

/*	bxRemoveFavEntry
 *  delete fav by favid
 *	@param favid
 */
function bxRemoveFavEntry(favid) {
    //console.log("bxRemoveFavEntry");
    if (favid > 0) {
        var sendData = {
            type: 99998,
            no_cache: 1,
            format: 'json',
            tx_favoriten_pi1: {
                favID: favid,
                format: 'json',
                controller: 'Favoriten',
                action: 'delete'
            }
        };
        bxAjaxTriggerFavEntry(sendData, "delete")
    }
}
/*	bxAjaxTriggerFavEntry
 *  trigger fav delete or create action
 */
function bxAjaxTriggerFavEntry(favDataObj, favAction) {

    if (favAction == "delete" || favAction == "create") {
        var tactsuccess = "";
        var tacterror = "";

        if (favAction == "delete") {
            if (typeof bxpageconfll["removefavsuccess"] !== "undefined") {
                tactsuccess = bxpageconfll["removefavsuccess"];
            } else {
                tactsuccess = "Favorit gelöscht!";
            }
            if (typeof bxpageconfll["removefaverror"] !== "undefined") {
                tacterror = bxpageconfll["removefaverror"];
            } else {
                tacterror = "Favorit konnte nicht gelöscht werden!";
            }

            try {
                bxPrivSendFavAjaxCall(favDataObj, tactsuccess, tacterror, null, null);
                /*$.ajax({
                	method: 'GET',
                	data: favDataObj,
                	dataType: 'json',
                	contentType: 'application/javascript',
                	url: 'index.php',
                	success: function(data, textStatus, jqXHR){
                		bxTriggerToast("",tactsuccess,"success",false);
                	},
                	error: function(jqXHR, textStatus, errorThrown){
                		bxTriggerToast("",tacterror,"error",false);

                	}
                });*/
            } catch (e) {
                console.log({
                    'exception': e
                });
            }
        } else if (favAction == "create") {
            //TODO: Debug Remove...
            /*tsinfo = "<h4>Debug notice</h4><p>FAV Transaction info:</p><p>";
            tsinfo += "<b>action</b> "+favDataObj["tx_favoriten_pi1"]["action"]+"<br>";
            if(favAction=="delete") {	
            	tsinfo += "<b>favID</b> "+favDataObj["tx_favoriten_pi1"]["favID"]+"";
            } else {
            	tsinfo += "<b>favType</b> "+favDataObj["tx_favoriten_pi1"]["favType"]+"<br>";
            	tsinfo += "<b>title</b> "+favDataObj["tx_favoriten_pi1"]["favTitle"]+"<br>";
            	tsinfo += "<b>value1</b> "+favDataObj["tx_favoriten_pi1"]["favValue1"]+"<br>";
            	tsinfo += "<b>value2</b> "+favDataObj["tx_favoriten_pi1"]["favValue2"]+"<br>";
            }
            tsinfo += "</p>"
            bxTriggerToast(null,tsinfo,null,false);*/

            //console.log("parentID: "+favDataObj["tx_favoriten_pi1"]["parentID"]);
            bxAjaxTriggerFavEntryAdd(favDataObj);
        }



    } else {
        console.log("Error, unknown fav action");
    }
}



/*	bxTriggerToast
 *  show fading ui infobox 
 *  @param headline1 short headline1 
 *	 text1 infotext
 *   type (warning|info|success|error) specifies color and icon 
 * 	 loader1 if true loading bar indicates fading time of the infobox
 */
function bxTriggerToast(headline1, text1, type1, loader1) {
    if (headline1 == '') {
        headline1 = null;
    }
    if (type1 != "warning" && type1 != "info" && type1 != "success" && type1 != "error") {
        type1 = "";
    }
    if (loader1 != true) {
        loader1 = false;
    }
    var ttoastobj = {
        text: text1,
        heading: headline1,
        showHideTransition: 'slide',
        allowToastClose: true,
        hideAfter: 7000,
        stack: 5,
        position: 'top-right',
        textAlign: 'left',
        loader: loader1,
        loaderBg: '#990000'
    };
    if (type1 != "") {
        ttoastobj["icon"] = type1;
    }
    if ($.isFunction($.toast)) {
        $.toast(ttoastobj);
    }
}


/*	bxAddGetProductSeachParamtoSearch
 *  copy textvalue of element into another element
 */
function bxAddGetProductSeachParamtoSearch(formid, fieldid) {
    $('#' + formid).attr('value', $('#' + fieldid).val());
    //$('#'+formid).attr( 'action',  $("#"+formid).attr("action")+"?sword="+$('#'+fieldid).val() );
    //+"&tx_indexedsearch_pi2[search][sword]="+$('#'+fieldid).val()
    //console.log($('#'+formid).attr('action'));
}

function bxAddFieldForProductSearch(fieldsource, fieldtarget) {
    $('#' + fieldtarget).attr('value', $('#' + fieldsource).val());
}


/* bxRefreshDeliveryMethod
 */
function bxRefreshDeliveryMethod(deliverytype, deliverydetail) {
    $('.bxdeliveryselect .bxtilelink').removeClass('bxtilelinkselected');

    $('#lief_art').val(deliverytype);
    if (deliverytype == 'abholung') {
        $('#versand_ort').val(deliverydetail);
        $('#lief_ort').val('');
    } else {
        $('#versand_ort').val('');
        $('#lief_ort').val(deliverydetail);
    }
    $('#btnbasketnext').trigger("click");
    return false;
}


/* bxShowColorInformation
 show modal box with color shade information
 */
function bxShowColorOrTextureInformation(name, colorinfo, texture) {
    var cinfo = "<p>";
    var cstyle = "";
    if (name != '' && name != undefined) {
        cinfo += "<b>" + name + "</b><br />";
    }
    if (colorinfo != '' && colorinfo != undefined) {
        cstyle += "background-color:" + colorinfo + ";";
    }
    if (texture != '' && texture != 'none' && texture != undefined) {
        cstyle += "background-image:" + texture.replace(/\"/g, '') + ";";
    }
    cinfo += "</p>";
    bxSetAndShowModalBox('<p>' + cinfo + '</p><div class="bx-modal-color-field" style="' + cstyle + '">&nbsp;</div>');
}

/* bxShowColorInformation
 show modal box with color shade information
 */
function bxShowColorInformation(name, hex, rgb, cmyk, ral, hbz, pg) {

    $('.tooltip').each(function () {
        $(this).hide();
    });

    var cinfo = "<p>";
    if (name != '') {
        cinfo += "<b>" + name + "</b><br />";
    }
    if (ral != '') {
        cinfo += ral + "</b><br />";
    }
    if (rgb != '') {
        cinfo += rgb + "<br />";
    }
    if (cmyk != '') {
        cinfo += cmyk + "<br />";
    }
    if (hbz != '') {
        cinfo += hbz + "<br />";
    }
    if (pg != '') {
        cinfo += pg + "<br />";
    }
    cinfo += "</p>";
    bxSetAndShowModalBox('<p>' + cinfo + '</p><div class="bx-modal-color-field" style="background-color:' + hex + '"">&nbsp;</div>');
    return false;
}

/* bxTriggerNlSearchByTerm
 check if term is a zip or location
 fill nl search form element and submit it
 */
function bxTriggerNlSearchByTerm(term) {
    var fieldToChange = "";
    if (term.length > 2) {
        if ($.isNumeric(term)) {
            fieldToChange = "bxfooternlsearchplz";
        } else {
            fieldToChange = "bxfooternlsearchlocation";
        }
        if ($('#' + fieldToChange).length > 0) {
            $('#' + fieldToChange).val(term);
        }
        if ($('#bxfooternlsearchform').length > 0) {
            $('#bxfooternlsearchform').submit();
        }
    } else {
        //TODO: error message required?
    }
}

/* bxIncreaseOrDecreaseArticleCount
 increase or decrease helper for fields with article count
 add or decrease 1 - or if a step size value is set in a hidden field, use it
 if a minimum value is set in a hidden field, use it
 */
function bxIncreaseOrDecreaseArticleCount(inputobj, increase) {
    if (increase != false) {
        increase = true;
    }
    tval = inputobj.val().replace(",", ".") * 1;
    taddvar = 1;
    tminval = 0;
    if ($.isNumeric(tval)) {
        //stepping val
        if (inputobj.parent().children(".quantityStepSize").length > 0) {
            taddvar = inputobj.parent().children(".quantityStepSize").val() * 1;
        }
        //min val
        if (inputobj.parent().children(".minimumQuantity").length > 0) {
            tminval = inputobj.parent().children(".minimumQuantity").val() * 1;
        }
        if ($.isNumeric(taddvar)) {
            //in or decrease
            stepsPart = bxRoundArticleCount(tval - tminval);
            if (increase) {
                if (stepsPart < 0) {
                    //wert unterhalb tminval auf tminval aufrunden
                    tval = tminval;
                } else {
                    //JS Rechenoperationsprobleme auch hier problematisch
                    //Loesung, Aufrunden, multiplikation um bruchrechnung zu umgehen
                    //console.log( ((stepsPart*1000) % (taddvar*1000))+ " "+taddvar*1000);
                    //pruefung ist die eingegebene menge ausserhalb der stepsize?
                    if ((stepsPart * 1000) % (taddvar * 1000) > 0) {
                        //dann nehme naechsthoeheren wert
                        tval = (Math.ceil(stepsPart / taddvar)) * taddvar + tminval;
                    } else {
                        //sonst regulaer um einen wert erhoehen
                        tval = (Math.ceil(stepsPart / taddvar) + 1) * taddvar + tminval;
                    }

                }
            } else {
                if (stepsPart < 0) {
                    tval = 0;
                } else {
                    // JavaScript hat ein Problem bei Rechenoperationen, da die eigentliche
                    // Rechnung im binaeren Zahlensystem durchgefuehrt wird. Die (fuer den
                    // Menschen "glatten") binaeren Werte des dezimalen Zahlensystems koennen
                    // nicht immer exakt im binaeren Zahlensystem abgebildet werden. Dadurch
                    // treten weit hinter dem Komma Ungenauigkeiten auf, die zu Problem fuehren.
                    // Aus diesem Grund muss hier gerundet werden.
                    rest = bxRoundArticleCount(stepsPart % taddvar);
                    if ((rest != 0.00) && (rest != taddvar)) {
                        tval = Math.floor(stepsPart / taddvar) * taddvar + tminval;
                    } else {
                        //Rechenoperationsprobleme auch hier, round statt floor
                        tval = (Math.round(stepsPart / taddvar) - 1) * taddvar + tminval;
                    }
                }
            }

            //Round
            if (tval.toString().indexOf('.') != -1) {
                tval = bxRoundArticleCount(tval);
            }
            //check min
            if ((tminval > 0) && (tval < tminval)) {
                if (increase) {
                    tval = tminval;
                } else {
                    tval = 0;
                }
            }
            //minval broken?
            if (tval < 0) {
                tval = 0;
            }
            //Set
            inputobj.val(tval);
        }
    }
    tval = null;
    taddvar = null;
    tminval = null;
    return false;
}

/*js round: 2 digits only*/
function bxRoundArticleCount(articlecount) {
    var k = (Math.round(articlecount * 100) / 100).toString();
    k += (k.indexOf('.') == -1) ? '.00' : '00';
    return k.substring(0, k.indexOf('.') + 3);
}

function fancytitleOnly() {
    return this.title;
}

function jsfct_shop_deny_enter(event) {
    var taste = event.keyCode ? event.keyCode : event.which ? event.which : event.charCode;
    if (taste == 13) {
        return false;
    }
}

/* ==========================
 * ModalBox Functions - begin
 * ========================== */
/* 	bxSetAndShowModalBox
 *	set loading indicator into modalbox content area
 *	@todo integrate additional htmlcontent 
 */
function bxPrepareModalBoxForLoading(htmlcontent) {
    bxSetModalBox('<p class="text-center"><i class="fa fa-circle-o-notch fa-spin fa-3x fa-fw margin-bottom"></i><span class="sr-only">Loading...</span></p>');
}

/* 	bxSetAndShowModalBox
 *	set content and show modalbox
 *	@param htmlcontent 
 */
function bxSetAndShowModalBox(htmlcontent) {


    if ($("#dialog").length > 0) {
        bxSetModalBox(htmlcontent);
        bxShowModalBox();
    }
}

/* 	bxSetModalBox
 *	set modalbox html content
 *	@param htmlcontent 
 */
function bxSetModalBox(htmlcontent) {
    if ($("#dialog").length > 0) {
        // alert($('#dialog-modalbox-inner'));
        $('#dialog-modalbox-inner').html(htmlcontent);
    }
}

/* 	bxShowModalBox
 *	show modalbox
 */
function bxShowModalBox() {
    if ($("#dialog").length > 0) {
        /*$('#dialog').jqm( {
         modal : true,
         overlay : 60
         });*/
        $('#dialog').modal("show");

        //$('#dialog').jqmShow();
    }
}

/* 	bxHideModalBox
 *	hide modalbox
 */
function bxHideModalBox() {
    if ($("#dialog").length > 0) {
        //$('#dialog').jqmHide();
        $('#dialog').modal("hide");
    }
}

/* 	bxClearModalBox
 *	clear modalbox
 */
function bxClearModalBox() {
    if ($("#dialog").length > 0) {
        $('#dialog-modalbox-inner').html('');
    }
}

/* ========================
 * ModalBox Functions - end
 * ======================== */

/* 	processAjaxResult
 *	old function for bxAjaxOnlineShop interactions 
 */
function processFormData(typ, sorte, groesse, farbe, menge, farbname, flag, mengeInhalt, kollektion) {
    processFormDataExt(typ, sorte, groesse, farbe, menge, farbname, flag, mengeInhalt, kollektion, '');
}

/* 	processAjaxResult
 *	news function for bxAjaxOnlineShop interactions, supporting colorid
 */
function processFormDataExt(typ, sorte, groesse, farbe, menge, farbname, flag, mengeInhalt, kollektion, colorId) {

    var txt = '';
    bxClearModalBox();
    bxPrepareModalBoxForLoading();
    bxShowModalBox();
    // $.getJSON("/typo3conf/ext/bxonlineshop/pi1/class.tx_bxajax_pi1.php",
    // {typ: typ , sorte: sorte ,groesse: groesse ,farbe: farbe,farbname:
    // farbname,menge: menge},"processAjaxResult");

    if (parseInt(flag, 10) == 1) {
        flag = 1;
    } else {
        flag = 0;
    }
    if (typ == "addWare" && (menge == '' || isNaN(parseFloat(menge)))) {
        bxSetModalBox('Bitte geben Sie die Menge ein.');
        bxShowModalBox();
        return;
    }
    if (sorte == '' && (typ == 'addWare' || typ == 'getPrice')) {
        bxSetModalBox('Bitte wählen Sie eine Variante aus.');
        bxShowModalBox();
        return;
    } else if (farbe == '' && farbname == '' && colorId == '' && (typ == 'addWare' || typ == 'getPrice')) {
        bxSetModalBox('Bitte wählen Sie einen Farbton/eine Variante aus.');
        bxShowModalBox();
        return;
    } else if (groesse == '' && (typ == 'addWare' || typ == 'getPrice')) {
        bxSetModalBox('Bitte wählen Sie eine Größe aus.');
        bxShowModalBox();
        return;
    }
    if (typ == 'searchColor' && farbname == '') {
        bxSetModalBox('Bitte geben Sie einen Farbtonnamen an.');
        bxShowModalBox();
        return;
    }

    var ajdata = "";
    if (typ == 'addWare' || typ == 'getPrice') {
        //ajdata = {colorId: farbname, eID: "bxAjaxOnlineShop", type: typ, sorte: sorte, groesse: groesse, farbe: farbe, kollektion:kollektion, menge: menge,mengeInhalt: mengeInhalt, flag: flag};
        ajdata = {
            eID: "bxAjaxOnlineShop",
            type: typ,
            sorte: sorte,
            groesse: groesse,
            farbe: farbe,
            kollektion: kollektion,
            menge: menge,
            mengeInhalt: mengeInhalt,
            flag: flag
        };
        if (farbname != null && farbname != '') {
            ajdata.farbname = farbname;
        }
        if (colorId != null && colorId != '') {
            ajdata.colorId = colorId;
        }

    } else {
        ajdata = {
            farbname: farbname,
            eID: "bxAjaxOnlineShop",
            type: typ,
            sorte: sorte,
            groesse: groesse,
            farbe: farbe,
            kollektion: kollektion,
            menge: menge,
            mengeInhalt: mengeInhalt,
            flag: flag
        };
    }

    $.ajax({
        type: "POST",
        dataType: "json",
        scriptCharset: "utf-8",
        success: function (data, textStatus) {
            processAjaxResult(typ, data, textStatus);
        },
        error: function (data, textStatus) {
            processShopAjaxErrorResult(typ, data, textStatus);
        },
        url: "/index.php",
        cache: false,
        async: true,
        data: ajdata
    });

}

function processShopAjaxErrorResult(callTyp, data, textStatus) {
    bxSetModalBox("<div>" + data.responseText + "</div>");
}

/* 	processAjaxResult
 *	helper function, show result/refesh actions for addWare, chooseColorName, copyWare
 */
function processAjaxResult(callTyp, data, textStatus) {
    // array( 'action' => 'errorMsg', 'msg' => 'Die Artikel Nummer ist nicht
    // vollst&auml;ndig.' );
    // array( 'action' => 'show', 'msg' => $smarty->fetch(

    if (data.action == 'errorMsg') {
        bxSetModalBox("<div>" + data.msg + "</div>");
        return;
    }
    if (data.action == 'show') {
        var tmsg = data.msg;
        bxSetModalBox(tmsg);
        bxShowModalBox();
        // $("#dialogcontent").html( data.msg );
    }
    if (callTyp == "addWare" || callTyp == "chooseColorName" || callTyp == "copyWare") {
        getBasketShort();
    }

}

/* getBasketShort
 *	ajax helper function get short basket info (refresh number of basket elements)
 */
function getBasketShort() {
    $.ajax({
        type: "POST",
        dataType: "json",
        success: function (data, textStatus) {
            $('#basketsmallinfo').html(data.msg);
        },
        url: "/index.php",
        cache: false,
        async: true,
        data: {
            type: "showBasketSmall",
            eID: "bxAjaxOnlineShop"
        }
    });
}
/* getCatalogProduct
 *	ajax helper function get products by groupid (bxfarbtonsuche)
 */
function getCatalogProduct() {

    var groupId = $("#produktgruppe").options[$("#produktgruppe").selectedIndex].value;
    $.ajax({
        type: "POST",
        dataType: "json",
        scriptCharset: "utf-8",
        success: function (data, textStatus) {
            processAjaxResult(typ, data, textStatus)
        },
        url: "/typo3conf/ext/bxfarbtonsuche/pi1/class.tx_bxajax_pi1.php",
        cache: false,
        async: true,
        data: {
            groupId: groupId
        }
    });
}
/* loadButton
 * 
 */
function loadButton() {
    var tmp;
    $("#submitButton div").hide();
    $("#submitButton").append("<img  src=\"/fileadmin/v1/img/bx-loader-big.gif\"> ");
    return true;
}
/* bxSwitchContainers
 *	change visibility of two elements
 *	@params 
 *	hideContainer - element to hide
 *	showContainer - element to show
 */
function bxSwitchContainers(hideContainer, showContainer) {
    $(hideContainer).hide();
    $(showContainer).show();
    return true;
}

/* initBxCompareSlider
 * trigger function for twentytwenty slider element
 * configuration -> see dce39
 */
function initBxCompareSlider(sliderid, sliderdirection, initialsliderpos) {
    if (typeof $('#' + sliderid).twentytwenty === "function") {
        $('#' + sliderid).twentytwenty({
            "default_offset_pct": initialsliderpos,
            orientation: sliderdirection,
            before_label: '',
            after_label: '',
            no_overlay: true,
            move_with_handle_only: false,
            click_to_move: false
        });
    } else {
        //console.log("Framework missing");		
    }
}

/* dce45*/
//global google map styling
bxdceMapStyleOption = [{
        "featureType": "administrative",
        "elementType": "labels.text.fill",
        "stylers": [{
            "color": "#444444"
        }]
    },
    {
        "featureType": "landscape",
        "elementType": "all",
        "stylers": [{
            "color": "#f2f2f2"
        }]
    },
    {
        "featureType": "poi",
        "elementType": "all",
        "stylers": [{
            "visibility": "off"
        }]
    },
    {
        "featureType": "poi",
        "elementType": "labels.text",
        "stylers": [{
            "visibility": "off"
        }]
    },
    {
        "featureType": "road",
        "elementType": "all",
        "stylers": [{
            "saturation": -100
        }, {
            "lightness": 45
        }]
    },
    {
        "featureType": "road.highway",
        "elementType": "all",
        "stylers": [{
            "visibility": "simplified"
        }]
    },
    {
        "featureType": "road.arterial",
        "elementType": "labels.icon",
        "stylers": [{
            "visibility": "off"
        }]
    },
    {
        "featureType": "transit",
        "elementType": "all",
        "stylers": [{
            "visibility": "off"
        }]
    },
    {
        "featureType": "water",
        "elementType": "all",
        "stylers": [{
            "color": "#cccccc"
        }, {
            "visibility": "on"
        }]
    }
];

/* renderBxDceMap
 * create google map element within given container id
 * dce45
 */
function renderBxDceMap(mapuid) {
    if (mapuid > 0) {
        tmapObj = $('#bxbdamap' + mapuid);
        tlistObj = $('#bxbdamappoilist' + mapuid);
        tdceMapConf = new Array();
        tdceMapConf["zoom"] = tmapObj.data("zoom");
        tdceMapConf["lat"] = tmapObj.data("lat");
        tdceMapConf["lng"] = tmapObj.data("lng");
        tdceMapConf["needle"] = tmapObj.data("poicon")
        tdceMapConf["uid"] = mapuid;
        if (!tdceMapConf["lat"]) {
            tdceMapConf["lat"] = 51.1642292;
        }
        if (!tdceMapConf["lng"]) {
            tdceMapConf["lng"] = 10.4541194;
        }
        if (!tdceMapConf["zoom"]) {
            tdceMapConf["zoom"] = 6;
        }

        tc = 0;
        tdceMapMarkerArray = new Array();
        tlistObj.find(".bxdcemappoi").each(function (i) {
            //todo do not read twice
            if ($(this).data("lat") && $(this).data("lng") && $(this).data("title")) {
                tdceMapMarkerArray[tc] = new Array();
                tdceMapMarkerArray[tc]["title"] = $(this).data("title");
                tdceMapMarkerArray[tc]["lat"] = $(this).data("lat");
                tdceMapMarkerArray[tc]["lng"] = $(this).data("lng");
                tc++;
            }
        });

        var bxdcemapOptions = {
            center: new google.maps.LatLng(tdceMapConf["lat"], tdceMapConf["lng"]),
            zoom: tdceMapConf["zoom"],
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            disableDefaultUI: true,
            zoomControl: true,
            mapTypeControl: false,
            scaleControl: true,
            streetViewControl: false,
            rotateControl: true,
            fullscreenControl: true,
            styles: bxdceMapStyleOption
        };

        bxdcemap = new google.maps.Map(document.getElementById("bxbdamap" + mapuid), bxdcemapOptions);
        $('#bxbdamap' + mapuid).css("height", "650");
        infowindow = new google.maps.InfoWindow({
            content: "",
            maxWidth: 300
        });
        var isIE11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));
        var bxdceneedle = {
            url: isIE11 ? 'fileadmin/template/brillux.de/css/images/icons/bx-standort-icon-rot.png' : 'fileadmin/template/brillux.de/css/images/icons/bx-standort-icon-rot.svg',
            scaledSize: new google.maps.Size(28.197, 42.852843)
        };
        if (tdceMapConf["needle"].indexOf(".png") > 0) {
            bxdceneedle.url = tdceMapConf["needle"];
        }

        gmarkerArray = new Array();
        for (var i = 0; i < tdceMapMarkerArray.length; i++) {
            gmarkerArray[i] = new google.maps.Marker({
                icon: bxdceneedle,
                position: new google.maps.LatLng(tdceMapMarkerArray[i]["lat"], tdceMapMarkerArray[i]["lng"]),
                map: bxdcemap,
                title: tdceMapMarkerArray[i]["title"]
            });
            gmarkerArray[i].info = new google.maps.InfoWindow({
                content: getBXDceMapPoiInfo(mapuid + "-" + i)
            });
            google.maps.event.addListener(gmarkerArray[i], 'click', function () {
                infowindow.setContent(this.info.content);
                infowindow.open(bxdcemap, this)
            });
        }
        google.maps.event.trigger(bxdcemap, 'resize');
    } else {
        console.log("Error: No valid content uid");
    }
}
/* getBXDceMapPoiInfo
 * read html from html element by given id 
 * helper function for dce45
 * @param poiUid uid of dom element
 */
function getBXDceMapPoiInfo(poiUid) {
    rhtml = "";
    if ($('#bxbdamappoi' + poiUid).length) {
        rhtml += $('#bxbdamappoi' + poiUid).html();
    }
    return rhtml;
}
/* setColorName
 * helper function bx shop, set color information 
 */
function setColorName(color, size, colorName, collection, rgb, minSize, colorId, texture) {
    changeTypOnClick('FMIX');
    $('#bxordercolorsearchterm').val(colorName);
    setSearchColorInfoLine(collection, colorName, rgb, texture);
    setFSColorId(colorId);
    setFSColorCollection(collection);
    setMinSize(minSize);
    changeActiveColor(color);
    //sb4910 fssuche must not change size!
    //changeActiveSize( size );
}
/* removeLoginTypeUriParam
 * helper function remove logintype=login, logintype=logout from URL 
 * @param uri 
 */
function removeLoginTypeUriParam(uri) {
    return uri.replace(/([&?]logintype=(login|logout)$|logintype=(login|logout)&|[?&]logintype=(login|logout)(?=#))/, '');
}


/*! 
 * Master Slider – Responsive Touch Swipe Slider
 * Copyright © 2017 All Rights Reserved. 
 *
 * @author Averta [www.averta.net]
 * @version 2.51.2
 * @date Jun 2017
 */


/* ================== bin-debug/js/pro/tools/base.js =================== */
window.averta = {};

;
(function ($) {

    //"use strict";

    window.package = function (name) {
        if (!window[name]) window[name] = {};
    };

    var extend = function (target, object) {
        for (var key in object) target[key] = object[key];
    };

    Function.prototype.extend = function (superclass) {
        if (typeof superclass.prototype.constructor === "function") {
            extend(this.prototype, superclass.prototype);
            this.prototype.constructor = this;
        } else {
            this.prototype.extend(superclass);
            this.prototype.constructor = this;
        }
    };

    // Converts JS prefix to CSS prefix
    var trans = {
        'Moz': '-moz-',
        'Webkit': '-webkit-',
        'Khtml': '-khtml-',
        'O': '-o-',
        'ms': '-ms-',
        'Icab': '-icab-'
    };

    window._mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    window._touch = 'ontouchstart' in document;
    $(document).ready(function () {
        window._jcsspfx = getVendorPrefix(); // JS CSS VendorPrefix
        window._csspfx = trans[window._jcsspfx]; // CSS VendorPrefix
        window._cssanim = supportsTransitions();
        window._css3d = supports3DTransforms();
        window._css2d = supportsTransforms();
    });


    // Thanks to LEA VEROU
    // http://lea.verou.me/2009/02/find-the-vendor-prefix-of-the-current-browser/
    function getVendorPrefix() {

        if ('result' in arguments.callee) return arguments.callee.result;

        var regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;

        var someScript = document.getElementsByTagName('script')[0];

        for (var prop in someScript.style) {
            if (regex.test(prop)) {
                return arguments.callee.result = prop.match(regex)[0];
            }
        }

        if ('WebkitOpacity' in someScript.style) return arguments.callee.result = 'Webkit';
        if ('KhtmlOpacity' in someScript.style) return arguments.callee.result = 'Khtml';

        return arguments.callee.result = '';
    }


    // Thanks to Steven Benner.
    // http://stevenbenner.com/2010/03/javascript-regex-trick-parse-a-query-string-into-an-object/
    window.parseQueryString = function (url) {
        var queryString = {};
        url.replace(
            new RegExp("([^?=&]+)(=([^&]*))?", "g"),
            function ($0, $1, $2, $3) {
                queryString[$1] = $3;
            }
        );

        return queryString;
    };

    function checkStyleValue(prop) {
        var b = document.body || document.documentElement;
        var s = b.style;
        var p = prop;
        if (typeof s[p] == 'string') {
            return true;
        }

        // Tests for vendor specific prop
        v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'],
            p = p.charAt(0).toUpperCase() + p.substr(1);
        for (var i = 0; i < v.length; i++) {
            if (typeof s[v[i] + p] == 'string') {
                return true;
            }
        }
        return false;
    }

    function supportsTransitions() {
        return checkStyleValue('transition');
    }

    function supportsTransforms() {
        return checkStyleValue('transform');
    }

    function supports3DTransforms() {
        if (!supportsTransforms()) return false;
        var el = document.createElement('i'),
            has3d,
            transforms = {
                'WebkitTransform': '-webkit-transform',
                'OTransform': '-o-transform',
                'MSTransform': '-ms-transform',
                'msTransform': '-ms-transform',
                'MozTransform': '-moz-transform',
                'Transform': 'transform',
                'transform': 'transform'
            };

        el.style.display = 'block';

        // Add it to the body to get the computed style
        document.body.insertBefore(el, null);

        for (var t in transforms) {
            if (el.style[t] !== undefined) {
                el.style[t] = 'translate3d(1px,1px,1px)';
                has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
            }
        }

        document.body.removeChild(el);

        return (has3d != null && has3d.length > 0 && has3d !== "none");
    }

    /**
     * Provides requestAnimationFrame in a cross browser way.
     * @author paulirish / http://paulirish.com/
     */
    var fps60 = 50 / 3;

    if (!window.requestAnimationFrame) {

        window.requestAnimationFrame = (function () {

            return window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function ( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {

                    window.setTimeout(callback, fps60);

                };

        })();

    }

    if (!window.getComputedStyle) {
        window.getComputedStyle = function (el, pseudo) {
            this.el = el;
            this.getPropertyValue = function (prop) {
                var re = /(\-([a-z]){1})/g;
                if (prop == 'float') prop = 'styleFloat';
                if (re.test(prop)) {
                    prop = prop.replace(re, function () {
                        return arguments[2].toUpperCase();
                    });
                }
                return el.currentStyle[prop] ? el.currentStyle[prop] : null;
            };
            return el.currentStyle;
        };
    }

    // IE8 Array indexOf fix
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (elt /*, from*/ ) {
            var len = this.length >>> 0;

            var from = Number(arguments[1]) || 0;
            from = (from < 0) ?
                Math.ceil(from) :
                Math.floor(from);
            if (from < 0)
                from += len;

            for (; from < len; from++) {
                if (from in this &&
                    this[from] === elt)
                    return from;
            }
            return -1;
        };
    }


    /**
     * check ie browser
     * @param  {Number | string}  version
     * @return {Boolean}
     */
    window.isMSIE = function (version) {
        if (!$.browser.msie) {
            return false;
        } else if (!version) {
            return true;
        }
        var ieVer = $.browser.version.slice(0, $.browser.version.indexOf('.'));
        if (typeof version === 'string') {
            if (version.indexOf('<') !== -1 || version.indexOf('>') !== -1) {
                return eval(ieVer + version);
            } else {
                return eval(version + '==' + ieVer);
            }
        } else {
            return version == ieVer;
        }
    }

    $.removeDataAttrs = function ($target, exclude) {
        var i,
            attrName,
            dataAttrsToDelete = [],
            dataAttrs = $target[0].attributes,
            dataAttrsLen = dataAttrs.length;

        exclude = exclude || [];

        // loop through attributes and make a list of those
        // that begin with 'data-'
        for (i = 0; i < dataAttrsLen; i++) {
            attrName = dataAttrs[i].name;
            if ('data-' === attrName.substring(0, 5) && exclude.indexOf(attrName) === -1) {
                // Why don't you just delete the attributes here?
                // Deleting an attribute changes the indices of the
                // others wreaking havoc on the loop we are inside
                // b/c dataAttrs is a NamedNodeMap (not an array or obj)
                dataAttrsToDelete.push(dataAttrs[i].name);
            }
        }
        // delete each of the attributes we found above
        // i.e. those that start with "data-"
        $.each(dataAttrsToDelete, function (index, attrName) {
            $target.removeAttr(attrName);
        })
    };

    if (jQuery) {
        $.jqLoadFix = function () {
            if (this.complete) {
                var that = this;
                setTimeout(function () {
                    $(that).trigger('load');
                }, 1);
            }
        };

        jQuery.uaMatch = jQuery.uaMatch || function (ua) {
            ua = ua.toLowerCase();

            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
                /(webkit)[ \/]([\w.]+)/.exec(ua) ||
                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
                /(msie) ([\w.]+)/.exec(ua) ||
                ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];

            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };

        // Don't clobber any existing jQuery.browser in case it's different
        //if ( !jQuery.browser ) {
        matched = jQuery.uaMatch(navigator.userAgent);
        browser = {};

        if (matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }

        // Chrome is Webkit, but Webkit is also Safari.
        if (browser.chrome) {
            browser.webkit = true;
        } else if (browser.webkit) {
            browser.safari = true;
        }

        // hofix for IE11 detection
        var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
        if (isIE11) {
            browser.msie = "true";
            delete browser.mozilla;
        }

        jQuery.browser = browser;

        //}

        $.fn.preloadImg = function (src, _event) {
            this.each(function () {
                var $this = $(this);
                var self = this;
                var img = new Image();
                img.onload = function (event) {
                    if (event == null) event = {}; // IE8
                    $this.attr('src', src);
                    event.width = img.width;
                    event.height = img.height;
                    $this.data('width', img.width);
                    $this.data('height', img.height);
                    setTimeout(function () {
                        _event.call(self, event);
                    }, 50);
                    img = null;
                };
                img.src = src;
            });
            return this;
        };
    }
})(jQuery);

/* ================== bin-debug/js/pro/tools/EventDispatcher.js =================== */
;
(function () {

    "use strict";

    averta.EventDispatcher = function () {
        this.listeners = {};
    };

    averta.EventDispatcher.extend = function (_proto) {
        var instance = new averta.EventDispatcher();
        for (var key in instance)
            if (key != 'constructor') _proto[key] = averta.EventDispatcher.prototype[key];
    };

    averta.EventDispatcher.prototype = {

        constructor: averta.EventDispatcher,

        addEventListener: function (event, listener, ref) {
            if (!this.listeners[event]) this.listeners[event] = [];
            this.listeners[event].push({
                listener: listener,
                ref: ref
            });

        },

        removeEventListener: function (event, listener, ref) {
            if (this.listeners[event]) {

                for (var i = 0; i < this.listeners[event].length; ++i) {

                    if (listener === this.listeners[event][i].listener && ref === this.listeners[event][i].ref) {
                        this.listeners[event].splice(i--, 1);
                    }
                }

                if (this.listeners[event].length === 0) {
                    this.listeners[event] = null;
                }
            }
        },

        dispatchEvent: function (event) {
            event.target = this;
            if (this.listeners[event.type]) {
                for (var i = 0, l = this.listeners[event.type].length; i < l; ++i) {
                    this.listeners[event.type][i].listener.call(this.listeners[event.type][i].ref, event);
                }
            }
        }
    };

})();

/* ================== bin-debug/js/pro/tools/TouchSwipe.js =================== */
;
(function ($) {

    "use strict";

    var isTouch = 'ontouchstart' in document,
        isPointer = window.navigator.pointerEnabled,
        isMSPoiner = !isPointer && window.navigator.msPointerEnabled,
        usePointer = isPointer || isMSPoiner,
        // Events
        ev_start = (isPointer ? 'pointerdown ' : '') + (isMSPoiner ? 'MSPointerDown ' : '') + (isTouch ? 'touchstart ' : '') + 'mousedown',
        ev_move = (isPointer ? 'pointermove ' : '') + (isMSPoiner ? 'MSPointerMove ' : '') + (isTouch ? 'touchmove ' : '') + 'mousemove',
        ev_end = (isPointer ? 'pointerup ' : '') + (isMSPoiner ? 'MSPointerUp ' : '') + (isTouch ? 'touchend ' : '') + 'mouseup',
        ev_cancel = (isPointer ? 'pointercancel ' : '') + (isMSPoiner ? 'MSPointerCancel ' : '') + 'touchcancel';


    averta.TouchSwipe = function ($element) {
        this.$element = $element;
        this.enabled = true;

        $element.bind(ev_start, {
            target: this
        }, this.__touchStart);

        $element[0].swipe = this;

        this.onSwipe = null;
        this.swipeType = 'horizontal';
        this.noSwipeSelector = 'input, textarea, button, .no-swipe, .ms-no-swipe';

        this.lastStatus = {};

    };

    var p = averta.TouchSwipe.prototype;

    /*-------------- METHODS --------------*/

    p.getDirection = function (new_x, new_y) {
        switch (this.swipeType) {
            case 'horizontal':
                return new_x <= this.start_x ? 'left' : 'right';
                break;
            case 'vertical':
                return new_y <= this.start_y ? 'up' : 'down';
                break;
            case 'all':
                if (Math.abs(new_x - this.start_x) > Math.abs(new_y - this.start_y))
                    return new_x <= this.start_x ? 'left' : 'right';
                else
                    return new_y <= this.start_y ? 'up' : 'down';
                break;
        }
    };

    p.priventDefultEvent = function (new_x, new_y) {
        //if(this.priventEvt != null) return this.priventEvt;
        var dx = Math.abs(new_x - this.start_x);
        var dy = Math.abs(new_y - this.start_y);

        var horiz = dx > dy;

        return (this.swipeType === 'horizontal' && horiz) ||
            (this.swipeType === 'vertical' && !horiz);

        //return this.priventEvt;
    };

    p.createStatusObject = function (evt) {
        var status_data = {},
            temp_x, temp_y;

        temp_x = this.lastStatus.distanceX || 0;
        temp_y = this.lastStatus.distanceY || 0;

        status_data.distanceX = evt.pageX - this.start_x;
        status_data.distanceY = evt.pageY - this.start_y;
        status_data.moveX = status_data.distanceX - temp_x;
        status_data.moveY = status_data.distanceY - temp_y;

        status_data.distance = parseInt(Math.sqrt(Math.pow(status_data.distanceX, 2) + Math.pow(status_data.distanceY, 2)));

        status_data.duration = new Date().getTime() - this.start_time;
        status_data.direction = this.getDirection(evt.pageX, evt.pageY);

        return status_data;
    };


    p.__reset = function (event, jqevt) {
        this.reset = false;
        this.lastStatus = {};
        this.start_time = new Date().getTime();

        var point = this.__getPoint(event, jqevt);
        this.start_x = point.pageX;
        this.start_y = point.pageY;
    };

    p.__touchStart = function (event) {

        var swipe = event.data.target;
        var jqevt = event;
        if (!swipe.enabled) return;

        if ($(event.target).closest(swipe.noSwipeSelector, swipe.$element).length > 0) {
            return;
        }

        event = event.originalEvent;

        if (usePointer) {
            $(this).css('-ms-touch-action', swipe.swipeType === 'horizontal' ? 'pan-y' : 'pan-x');
        }

        if (!swipe.onSwipe) {
            $.error('Swipe listener is undefined');
            return;
        }

        // don't catch the touch start again, also don't go further if the delay between touchstart and mousedown is small
        // if ( swipe.touchStarted ) {
        if (swipe.touchStarted || isTouch && swipe.start_time && event.type === 'mousedown' && new Date().getTime() - swipe.start_time < 600) {
            return;
        }

        var point = swipe.__getPoint(event, jqevt);
        swipe.start_x = point.pageX;
        swipe.start_y = point.pageY;

        swipe.start_time = new Date().getTime();

        $(document).bind(ev_end, {
            target: swipe
        }, swipe.__touchEnd).
        bind(ev_move, {
            target: swipe
        }, swipe.__touchMove).
        bind(ev_cancel, {
            target: swipe
        }, swipe.__touchCancel);

        var status = swipe.createStatusObject(point);
        status.phase = 'start';

        swipe.onSwipe.call(null, status);

        if (!isTouch)
            jqevt.preventDefault();

        swipe.lastStatus = status;
        swipe.touchStarted = true;
    };

    p.__touchMove = function (event) {
        var swipe = event.data.target;
        var jqevt = event;
        event = event.originalEvent;

        if (!swipe.touchStarted) return;

        clearTimeout(swipe.timo);
        swipe.timo = setTimeout(function () {
            swipe.__reset(event, jqevt);
        }, 60);

        var point = swipe.__getPoint(event, jqevt);

        var status = swipe.createStatusObject(point);

        if (swipe.priventDefultEvent(point.pageX, point.pageY))
            jqevt.preventDefault();

        status.phase = 'move';

        //if(swipe.lastStatus.direction !== status.direction) swipe.__reset(event , jqevt);

        swipe.lastStatus = status;

        swipe.onSwipe.call(null, status);
    };

    p.__touchEnd = function (event) {

        var swipe = event.data.target;
        var jqevt = event;
        event = event.originalEvent;

        clearTimeout(swipe.timo);

        var status = swipe.lastStatus;

        if (!isTouch)
            jqevt.preventDefault();

        status.phase = 'end';

        swipe.touchStarted = false;
        swipe.priventEvt = null;

        $(document).unbind(ev_end, swipe.__touchEnd).
        unbind(ev_move, swipe.__touchMove).
        unbind(ev_cancel, swipe.__touchCancel);

        status.speed = status.distance / status.duration;

        swipe.onSwipe.call(null, status);

    };

    p.__touchCancel = function (event) {
        var swipe = event.data.target;
        swipe.__touchEnd(event);
    };

    p.__getPoint = function (event, jqEvent) {
        if (isTouch && event.type.indexOf('mouse') === -1) {
            return event.touches[0];
        } else if (usePointer) {
            return event;
        } else {
            return jqEvent;
        }
    };

    p.enable = function () {
        if (this.enabled) return;
        this.enabled = true;
    };

    p.disable = function () {
        if (!this.enabled) return;
        this.enabled = false;
    };

})(jQuery);

/* ================== bin-debug/js/pro/tools/Timer.js =================== */
/**
 * 	Ticker Class
 * 	Author: Averta Ltd
 */

;
(function () {
    "use strict";

    averta.Ticker = function () {};

    var st = averta.Ticker,
        list = [],
        len = 0,
        __stopped = true;

    st.add = function (listener, ref) {
        list.push([listener, ref]);

        if (list.length === 1) st.start();
        len = list.length;
        return len;
    };

    st.remove = function (listener, ref) {
        for (var i = 0, l = list.length; i < l; ++i) {
            if (list[i] && list[i][0] === listener && list[i][1] === ref) {
                list.splice(i, 1);
            }
        }

        len = list.length;

        if (len === 0) {
            st.stop();
        }
    };

    st.start = function () {
        if (!__stopped) return;
        __stopped = false;
        __tick();
    };

    st.stop = function () {
        __stopped = true;
    };

    var __tick = function () {
        if (st.__stopped) return;
        var item;
        for (var i = 0; i !== len; i++) {
            item = list[i];
            item[0].call(item[1]);
        }

        requestAnimationFrame(__tick);
    };

})();

/**
 * 	Timer Class
 * 	Author: Averta Ltd
 */
;
(function () {
    "use strict";

    if (!Date.now) {
        Date.now = function () {
            return new Date().getTime();
        };
    }

    averta.Timer = function (delay, autoStart) {
        this.delay = delay;
        this.currentCount = 0;
        this.paused = false;
        this.onTimer = null;
        this.refrence = null;

        if (autoStart) this.start();

    };

    averta.Timer.prototype = {

        constructor: averta.Timer,

        start: function () {
            this.paused = false;
            this.lastTime = Date.now();
            averta.Ticker.add(this.update, this);
        },

        stop: function () {
            this.paused = true;
            averta.Ticker.remove(this.update, this);
        },

        reset: function () {
            this.currentCount = 0;
            this.paused = true;
            this.lastTime = Date.now();
        },

        update: function () {
            if (this.paused || Date.now() - this.lastTime < this.delay) return;
            this.currentCount++;
            this.lastTime = Date.now();
            if (this.onTimer)
                this.onTimer.call(this.refrence, this.getTime());

        },

        getTime: function () {
            return this.delay * this.currentCount;
        }

    };
})();

/* ================== bin-debug/js/pro/tools/CSSTweener.js =================== */
;
(function () {

    "use strict";

    var evt = null;

    window.CSSTween = function (element, duration, delay, ease) {

        this.$element = element;
        this.duration = duration || 1000;
        this.delay = delay || 0;
        this.ease = ease || 'linear';

        /*if(!evt){
        	if(window._jcsspfx === 'O')
        		evt = 'otransitionend';
        	else if(window._jcsspfx == 'Webkit')
        		evt = 'webkitTransitionEnd';
        	else
        		evt = 'transitionend' ;
        }*/

    };

    var p = CSSTween.prototype;

    /*-------------- METHODS --------------*/

    p.to = function (callback, target) {
        this.to_cb = callback;
        this.to_cb_target = target;

        return this;
    };

    p.from = function (callback, target) {
        this.fr_cb = callback;
        this.fr_cb_target = target;

        return this;
    };

    p.onComplete = function (callback, target) {
        this.oc_fb = callback;
        this.oc_fb_target = target;

        return this;
    };

    p.chain = function (csstween) {
        this.chained_tween = csstween;
        return this;
    };

    p.reset = function () {
        //element.removeEventListener(evt , this.onTransComplete , true);
        clearTimeout(this.start_to);
        clearTimeout(this.end_to);
    };

    p.start = function () {
        var element = this.$element[0];

        clearTimeout(this.start_to);
        clearTimeout(this.end_to);

        this.fresh = true;

        if (this.fr_cb) {
            element.style[window._jcsspfx + 'TransitionDuration'] = '0ms';
            this.fr_cb.call(this.fr_cb_target);
        }

        var that = this;

        this.onTransComplete = function (event) {

            if (!that.fresh) return;

            //that.$element[0].removeEventListener(evt , this.onTransComplete, true);
            //event.stopPropagation();


            that.reset();

            element.style[window._jcsspfx + 'TransitionDuration'] = '';
            element.style[window._jcsspfx + 'TransitionProperty'] = '';
            element.style[window._jcsspfx + 'TransitionTimingFunction'] = '';
            element.style[window._jcsspfx + 'TransitionDelay'] = '';

            that.fresh = false;
            if (that.chained_tween) that.chained_tween.start();
            if (that.oc_fb) that.oc_fb.call(that.oc_fb_target);

        };

        this.start_to = setTimeout(function () {
            if (!that.$element) return;
            element.style[window._jcsspfx + 'TransitionDuration'] = that.duration + 'ms';
            element.style[window._jcsspfx + 'TransitionProperty'] = that.transProperty || 'all';

            if (that.delay > 0) element.style[window._jcsspfx + 'TransitionDelay'] = that.delay + 'ms';
            else element.style[window._jcsspfx + 'TransitionDelay'] = '';

            element.style[window._jcsspfx + 'TransitionTimingFunction'] = that.ease;

            if (that.to_cb) that.to_cb.call(that.to_cb_target);

            //that.$element[0].addEventListener(evt , that.onTransComplete , true );

            that.end_to = setTimeout(function () {
                that.onTransComplete();
            }, that.duration + (that.delay || 0));
        }, 1);

        return this;
    };

})();

/**
 *	Cross Tween Class
 */
;
(function () {

    "use strict";

    var _cssanim = null;
    window.CTween = {};

    function transPos(element, properties) {
        if (properties.x !== undefined || properties.y !== undefined) {
            if (_cssanim) {
                var trans = window._jcsspfx + "Transform";
                if (properties.x !== undefined) {
                    properties[trans] = (properties[trans] || '') + ' translateX(' + properties.x + 'px)';
                    delete properties.x;
                }

                if (properties.y !== undefined) {
                    properties[trans] = (properties[trans] || '') + ' translateY(' + properties.y + 'px)';
                    delete properties.y;
                }
            } else {
                if (properties.x !== undefined) {
                    var posx = element.css('right') !== 'auto' ? 'right' : 'left';
                    //if(!element[0].bx) element[0].bx = parseInt(element.css(posx));
                    properties[posx] = /*element[0].bx + */ properties.x + 'px';
                    delete properties.x;
                }

                if (properties.y !== undefined) {
                    var posy = element.css('bottom') !== 'auto' ? 'bottom' : 'top';
                    //if(!element[0].by) element[0].by = parseInt(element.css(posy));
                    properties[posy] = /*element[0].by + */ properties.y + 'px';
                    delete properties.y;
                }
            }
        }
        return properties;
    }

    CTween.setPos = function (element, pos) {
        element.css(transPos(element, pos));
    };

    CTween.animate = function (element, duration, properties, options) {
        if (_cssanim == null) _cssanim = window._cssanim;

        options = options || {};

        transPos(element, properties);

        if (_cssanim) {
            var tween = new CSSTween(element, duration, options.delay, EaseDic[options.ease]);
            if (options.transProperty) {
                tween.transProperty = options.transProperty;
            }
            tween.to(function () {
                element.css(properties);
            });
            if (options.complete) tween.onComplete(options.complete, options.target);
            tween.start();
            tween.stop = tween.reset;
            return tween;
        }

        var onCl;

        if (options.delay) element.delay(options.delay);
        if (options.complete)
            onCl = function () {
                options.complete.call(options.target);
            };

        element.stop(true).animate(properties, duration, options.ease || 'linear', onCl);

        return element;
    };

    CTween.fadeOut = function (target, duration, remove) {
        var options = {};
        if (remove === true) {
            options.complete = function () {
                target.remove();
            };
        } else if (remove === 2) {
            options.complete = function () {
                target.css('display', 'none');
            };
        }

        CTween.animate(target, duration || 1000, {
            opacity: 0
        }, options);
    };

    CTween.fadeIn = function (target, duration, reset) {
        if (reset !== false) {
            target.css('opacity', 0).css('display', '');
        }

        CTween.animate(target, duration || 1000, {
            opacity: 1
        });
    };

})();

;
(function () {

    // Thanks to matthewlein
    // https://github.com/matthewlein/Ceaser

    window.EaseDic = {
        'linear': 'linear',
        'ease': 'ease',
        'easeIn': 'ease-in',
        'easeOut': 'ease-out',
        'easeInOut': 'ease-in-out',

        'easeInCubic': 'cubic-bezier(.55,.055,.675,.19)',
        'easeOutCubic': 'cubic-bezier(.215,.61,.355,1)',
        'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
        'easeInCirc': 'cubic-bezier(.6,.04,.98,.335)',
        'easeOutCirc': 'cubic-bezier(.075,.82,.165,1)',
        'easeInOutCirc': 'cubic-bezier(.785,.135,.15,.86)',
        'easeInExpo': 'cubic-bezier(.95,.05,.795,.035)',
        'easeOutExpo': 'cubic-bezier(.19,1,.22,1)',
        'easeInOutExpo': 'cubic-bezier(1,0,0,1)',
        'easeInQuad': 'cubic-bezier(.55,.085,.68,.53)',
        'easeOutQuad': 'cubic-bezier(.25,.46,.45,.94)',
        'easeInOutQuad': 'cubic-bezier(.455,.03,.515,.955)',
        'easeInQuart': 'cubic-bezier(.895,.03,.685,.22)',
        'easeOutQuart': 'cubic-bezier(.165,.84,.44,1)',
        'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
        'easeInQuint': 'cubic-bezier(.755,.05,.855,.06)',
        'easeOutQuint': 'cubic-bezier(.23,1,.32,1)',
        'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
        'easeInSine': 'cubic-bezier(.47,0,.745,.715)',
        'easeOutSine': 'cubic-bezier(.39,.575,.565,1)',
        'easeInOutSine': 'cubic-bezier(.445,.05,.55,.95)',
        'easeInBack': 'cubic-bezier(.6,-.28,.735,.045)',
        'easeOutBack': 'cubic-bezier(.175, .885,.32,1.275)',
        'easeInOutBack': 'cubic-bezier(.68,-.55,.265,1.55)'
    };
})();

/* ================== bin-debug/js/pro/tools/Aligner.js =================== */
;
(function () {

    "use strict";

    window.MSAligner = function (type, $container, $img) {

        this.$container = $container;
        this.$img = $img;

        this.type = type || 'stretch'; // fill , fit , stretch , tile , center

        this.widthOnly = false;
        this.heightOnly = false;
    };

    var p = MSAligner.prototype;

    /*-------------- METHODS --------------*/

    p.init = function (w, h) {

        this.baseWidth = w;
        this.baseHeight = h;
        this.imgRatio = w / h;
        this.imgRatio2 = h / w;

        switch (this.type) {
            case 'tile':
                this.$container.css('background-image', 'url(' + this.$img.attr('src') + ')');
                this.$img.remove();
                break;
            case 'center':
                this.$container.css('background-image', 'url(' + this.$img.attr('src') + ')');
                this.$container.css({
                    backgroundPosition: 'center center',
                    backgroundRepeat: 'no-repeat'
                });
                this.$img.remove();
                break;
            case 'stretch':
                this.$img.css({
                    width: '100%',
                    height: '100%'
                });
                break;
            case 'fill':
            case 'fit':
                this.needAlign = true;
                this.align();
                break;
        }

    };

    p.align = function () {
        if (!this.needAlign) return;

        var cont_w = this.$container[0].offsetWidth;
        var cont_h = this.$container[0].offsetHeight;

        var contRatio = cont_w / cont_h;

        if (this.type == 'fill') {
            if (this.imgRatio < contRatio) {
                this.$img.width(cont_w);
                this.$img.height(cont_w * this.imgRatio2);
            } else {
                this.$img.height(cont_h);
                this.$img.width(cont_h * this.imgRatio);
            }

        } else if (this.type == 'fit') {

            if (this.imgRatio < contRatio) {
                this.$img.height(cont_h);
                this.$img.width(cont_h * this.imgRatio);
            } else {
                this.$img.width(cont_w);
                this.$img.height(cont_w * this.imgRatio2);
            }
        }

        this.setMargin();

    };

    p.setMargin = function () {

        var cont_w = this.$container[0].offsetWidth;
        var cont_h = this.$container[0].offsetHeight;

        this.$img.css('margin-top', (cont_h - this.$img[0].offsetHeight) / 2 + 'px');
        this.$img.css('margin-left', (cont_w - this.$img[0].offsetWidth) / 2 + 'px');
    }

})();

/* ================== bin-debug/js/pro/tools/pointer-events-polyfill.js =================== */
/**
 * CSS pointer-events polyfill
 * Adds support for `pointer-events: none;` for browsers not supporting this property
 * Requires jQuery@~1.9
 *
 * @copyright Sebastian Langer 2016
 * @license MIT
 * @author Sebastian Langer <sl@scn.cx>
 */
(function ($) {
    /**
     * Polyfill main-method
     * @param  {object} userOptions override default options
     */
    var Polyfill = function (userOptions) {
        this.options = $.extend({}, Polyfill.defaultOptions, userOptions);

        this.isEnabled = false;

        if (this.options.forcePolyfill || !this.supportsPointerEvents()) {
            this.registerEvents();
            this.isEnabled = true;
        }
    };

    Polyfill.defaultOptions = {
        forcePolyfill: false,
        selector: '*',
        listenOn: ['click', 'dblclick', 'mousedown', 'mouseup'],
        pointerEventsNoneClass: null,
        pointerEventsAllClass: null,
        eventNamespace: 'pointer-events-polyfill'
    };

    /**
     * registers events needed for the polyfill to work properly
     */
    Polyfill.prototype.registerEvents = function () {
        $(document).on(this.getEventNames(), this.options.selector, $.proxy(this.onElementClick, this));
    };

    /**
     * get all events as a jquery-compatible event string
     * @return {String} namespaced jquery-events
     */
    Polyfill.prototype.getEventNames = function () {
        var eventNamespace = this.options.eventNamespace ? '.' + this.options.eventNamespace : '';
        return this.options.listenOn.join(eventNamespace + ' ') + eventNamespace;
    };

    /**
     * detects support for css pointer-events
     * stolen from modernizr - https://github.com/Modernizr/Modernizr/blob/1f8af59/feature-detects/css/pointerevents.js
     * @return {boolean} indicates support
     */
    Polyfill.prototype.supportsPointerEvents = function () {
        var style = document.createElement('a').style;
        style.cssText = 'pointer-events:auto';
        return style.pointerEvents === 'auto';
    };

    /**
     * recursively checks parent nodes if they have a pointer-events css-property
     * @param  {jQuery} $el element to test
     * @return {boolean}    indicates click-through-ability of the given element
     */
    Polyfill.prototype.isClickThrough = function ($el) {
        var elPointerEventsCss = $el.css('pointer-events');
        if ($el.length === 0 || elPointerEventsCss === 'all' || $el.is(':root') || $el.hasClass(this.options.pointerEventsAllClass)) {
            return false;
        }
        if (elPointerEventsCss === 'none' || $el.hasClass(this.options.pointerEventsNoneClass) || this.isClickThrough($el.parent())) {
            return true;
        }
        return false;
    };

    /**
     * proxies click-through to underlying element if necessary
     * @param  {Event} e click-event
     * @return {boolean} preventDefault
     */
    Polyfill.prototype.onElementClick = function (e) {
        var $elOrg = $(e.target);

        if (!this.isClickThrough($elOrg)) {
            return true;
        }

        // retrieve element below the clicked one
        $elOrg.hide();
        var elBelow = document.elementFromPoint(e.clientX, e.clientY);

        // trigger the original element on the one below
        e.target = elBelow;
        $(elBelow).trigger(e);

        // open links
        if (elBelow.tagName === 'A') {
            // middle click (sometimes the browser blocks it as popup)
            if (e.which === 2) {
                window.open(elBelow.getAttribute('href'), '_blank');
            } else {
                elBelow.click();
            }
        }

        // restore clicked element
        $elOrg.show();

        return false;
    };

    /**
     * destroys the plugin - removes listeners and data
     */
    Polyfill.prototype.destroy = function () {
        $(document).off(this.getEventNames());
        this.isEnabled = false;
    };

    /**
     * make polyfill available globally
     * @param  {object} userOptions override default options
     * @return {Polyfill}           polyfill-object
     */
    window.pointerEventsPolyfill = function (userOptions) {
        return new Polyfill(userOptions);
    };
})(jQuery);

/* ================== bin-debug/js/pro/controls/controller.js =================== */
/**
 *  Touch List Control
 * 	version 1.1.2
 * 	
 * 	Copyright (C) 2014, Averta Ltd. All rights reserved. 	 	
 */

;
(function () {

    "use strict";

    var _options = {
        bouncing: true,
        snapping: false,
        snapsize: null,
        friction: 0.05,
        outFriction: 0.05,
        outAcceleration: 0.09,
        minValidDist: 0.3,
        snappingMinSpeed: 2,
        paging: false,
        endless: false,
        maxSpeed: 160
    };


    var Controller = function (min, max, options) {

        if (max === null || min === null) {
            throw new Error('Max and Min values are required.');
        }

        this.options = options || {};

        for (var key in _options) {
            if (!(key in this.options))
                this.options[key] = _options[key];
        }

        this._max_value = max;
        this._min_value = min;

        this.value = min;
        this.end_loc = min;

        this.current_snap = this.getSnapNum(min);

        this.__extrStep = 0;
        this.__extraMove = 0;

        this.__animID = -1;

    };

    var p = Controller.prototype;

    /*
    ---------------------------------------------------
    	PUBLIC METHODS
    ----------------------------------------------------
    */


    p.changeTo = function (value, animate, speed, snap_num, dispatch) {
        this.stopped = false;
        this._internalStop();
        value = this._checkLimits(value);
        speed = Math.abs(speed || 0);

        if (this.options.snapping) {
            snap_num = snap_num || this.getSnapNum(value);
            if (dispatch !== false) this._callsnapChange(snap_num);
            this.current_snap = snap_num;
        }

        if (animate) {
            this.animating = true;

            var self = this,
                active_id = ++self.__animID,
                amplitude = value - self.value,
                timeStep = 0,
                targetPosition = value,
                animFrict = 1 - self.options.friction,
                timeconst = animFrict + (speed - 20) * animFrict * 1.3 / self.options.maxSpeed;

            var tick = function () {

                if (active_id !== self.__animID) return;

                var dis = value - self.value;

                if (Math.abs(dis) > self.options.minValidDist && self.animating) {
                    window.requestAnimationFrame(tick);
                } else {

                    if (self.animating) {
                        self.value = value;
                        self._callrenderer();
                    }

                    self.animating = false;

                    if (active_id !== self.__animID) {
                        self.__animID = -1;
                    }

                    self._callonComplete('anim');

                    return;
                }

                //self.value += dis * timeconst
                self.value = targetPosition - amplitude * Math.exp(- ++timeStep * timeconst);

                self._callrenderer();
            };

            tick();

            return;
        }

        this.value = value;
        this._callrenderer();
    };

    p.drag = function (move) {

        if (this.start_drag) {
            this.drag_start_loc = this.value;
            this.start_drag = false;
        }

        this.animating = false;
        this._deceleration = false;

        this.value -= move;

        if (!this.options.endless && (this.value > this._max_value || this.value < 0)) {
            if (this.options.bouncing) {
                this.__isout = true;
                this.value += move * 0.6;
            } else if (this.value > this._max_value) {
                this.value = this._max_value;
            } else {
                this.value = 0;
            }
        } else if (!this.options.endless && this.options.bouncing) {
            this.__isout = false;
        }

        this._callrenderer();

    };

    p.push = function (speed) {
        this.stopped = false;
        if (this.options.snapping && Math.abs(speed) <= this.options.snappingMinSpeed) {
            this.cancel();
            return;
        }

        this.__speed = speed;
        this.__startSpeed = speed;

        this.end_loc = this._calculateEnd();

        if (this.options.snapping) {

            var snap_loc = this.getSnapNum(this.value),
                end_snap = this.getSnapNum(this.end_loc);

            if (this.options.paging) {
                snap_loc = this.getSnapNum(this.drag_start_loc);

                this.__isout = false;
                if (speed > 0) {
                    this.gotoSnap(snap_loc + 1, true, speed);
                } else {
                    this.gotoSnap(snap_loc - 1, true, speed);
                }
                return;
            } else if (snap_loc === end_snap) {
                this.cancel();
                return;
            }

            this._callsnapChange(end_snap);
            this.current_snap = end_snap;

        }

        this.animating = false;

        this.__needsSnap = this.options.endless || (this.end_loc > this._min_value && this.end_loc < this._max_value);

        if (this.options.snapping && this.__needsSnap)
            this.__extraMove = this._calculateExtraMove(this.end_loc);


        this._startDecelaration();
    };

    p.bounce = function (speed) {
        if (this.animating) return;
        this.stopped = false;
        this.animating = false;

        this.__speed = speed;
        this.__startSpeed = speed;

        this.end_loc = this._calculateEnd();

        //if(this.options.paging){}

        this._startDecelaration();
    };

    p.stop = function () {
        this.stopped = true;
        this._internalStop();
    };

    p.cancel = function () {
        this.start_drag = true; // reset flag for next drag
        if (this.__isout) {
            this.__speed = 0.0004;
            this._startDecelaration();
        } else if (this.options.snapping) {
            this.gotoSnap(this.getSnapNum(this.value), true);
        }

    };

    p.renderCallback = function (listener, ref) {
        this.__renderHook = {
            fun: listener,
            ref: ref
        };
    };

    p.snappingCallback = function (listener, ref) {
        this.__snapHook = {
            fun: listener,
            ref: ref
        };
    };

    p.snapCompleteCallback = function (listener, ref) {
        this.__compHook = {
            fun: listener,
            ref: ref
        };
    };

    p.getSnapNum = function (value) {
        return Math.floor((value + this.options.snapsize / 2) / this.options.snapsize);
    };

    p.nextSnap = function () {
        this._internalStop();

        var curr_snap = this.getSnapNum(this.value);

        if (!this.options.endless && (curr_snap + 1) * this.options.snapsize > this._max_value) {
            this.__speed = 8;
            this.__needsSnap = false;
            this._startDecelaration();
        } else {
            this.gotoSnap(curr_snap + 1, true);
        }

    };

    p.prevSnap = function () {
        this._internalStop();

        var curr_snap = this.getSnapNum(this.value);

        if (!this.options.endless && (curr_snap - 1) * this.options.snapsize < this._min_value) {
            this.__speed = -8;
            this.__needsSnap = false;
            this._startDecelaration();
        } else {
            this.gotoSnap(curr_snap - 1, true);
        }

    };

    p.gotoSnap = function (snap_num, animate, speed) {
        this.changeTo(snap_num * this.options.snapsize, animate, speed, snap_num);
    };

    p.destroy = function () {
        this._internalStop();
        this.__renderHook = null;
        this.__snapHook = null;
        this.__compHook = null;
    };

    /*
    ---------------------------------------------------
    	PRIVATE METHODS
    ----------------------------------------------------
    */

    p._internalStop = function () {
        this.start_drag = true; // reset flag for next drag
        this.animating = false;
        this._deceleration = false;
        this.__extrStep = 0;
    };

    p._calculateExtraMove = function (value) {
        var m = value % this.options.snapsize;
        return m < this.options.snapsize / 2 ? -m : this.options.snapsize - m;
    };

    p._calculateEnd = function (step) {
        var temp_speed = this.__speed;
        var temp_value = this.value;
        var i = 0;
        while (Math.abs(temp_speed) > this.options.minValidDist) {
            temp_value += temp_speed;
            temp_speed *= this.options.friction;
            i++;
        }
        if (step) return i;
        return temp_value;
    };

    p._checkLimits = function (value) {
        if (this.options.endless) return value;
        if (value < this._min_value) return this._min_value;
        if (value > this._max_value) return this._max_value;
        return value;
    };

    p._callrenderer = function () {
        if (this.__renderHook) this.__renderHook.fun.call(this.__renderHook.ref, this, this.value);
    };

    p._callsnapChange = function (targetSnap) {
        if (!this.__snapHook || targetSnap === this.current_snap) return;
        this.__snapHook.fun.call(this.__snapHook.ref, this, targetSnap, targetSnap - this.current_snap);
    };

    p._callonComplete = function (type) {
        if (this.__compHook && !this.stopped) {
            this.__compHook.fun.call(this.__compHook.ref, this, this.current_snap, type);
        }

    };

    p._computeDeceleration = function () {

        if (this.options.snapping && this.__needsSnap) {
            var xtr_move = (this.__startSpeed - this.__speed) / this.__startSpeed * this.__extraMove;
            this.value += this.__speed + xtr_move - this.__extrStep;
            this.__extrStep = xtr_move;
        } else {
            this.value += this.__speed;
        }

        this.__speed *= this.options.friction; //* 10;

        if (!this.options.endless && !this.options.bouncing) {
            if (this.value <= this._min_value) {
                this.value = this._min_value;
                this.__speed = 0;
            } else if (this.value >= this._max_value) {
                this.value = this._max_value;
                this.__speed = 0;
            }
        }

        this._callrenderer();

        if (!this.options.endless && this.options.bouncing) {

            var out_value = 0;

            if (this.value < this._min_value) {
                out_value = this._min_value - this.value;
            } else if (this.value > this._max_value) {
                out_value = this._max_value - this.value;
            }

            this.__isout = Math.abs(out_value) >= this.options.minValidDist;

            if (this.__isout) {
                if (this.__speed * out_value <= 0) {
                    this.__speed += out_value * this.options.outFriction;
                } else {
                    this.__speed = out_value * this.options.outAcceleration;
                }
            }
        }
    };

    p._startDecelaration = function () {
        if (this._deceleration) return;
        this._deceleration = true;

        var self = this;

        var tick = function () {

            if (!self._deceleration) return;

            self._computeDeceleration();

            if (Math.abs(self.__speed) > self.options.minValidDist || self.__isout) {
                window.requestAnimationFrame(tick);
            } else {
                self._deceleration = false;
                self.__isout = false;

                if (self.__needsSnap && self.options.snapping && !self.options.paging) {
                    self.value = self._checkLimits(self.end_loc + self.__extraMove);
                } else {
                    self.value = Math.round(self.value);
                }

                self._callrenderer();
                self._callonComplete('decel');
            }
        };

        tick();
    };

    window.Controller = Controller;

})();

/* ================== bin-debug/js/pro/layers/LayerController.js =================== */
/**
 * Master Slider Layer Controller
 * @author averta
 * @package Master Slider jQuery PRO
 * @since 2.11.1
 */
;
(function (window, document, $) {

    /**
     * Layer Controller constructor
     * @param {MSSlide} slide layer controller's slide.
     */
    window.MSLayerController = function (slide) {
        this.slide = slide;
        this.slider = slide.slider;
        this.layers = [];
        this.layersCount = 0;
        this.preloadCount = 0;
        this.$layers = $('<div></div>').addClass('ms-slide-layers');
        this.$staticLayers = $('<div></div>').addClass('ms-static-layers');
        this.$fixedLayers = $('<div></div>').addClass('ms-fixed-layers');
        this.$animLayers = $('<div></div>').addClass('ms-anim-layers');

    };

    var p = MSLayerController.prototype;


    /*-----------------------------------------*\
    	Public Methods
    \*-----------------------------------------*/

    /**
     * Adds new layer to the controller and slide
     * @param {MSLayerElement} layer
     */
    p.addLayer = function (layer) {
        layer.slide = this.slide;
        layer.controller = this;

        // append layer element to the layers container based on `data-position` attribute.
        switch (layer.$element.data('position')) {
            case 'static':
                this.hasStaticLayer = true;
                layer.$element.appendTo(this.$staticLayers);
                break;
            case 'fixed':
                this.hasFixedLayer = true;
                layer.$element.appendTo(this.$fixedLayers);
                break;
            default:
                layer.$element.appendTo(this.$animLayers);
                break;
        }

        layer.create();
        this.layers.push(layer);
        this.layersCount++;

        // @since 1.7.0
        if (layer.parallax) {
            this.hasParallaxLayer = true;
        }

        if (layer.needPreload) {
            this.preloadCount++;
        }
    };

    /**
     * add layers over slide
     * it calls after addLayer
     */
    p.create = function () {
        this.slide.$element.append(this.$layers);
        this.$layers.append(this.$animLayers);

        if (this.hasStaticLayer) {
            this.$layers.append(this.$staticLayers);
        }

        if (this.slider.options.layersMode == 'center') {
            this.$layers.css('max-width', this.slider.options.width + 'px');

            if (this.hasFixedLayer) {
                this.$fixedLayers.css('max-width', this.slider.options.width + 'px');
            }
        }
    };

    /**
     * load layers that requires preloading
     * @param {Function} callback onload callback function
     */
    p.loadLayers = function (callback) {
        this._onReadyCallback = callback;

        if (this.preloadCount === 0) {
            this._onlayersReady();
            return;
        }

        for (var i = 0; i !== this.layersCount; ++i) {
            if (this.layers[i].needPreload) {
                this.layers[i].loadImage();
            }
        }
    };

    /**
     * prepare layers to show over slide, this method will be called via `prepareToSelect` method of slide.
     */
    p.prepareToShow = function () {
        if (this.hasParallaxLayer) {
            this._enableParallaxEffect();
        }

        if (this.hasFixedLayer) {
            this.$fixedLayers.prependTo(this.slide.view.$element);
        }
    };

    /**
     * show layers over slide
     */
    p.showLayers = function () {
        if (this.layersHideTween) {
            this.layersHideTween.stop(true);
        }

        if (this.fixedLayersHideTween) {
            this.fixedLayersHideTween.stop(true);
        }

        this._resetLayers();
        this.$animLayers.css('opacity', '').css('display', '');

        if (this.hasFixedLayer) {
            this.$fixedLayers.css('opacity', '').css('display', '');
        }

        if (this.ready) {
            this._initLayers();
            this._locateLayers();
            this._startLayers();
        }
    };

    /**
     * hideLayers this method will be called via slide class.
     */
    p.hideLayers = function () {

        if (this.slide.selected || this.slider.options.instantStartLayers) {
            var that = this;
            that.layersHideTween = CTween.animate(this.$animLayers, 500, {
                opacity: 0
            }, {
                complete: function () {
                    that._resetLayers();
                }
            });

            if (this.hasFixedLayer) {
                this.fixedLayersHideTween = CTween.animate(this.$fixedLayers, 500, {
                    opacity: 0
                }, {
                    complete: function () {
                        that.$fixedLayers.detach();
                    }
                });
            }

            // disables parallax effect
            // @since 1.6.0
            if (this.hasParallaxLayer) {
                this._disableParallaxEffect();
            }
        }
    };

    /**
     * hide layers from slide
     */
    p.animHideLayers = function () {
        if (!this.ready) {
            return;
        }

        for (var i = 0; i !== this.layersCount; ++i) {
            this.layers[i].hide();
        }
    };

    /**
     * calculate new size of layers containers and locate layers
     * @param {Number} width  slider width
     * @param {Number} height slider height
     * @param {Boolean} hard  whether call init layers.
     */
    p.setSize = function (width, height, hard) {

        if (this.ready && (this.slide.selected || this.hasStaticLayer)) {
            if (hard) {
                this._initLayers(true);
            }
            this._locateLayers(!this.slide.selected);
        }

        if (this.slider.options.autoHeight) {
            this.updateHeight();
        }

        if (this.slider.options.layersMode == 'center') {
            var left = Math.max(0, (width - this.slider.options.width) / 2) + 'px';
            this.$layers[0].style.left = left;
            this.$fixedLayers[0].style.left = left;
        }

    };

    /**
     * updates layers container height
     */
    p.updateHeight = function () {
        // var h = this.slide.getHeight() + 'px';
        // this.$layers[0].style.height = h;
        // this.$fixedLayers[0].style.height = h;
    };

    /**
     * This method will be called by the last layer after loading all of layers.
     */
    p._onlayersReady = function () {
        this.ready = true;

        if (this.hasStaticLayer && !this.slide.isSleeping) {
            this._initLayers(false, true);
        }

        this._onReadyCallback.call(this.slide);
    };

    /**
     * this method will be called by slide when it starts sleeping
     */
    p.onSlideSleep = function () {

    };

    /**
     * this method will be called by slide after waking up
     */
    p.onSlideWakeup = function () {
        if (this.hasStaticLayer && this.ready) {
            this._initLayers(false, true);
        }
    };

    /**
     * get the layer object by the id attribute
     */
    p.getLayerById = function (layerId) {
        if (!layerId) {
            return null;
        }

        for (var i = 0; i < this.layersCount; ++i) {
            if (this.layers[i].id === layerId) {
                return this.layers[i];
            }
        }

        return null;
    };

    /**
     * destroy layer controller and stop layer animations
     */
    p.destroy = function () {
        if (this.slide.selected && this.hasParallaxLayer) {
            this._disableParallaxEffect();
        }

        for (var i = 0; i < this.layersCount; ++i) {
            this.layers[i].$element.stop(true).remove();
        }

        this.$layers.remove();
        this.$staticLayers.remove();
        this.$fixedLayers.remove();
        this.$animLayers.remove();
    };


    /*-----------------------------------------*\
    	Private Methods
    \*-----------------------------------------*/

    /**
     * start layer effect
     */
    p._startLayers = function () {
        for (var i = 0; i !== this.layersCount; ++i) {
            var layer = this.layers[i];
            if (!layer.waitForAction) {
                layer.start();
            }
        }
    };

    /**
     * call init method of all layers
     * @param  {Boolean} force
     */
    p._initLayers = function (force, onlyStatics) {

        if (this.init && !force || this.slider.init_safemode) {
            return;
        }

        this.init = onlyStatics !== true;

        var i = 0;
        if (onlyStatics && !this.staticsInit) { // init only static layers
            this.staticsInit = true;
            for (; i !== this.layersCount; ++i) {
                if (this.layers[i].staticLayer) {
                    this.layers[i].init();
                }
            }
        } else if (this.staticsInit && !force) { // statics are already initiated, init dynamics
            for (; i !== this.layersCount; ++i) {
                if (!this.layers[i].staticLayer) {
                    this.layers[i].init();
                }
            }
        } else { // init all
            for (; i !== this.layersCount; ++i) {
                this.layers[i].init();
            }
        }
    };

    /**
     * locate layers over slide
     */
    p._locateLayers = function (onlyStatics) {
        var i = 0;
        if (onlyStatics) {
            for (; i !== this.layersCount; ++i) {
                if (this.layers[i].staticLayer) {
                    this.layers[i].locate();
                }
            }
        } else {
            for (; i !== this.layersCount; ++i) {
                this.layers[i].locate();
            }
        }
    };

    /**
     * rest layers
     */
    p._resetLayers = function () {
        this.$animLayers.css('display', 'none').css('opacity', 1);
        for (var i = 0; i !== this.layersCount; ++i) {
            this.layers[i].reset();
        }
    };

    /**
     * moves layers based on x and y
     * @param  {Number} x
     * @param  {Number} y
     * @param  {Boolean} fast whether animate or not
     */
    p._applyParallax = function (x, y, fast) {
        for (var i = 0; i !== this.layersCount; ++i) {
            if (this.layers[i].parallax != null) {
                this.layers[i].moveParallax(x, y, fast);
            }
        }
    };

    /**
     * enable parallax moving layers
     */
    p._enableParallaxEffect = function () {
        if (this.slider.options.parallaxMode === 'swipe') {
            this.slide.view.addEventListener(MSViewEvents.SCROLL, this._swipeParallaxMove, this);
        } else {
            this.slide.$element.on('mousemove', {
                    that: this
                }, this._mouseParallaxMove)
                .on('mouseleave', {
                    that: this
                }, this._resetParalax);
            /**
             * Calculates new position of parallax based on device orintation gamma and beta
             * @param  {Event} e
             * @since 1.6.0
             */
            /*if( window._mobile && window.DeviceOrientationEvent ){

            	var that = this;
            	this.orientationParallaxMove = function(e){
            		var beta = Math.round(e.beta),
            			gamma = Math.round(e.gamma);

            		that._applyParallax(beta * that.__width / 360 , -gamma * that.__height / 360);
            	};

            	window.addEventListener('deviceorientation', this.orientationParallaxMove, false);
            }*/
        }
    };

    /**
     * disable parallax effect
     */
    p._disableParallaxEffect = function () {
        if (this.slider.options.parallaxMode === 'swipe') {
            this.slide.view.removeEventListener(MSViewEvents.SCROLL, this._swipeParallaxMove, this);
        } else {
            this.slide.$element.off('mousemove', this._mouseParallaxMove)
                .off('mouseleave', this._resetParalax);

            /*if( window._mobile && window.DeviceOrientationEvent ){
            	window.removeEventListener('deviceorientation', this.orientationParallaxMove);
            }*/
        }
    };

    /**
     * reset layers parallax position to 0, 0
     */
    p._resetParalax = function (e) {
        var that = e.data.that;
        that._applyParallax(0, 0);
    };

    /**
     * Calculates new mouse position over slide and moves layers
     * @since 1.6.0
     */
    p._mouseParallaxMove = function (e) {
        var that = e.data.that,
            os = that.slide.$element.offset(),
            slider = that.slider;

        if (slider.options.parallaxMode !== 'mouse:y-only') {
            var x = e.pageX - os.left - that.slide.__width / 2;
        } else {
            var x = 0;
        }

        if (slider.options.parallaxMode !== 'mouse:x-only') {
            var y = e.pageY - os.top - that.slide.__height / 2;
        } else {
            var y = 0;
        }

        that._applyParallax(-x, -y);
    };


    /**
     * Calculates new position of parallax based on slide position
     * @param  {Event} e
     * @since 1.6.0
     */
    p._swipeParallaxMove = function (e) {
        var value = this.slide.position - this.slide.view.__contPos;

        if (this.slider.options.dir === 'v') {
            this._applyParallax(0, value, true);
        } else {
            this._applyParallax(value, 0, true);
        }
    };


})(window, document, jQuery);

/* ================== bin-debug/js/pro/layers/OverlayLayerController.js =================== */
/**
 * Overlaye layer controller extends layer controller
 * @since 2.50.0
 */
;
(function ($, window, document, undefined) {
    "use strict";


    window.MSOverlayLayerController = function (slide) {
        MSLayerController.apply(this, arguments);
    }

    /* ------------------------------------------------------------------------------ */
    MSOverlayLayerController.extend(MSLayerController);
    var p = MSOverlayLayerController.prototype;
    var _super = MSLayerController.prototype;
    /* ------------------------------------------------------------------------------ */

    /**
     * @override
     */
    p.addLayer = function (layer) {
        var showOnSlides = layer.$element.data('show-on'),
            hideOnSlides = layer.$element.data('hide-on');

        if (hideOnSlides) {
            layer.hideOnSlides = hideOnSlides.replace(/\s+/g, '').split(',');
        }

        if (showOnSlides) {
            layer.showOnSlides = showOnSlides.replace(/\s+/g, '').split(',');
        }

        _super.addLayer.apply(this, arguments);
    };

    /**
     * @override
     */
    p.create = function () {
        _super.create.apply(this, arguments);
        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.checkLayers.bind(this));
    };

    p.checkLayers = function () {
        if (!this.ready) {
            return;
        }

        for (var i = 0; i !== this.layersCount; ++i) {
            var layer = this.layers[i];
            if (!layer.waitForAction) {
                if (this._checkForShow(layer)) {
                    layer.start();
                } else {
                    layer.hide();
                }
            }
        }
    };

    /**
     * enable parallax effect, overlay layars doesn't support swipe parallax
     */
    p._enableParallaxEffect = function () {
        this.slider.view.$element.on('mousemove', {
                that: this
            }, this._mouseParallaxMove)
            .on('mouseleave', {
                that: this
            }, this._resetParalax);
    };

    /**
     * disable parallax effect
     * overlay layers doesn't support swipe parallax
     */
    p._disableParallaxEffect = function () {
        this.slider.view.$element.off('mousemove', this._mouseParallaxMove)
            .off('mouseleave', this._resetParalax);
    };

    /* ------------------------------------------------------------------------------ */
    /**
     * start layer effect
     */
    p._startLayers = function () {
        for (var i = 0; i !== this.layersCount; ++i) {
            var layer = this.layers[i];

            if (this._checkForShow(layer) && !layer.waitForAction) {
                layer.start();
            }
        }
    };

    p._checkForShow = function (layer) {
        var slideId = this.slider.api.currentSlide.id,
            layerHideOn = layer.hideOnSlides,
            layerShowOn = layer.showOnSlides;

        if (layerShowOn) {
            return !!slideId && layerShowOn.indexOf(slideId) !== -1;
        }

        return !slideId || !layerHideOn || (layerHideOn.length && layerHideOn.indexOf(slideId) === -1);
    };

})(jQuery, window, document);

/* ================== bin-debug/js/pro/layers/OverlayLayers.js =================== */
/**
 * Master Slider overlay layers
 *
 */
;
(function ($, window, document, undefined) {
    "use strict";

    window.MSOverlayLayers = function (slider) {
        this.slider = slider;
    };

    /* ------------------------------------------------------------------------------ */
    var p = MSOverlayLayers.prototype;

    p.setupLayerController = function () {
        this.layerController = new MSOverlayLayerController(this);
        this.slider.api.addEventListener(MSSliderEvent.RESIZE, this.setSize.bind(this));
        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.setSize.bind(this));
        this.setSize();
    };

    p.setSize = function () {
        this.__width = this.$element.width();
        this.__height = this.$element.height();

        this.layerController.setSize(this.__width, this.__height);
    };

    p.create = function () {
        this.layerController.create();
        this.layerController.loadLayers(this._onLayersLoad);
        this.layerController.prepareToShow();

        if (window.pointerEventsPolyfill) {
            window.pointerEventsPolyfill({
                selector: '#' + this.slider.$element.attr('id') + ' ' + '.ms-overlay-layers',
                forcePolyfill: false
            });
        }
    };

    p.getHeight = function () {
        return this.slider.api.currentSlide.getHeight();
    };

    p.destroy = function () {
        this.layerController.destroy();
    };

    /* ------------------------------------------------------------------------------ */

    p._onLayersLoad = function () {
        this.ready = true;
        this.selected = true;
        this.layersLoaded = true;
        this.setSize();
        this.layerController.showLayers();
    };

})(jQuery, window, document);

/* ================== bin-debug/js/pro/layers/LayerEffects.js =================== */
;
(function ($) {

    window.MSLayerEffects = {};

    var installed,
        _fade = {
            opacity: 0
        };

    MSLayerEffects.setup = function () {

        if (installed) return;
        installed = true;

        var st = MSLayerEffects,
            transform_css = window._jcsspfx + 'Transform',
            transform_orig_css = window._jcsspfx + 'TransformOrigin',
            o = $.browser.opera; // Opera sucks :|
        _2d = window._css2d && window._cssanim && !o;

        st.defaultValues = {
            left: 0,
            top: 0,
            opacity: (isMSIE('<=9') ? 1 : ''),
            right: 0,
            bottom: 0
        };
        st.defaultValues[transform_css] = '';
        //st.defaultValues[transform_orig_css] = '';
        st.rf = 1;

        st.presetEffParams = {
            random: '30|300',
            long: 300,
            short: 30,
            'false': false,
            'true': true,
            tl: 'top left',
            bl: 'bottom left',
            tr: 'top right',
            br: 'bottom right',
            rt: 'top right',
            lb: 'bottom left',
            lt: 'top left',
            rb: 'bottom right',
            t: 'top',
            b: 'bottom',
            r: 'right',
            l: 'left',
            c: 'center'
        };


        /*
         ----------------------------------------
         				2D Effects
         ----------------------------------------
         */

        st.fade = function () {
            return _fade;
        };

        st.left = (_2d) ? function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'translateX(' + -dist * st.rf + 'px)';
            return r;
        } : function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.left = -dist * st.rf + 'px';
            return r;
        };

        st.right = (_2d) ? function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'translateX(' + dist * st.rf + 'px)';
            return r;
        } : function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.left = dist * st.rf + 'px';
            return r;
        };

        st.top = (_2d) ? function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'translateY(' + -dist * st.rf + 'px)';
            return r;
        } : function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.top = -dist * st.rf + 'px';
            return r;
        };

        st.bottom = (_2d) ? function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'translateY(' + dist * st.rf + 'px)';
            return r;
        } : function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.top = dist * st.rf + 'px';
            return r;
        };

        st.from = (_2d) ? function (leftdis, topdis, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'translateX(' + leftdis * st.rf + 'px) translateY(' + topdis * st.rf + 'px)';
            return r;
        } : function (leftdis, topdis, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r.top = topdis * st.rf + 'px';
            r.left = leftdis * st.rf + 'px';
            return r;
        };


        // --------------------------------------------------------------------

        st.rotate = (_2d) ? function (deg, orig) {
            var r = {
                opacity: 0
            };
            r[transform_css] = ' rotate(' + deg + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, orig) {
            return _fade;
        };

        st.rotateleft = (_2d) ? function (deg, dist, orig, fade) {
            var r = st.left(dist, fade);
            r[transform_css] += ' rotate(' + deg + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, dist, orig, fade) {
            return st.left(dist, fade);
        };

        st.rotateright = (_2d) ? function (deg, dist, orig, fade) {
            var r = st.right(dist, fade);
            r[transform_css] += ' rotate(' + deg + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, dist, orig, fade) {
            return st.right(dist, fade);
        };

        st.rotatetop = (_2d) ? function (deg, dist, orig, fade) {
            var r = st.top(dist, fade);
            r[transform_css] += ' rotate(' + deg + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, dist, orig, fade) {
            return st.top(dist, fade);
        };

        st.rotatebottom = (_2d) ? function (deg, dist, orig, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] += ' rotate(' + deg + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, dist, orig, fade) {
            return st.bottom(dist, fade);
        };

        st.rotatefrom = (_2d) ? function (deg, leftdis, topdis, orig, fade) {
            var r = st.from(leftdis, topdis, fade);
            r[transform_css] += ' rotate(' + deg + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, leftdis, topdis, orig, fade) {
            return st.from(leftdis, topdis, fade);
        };

        st.skewleft = (_2d) ? function (deg, dist, fade) {
            var r = st.left(dist, fade);
            r[transform_css] += ' skewX(' + deg + 'deg)';
            return r;
        } : function (deg, dist, fade) {
            return st.left(dist, fade);
        };

        st.skewright = (_2d) ? function (deg, dist, fade) {
            var r = st.right(dist, fade);
            r[transform_css] += ' skewX(' + -deg + 'deg)';
            return r;
        } : function (deg, dist, fade) {
            return st.right(dist, fade);
        };

        st.skewtop = (_2d) ? function (deg, dist, fade) {
            var r = st.top(dist, fade);
            r[transform_css] += ' skewY(' + deg + 'deg)';
            return r;
        } : function (deg, dist, fade) {
            return st.top(dist, fade);
        };

        st.skewbottom = (_2d) ? function (deg, dist, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] += ' skewY(' + -deg + 'deg)';
            return r;
        } : function (deg, dist, fade) {
            return st.bottom(dist, fade);
        };


        st.scale = (_2d) ? function (x, y, orig, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = ' scaleX(' + x + ') scaleY(' + y + ')';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, orig, fade) {
            return fade === false ? {} : {
                opacity: 0
            };
        };

        st.scaleleft = (_2d) ? function (x, y, dist, orig, fade) {
            var r = st.left(dist, fade);
            r[transform_css] = ' scaleX(' + x + ') scaleY(' + y + ')';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, dist, orig, fade) {
            return st.left(dist, fade);
        };

        st.scaleright = (_2d) ? function (x, y, dist, orig, fade) {
            var r = st.right(dist, fade);
            r[transform_css] = ' scaleX(' + x + ') scaleY(' + y + ')';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, dist, orig, fade) {
            return st.right(dist, fade);
        };

        st.scaletop = (_2d) ? function (x, y, dist, orig, fade) {
            var r = st.top(dist, fade);
            r[transform_css] = ' scaleX(' + x + ') scaleY(' + y + ')';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, dist, orig, fade) {
            return st.top(dist, fade);
        };

        st.scalebottom = (_2d) ? function (x, y, dist, orig, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] = ' scaleX(' + x + ') scaleY(' + y + ')';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, dist, orig, fade) {
            return st.bottom(dist, fade);
        };

        st.scalefrom = (_2d) ? function (x, y, leftdis, topdis, orig, fade) {
            var r = st.from(leftdis, topdis, fade);
            r[transform_css] += ' scaleX(' + x + ') scaleY(' + y + ')';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, leftdis, topdis, orig, fade) {
            return st.from(leftdis, topdis, fade);
        };

        st.rotatescale = (_2d) ? function (deg, x, y, orig, fade) {
            var r = st.scale(x, y, orig, fade);
            r[transform_css] += ' rotate(' + deg + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, x, y, orig, fade) {
            return st.scale(x, y, orig, fade);
        };


        /*
         ----------------------------------------
         				3D Effects
         ----------------------------------------
         */

        st.front = (window._css3d) ? function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'perspective(2000px) translate3d(0 , 0 ,' + dist + 'px ) rotate(0.001deg)';
            return r;
        } : function (dist) {
            return _fade;
        };

        st.back = (window._css3d) ? function (dist, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'perspective(2000px) translate3d(0 , 0 ,' + -dist + 'px ) rotate(0.001deg)';
            return r;
        } : function (dist) {
            return _fade;
        };

        st.rotatefront = (window._css3d) ? function (deg, dist, orig, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'perspective(2000px) translate3d(0 , 0 ,' + dist + 'px ) rotate(' + (deg || 0.001) + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, dist, orig, fade) {
            return _fade;
        };

        st.rotateback = (window._css3d) ? function (deg, dist, orig, fade) {
            var r = fade === false ? {} : {
                opacity: 0
            };
            r[transform_css] = 'perspective(2000px) translate3d(0 , 0 ,' + -dist + 'px ) rotate(' + (deg || 0.001) + 'deg)';
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (deg, dist, orig, fade) {
            return _fade;
        };

        st.rotate3dleft = (window._css3d) ? function (x, y, z, dist, orig, fade) {
            var r = st.left(dist, fade);
            r[transform_css] += (x ? ' rotateX(' + x + 'deg)' : ' ') + (y ? ' rotateY(' + y + 'deg)' : '') + (z ? ' rotateZ(' + z + 'deg)' : '');
            if (orig) r[transform_orig_css] = orig;
            return r;

        } : function (x, y, z, dist, orig, fade) {
            return st.left(dist, fade);;
        };

        st.rotate3dright = (window._css3d) ? function (x, y, z, dist, orig, fade) {
            var r = st.right(dist, fade);
            r[transform_css] += (x ? ' rotateX(' + x + 'deg)' : ' ') + (y ? ' rotateY(' + y + 'deg)' : '') + (z ? ' rotateZ(' + z + 'deg)' : '');
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, z, dist, orig, fade) {
            return st.right(dist, fade);;
        };

        st.rotate3dtop = (window._css3d) ? function (x, y, z, dist, orig, fade) {
            var r = st.top(dist, fade);
            r[transform_css] += (x ? ' rotateX(' + x + 'deg)' : ' ') + (y ? ' rotateY(' + y + 'deg)' : '') + (z ? ' rotateZ(' + z + 'deg)' : '');
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, z, dist, orig, fade) {
            return st.top(dist, fade);;
        };

        st.rotate3dbottom = (window._css3d) ? function (x, y, z, dist, orig, fade) {
            var r = st.bottom(dist, fade);
            r[transform_css] += (x ? ' rotateX(' + x + 'deg)' : ' ') + (y ? ' rotateY(' + y + 'deg)' : '') + (z ? ' rotateZ(' + z + 'deg)' : '');
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, z, dist, orig, fade) {
            return st.bottom(dist, fade);
        };

        st.rotate3dfront = (window._css3d) ? function (x, y, z, dist, orig, fade) {
            var r = st.front(dist, fade);
            r[transform_css] += (x ? ' rotateX(' + x + 'deg)' : ' ') + (y ? ' rotateY(' + y + 'deg)' : '') + (z ? ' rotateZ(' + z + 'deg)' : '');
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, z, dist, orig, fade) {
            return st.front(dist, fade);
        };

        st.rotate3dback = (window._css3d) ? function (x, y, z, dist, orig, fade) {
            var r = st.back(dist, fade);
            r[transform_css] += (x ? ' rotateX(' + x + 'deg)' : ' ') + (y ? ' rotateY(' + y + 'deg)' : '') + (z ? ' rotateZ(' + z + 'deg)' : '');
            if (orig) r[transform_orig_css] = orig;
            return r;
        } : function (x, y, z, dist, orig, fade) {
            return st.back(dist, fade);
        };

        // transform effect
        st.t = (window._css3d) ? function (fade, tx, ty, tz, r, rx, ry, rz, scx, scy, skx, sky, ox, oy, oz) {
            var _r = fade === false ? {} : {
                opacity: 0
            };
            var transform = 'perspective(2000px) ';

            tx !== 'n' && (transform += 'translateX(' + tx * st.rf + 'px) ');
            ty !== 'n' && (transform += 'translateY(' + ty * st.rf + 'px) ');
            tz !== 'n' && (transform += 'translateZ(' + tz * st.rf + 'px) ');
            r !== 'n' && (transform += 'rotate(' + r + 'deg) ');
            rx !== 'n' && (transform += 'rotateX(' + rx + 'deg) ');
            ry !== 'n' && (transform += 'rotateY(' + ry + 'deg) ');
            rz !== 'n' && (transform += 'rotateZ(' + rz + 'deg) ');
            skx !== 'n' && (transform += 'skewX(' + skx + 'deg) ');
            sky !== 'n' && (transform += 'skewY(' + sky + 'deg) ');
            scx !== 'n' && (transform += 'scaleX(' + scx + ') ');
            scy !== 'n' && (transform += 'scaleY(' + scy + ')');

            _r[transform_css] = transform;

            var trans_origin = '';

            trans_origin += (ox !== 'n' ? ox + '% ' : '50% ');
            trans_origin += (oy !== 'n' ? oy + '% ' : '50% ');
            trans_origin += (oz !== 'n' ? oz + 'px' : '');

            _r[transform_orig_css] = trans_origin;

            return _r;

        } : function (fade, tx, ty, tz, r, rx, ry, rz, scx, scy, skx, sky, ox, oy, oz) {

            var r = fade === false ? {} : {
                opacity: 0
            };
            tx !== 'n' && (r.left = tx * st.rf + 'px');
            ty !== 'n' && (r.top = ty * st.rf + 'px');
            return r;
        }
    };
})(jQuery);

/* ================== bin-debug/js/pro/layers/LayerElement.js =================== */
/**
 * Master Slider Layer Element
 * @author Averta
 * @package Master Slider jQuery
 */

;
(function ($) {

    /**
     * master slider layer element constructor
     */
    window.MSLayerElement = function () {

        // default layer start animation
        this.start_anim = {
            name: 'fade',
            duration: 1000,
            ease: 'linear',
            delay: 0
        };

        // default layer end animation
        this.end_anim = {
            duration: 1000,
            ease: 'linear'
        };

        // default layer type
        this.type = 'text'; // video , image

        //this.swipe 		= true;
        this.resizable = true;
        this.minWidth = -1;
        this.isVisible = true;

        // list of styles which should stores initial values and changes based on screen size for resizable layers
        this.__cssConfig = [
            'margin-top', 'padding-top',
            'margin-bottom', 'padding-left',
            'margin-right', 'padding-right',
            'margin-left', 'padding-bottom',


            'font-size', 'line-height',
            /*'height'		, */
            'width',
            'left', 'right',
            'top', 'bottom'
        ];

        this.baseStyle = {};
    };

    var p = MSLayerElement.prototype;

    /*--------------------------------------------------*\
    	Public Methods
    \*--------------------------------------------------*/

    /**
     * determine start animation for the layer
     * @param {Objec} anim
     */
    p.setStartAnim = function (anim) {
        $.extend(this.start_anim, anim);
        $.extend(this.start_anim, this._parseEff(this.start_anim.name));
        this.$element.css('visibility', 'hidden');
    };

    /**
     * determine end/hide animation for the layer
     * @param {Object} anim
     */
    p.setEndAnim = function (anim) {
        $.extend(this.end_anim, anim);
    };

    /**
     * create layer object from layer element
     */
    p.create = function () {
        this.$element.css('display', 'none');

        // resizable layer
        this.resizable = this.$element.data('resize') !== false;

        // fixed positioning
        this.fixed = this.$element.data('fixed') === true;

        // hide under parameter
        if (this.$element.data('widthlimit') !== undefined) {
            this.minWidth = this.$element.data('widthlimit');
        }

        if (!this.end_anim.name) {
            this.end_anim.name = this.start_anim.name;
        }

        if (this.end_anim.time) {
            this.autoHide = true; //this.end_anim.delay = this.slide.delay * 1000 - this.end_anim.duration;
        }

        // is this layer static?
        this.staticLayer = this.$element.data('position') === 'static';
        this.fixedLayer = this.$element.data('position') === 'fixed';
        this.layersCont = this.controller.$layers;

        // make it visible if it's static
        if (this.staticLayer) {
            this.$element.css('display', '')
                .css('visibility', '');
        }

        // create action event
        // @since v1.7.2
        if (this.$element.data('action') !== undefined) {
            var slideController = this.slide.slider.slideController;
            this.$element.on(this.$element.data('action-event') || 'click', function (event) {
                slideController.runAction($(this).data('action'));
                event.preventDefault();
            }).addClass('ms-action-layer');
        }

        $.extend(this.end_anim, this._parseEff(this.end_anim.name));
        this.slider = this.slide.slider;

        // masked layer
        if (this.masked) {
            this.$mask = $('<div></div>').addClass('ms-layer-mask');

            if (this.link) {
                this.link.wrap(this.$mask);
                this.$mask = this.link.parent();
            } else {
                this.$element.wrap(this.$mask);
                this.$mask = this.$element.parent();
            }

            if (this.maskWidth) {
                this.$mask.width(this.maskWidth);
            }

            if (this.maskHeight) {
                this.$mask.height(this.maskHeight);

                // add height to css check
                if (this.__cssConfig.indexOf('height') === -1) {
                    this.__cssConfig.push('height');
                }
            }
        }

        // new alignment method
        // @since v1.6.1
        var layerOrigin = this.layerOrigin = this.$element.data('origin');

        if (layerOrigin) {

            var vOrigin = layerOrigin.charAt(0),
                hOrigin = layerOrigin.charAt(1),
                offsetX = this.$element.data('offset-x'),
                offsetY = this.$element.data('offset-y'),
                layerEle = this.masked ? this.$mask[0] : this.$element[0];

            if (offsetY === undefined) {
                offsetY = 0;
            }

            switch (vOrigin) {
                case 't':
                    layerEle.style.top = offsetY + 'px';
                    break;
                case 'b':
                    layerEle.style.bottom = offsetY + 'px';
                    break;
                case 'm':
                    layerEle.style.top = offsetY + 'px';
                    this.middleAlign = true;
            }

            if (offsetX === undefined) {
                offsetX = 0;
            }


            switch (hOrigin) {
                case 'l':
                    layerEle.style.left = offsetX + 'px';
                    break;
                case 'r':
                    layerEle.style.right = offsetX + 'px';
                    break;
                case 'c':
                    layerEle.style.left = offsetX + 'px';
                    this.centerAlign = true;
            }
        }

        // parallax effect
        // @since v1.6.0
        this.parallax = this.$element.data('parallax')
        if (this.parallax != null) {
            this.parallax /= 100;
            this.$parallaxElement = $('<div></div>').addClass('ms-parallax-layer');

            if (this.masked) {
                this.$mask.wrap(this.$parallaxElement);
                this.$parallaxElement = this.$mask.parent();
            } else if (this.link) { // only for image layer
                this.link.wrap(this.$parallaxElement);
                this.$parallaxElement = this.link.parent();
            } else {
                this.$element.wrap(this.$parallaxElement);
                this.$parallaxElement = this.$element.parent();
            }

            this._lastParaX = 0;
            this._lastParaY = 0;
            this._paraX = 0;
            this._paraY = 0;


            // add bottom 0 to the parallax element if layer origin specified to the bottom
            this.alignedToBot = this.layerOrigin && this.layerOrigin.indexOf('b') !== -1;
            if (this.alignedToBot) {
                this.$parallaxElement.css('bottom', 0);
            }

            if (window._css3d) {
                this.parallaxRender = this._parallaxCSS3DRenderer;
            } else if (window._css2d) {
                this.parallaxRender = this._parallaxCSS2DRenderer;
            } else {
                this.parallaxRender = this._parallax2DRenderer;
            }

            if (this.slider.options.parallaxMode !== 'swipe') { // mouse mode
                averta.Ticker.add(this.parallaxRender, this);
            }
        }

        // remove all data- attributes excluding data-src
        $.removeDataAttrs(this.$element, ['data-src']);
    };

    /**
     * initialize layer
     */
    p.init = function () {
        //if(this.initialized) return;
        this.initialized = true;

        var value;

        this.$element.css('visibility', '');
        // store initial layer styles
        for (var i = 0, l = this.__cssConfig.length; i < l; i++) {
            var key = this.__cssConfig[i];
            if (this._isPosition(key) && this.masked) {
                value = this.$mask.css(key);
            } else if (this.type === 'text' && key === 'width' && !this.masked && !this.maskWidth) { // in some browsers using computed style for width in text layer causes unexpected word wrapping
                value = this.$element[0].style.width;
            } else {

                value = this.$element.css(key);
                var isSize = key === 'width' || key === 'height';

                if (isSize && this.masked) {
                    if (this.maskWidth && key === 'width') {
                        value = this.maskWidth + 'px';
                    } else if (this.maskHeight && key === 'height') {
                        value = this.maskHeight + 'px';
                    }
                }

                // fix for Google Chrome in ios, sometimes image layers over first slide not showing correctly.
                if (isSize && value === '0px') {
                    value = this.$element.data(key) + 'px';
                }
            }

            // skip unnecessary positioning styles
            if (this.layerOrigin && (
                    (key === 'top' && this.layerOrigin.indexOf('t') === -1 && this.layerOrigin.indexOf('m') === -1) ||
                    (key === 'bottom' && this.layerOrigin.indexOf('b') === -1) ||
                    (key === 'left' && this.layerOrigin.indexOf('l') === -1 && this.layerOrigin.indexOf('c') === -1) ||
                    (key === 'right' && this.layerOrigin.indexOf('r') === -1))) {
                continue;
            }

            if (value != 'auto' && value != "" && value != "normal") {
                this.baseStyle[key] = parseInt(value);
            }
        }

        // @since v1.6.0
        if (this.middleAlign) {
            this.baseHeight = this.$element.outerHeight(false); //this.$element.height();
        }

        if (this.centerAlign) {
            // in some browsers using computed style for width in text layer causes unexpected word wrapping
            //if ( this.type === 'text' ){
            //  this.baseWidth = parseInt(this.$element[0].style.width);
            //} else {
            this.baseWidth = this.$element.outerWidth(false);
            //}
        }

    };

    /**
     * locate layer over slider
     */
    p.locate = function () {

        // is slide ready?
        if (!this.slide.ready) {
            return;
        }

        var width = parseFloat(this.layersCont.css('width')),
            height = parseFloat(this.layersCont.css('height')),
            factor, isPosition, isSize;

        if (!this.staticLayer && this.$element.css('display') === 'none' && this.isVisible) {
            this.$element.css('display', '')
                .css('visibility', 'hidden');
        }

        if (this.staticLayer) {
            this.$element.addClass('ms-hover-active');
        }

        factor = this.resizeFactor = width / this.slide.slider.options.width;

        var $layerEle = this.masked ? this.$mask : this.$element;

        // updated @since v1.6.1
        for (var key in this.baseStyle) {

            isPosition = this._isPosition(key);
            isSize = key === 'width' || key === 'height';

            //switch resize/position factor
            if (this.fixed && isPosition) {
                factor = 1;
            } else {
                factor = this.resizeFactor;
            }

            if (!this.resizable && !isPosition) {
                continue;
            }

            if (key === 'top' && this.middleAlign) {
                $layerEle[0].style.top = '0px';
                this.baseHeight = $layerEle.outerHeight(false);
                $layerEle[0].style.top = this.baseStyle['top'] * factor + (height - this.baseHeight) / 2 + 'px';
            } else if (key === 'left' && this.centerAlign) {
                $layerEle[0].style.left = '0px';
                this.baseWidth = $layerEle.outerWidth(false);
                $layerEle[0].style.left = this.baseStyle['left'] * factor + (width - this.baseWidth) / 2 + 'px';
            } else if (isPosition && this.masked) {
                $layerEle[0].style[key] = this.baseStyle[key] * factor + 'px';
            } else if (isSize && ((key === 'width' && this.maskWidth) || (key === 'height' && this.maskHeight))) {
                $layerEle[0].style[key] = this.baseStyle[key] * factor + 'px';
            } else {
                this.$element.css(key, this.baseStyle[key] * factor + 'px');
            }
        }


        this.visible(this.minWidth < width);
    };

    /**
     * start layer animation
     */
    p.start = function () {

        // is it already showing or is it a static layer?
        if (this.isShowing || this.staticLayer) {
            return;
        }

        this.isShowing = true;
        this.$element.removeClass('ms-hover-active');

        var key, base;

        // reads css value form LayerEffects
        MSLayerEffects.rf = this.resizeFactor;
        var effect_css = MSLayerEffects[this.start_anim.eff_name].apply(null, this._parseEffParams(this.start_anim.eff_params));

        // checkes effect css and defines TO css values
        var start_css_eff = {};

        // set from position
        for (key in effect_css) {

            // check the position key (top, left, right or bottom) for animatin
            // It mostly will be used in old browsers
            // In effect left:100, layer base style right:300 -> effect changes to right:100
            if (this._checkPosKey(key, effect_css)) {
                continue;
            }

            // set default value from Layer Effects Class
            if (MSLayerEffects.defaultValues[key] != null) {
                start_css_eff[key] = MSLayerEffects.defaultValues[key];
            }

            if (key in this.baseStyle) {
                base = this.baseStyle[key];

                // updated @since v1.6.1
                if (this.middleAlign && key === 'top') {
                    base += (parseInt(this.layersCont.height()) - this.$element.outerHeight(false)) / 2;
                }

                if (this.centerAlign && key === 'left') {
                    base += (parseInt(this.layersCont.width()) - this.$element.outerWidth(false)) / 2;
                }
                //----------------------

                effect_css[key] = base + parseFloat(effect_css[key]) + 'px';
                start_css_eff[key] = base + 'px';
            }

            this.$element.css(key, effect_css[key]);
        }

        var that = this;

        clearTimeout(this.to);
        clearTimeout(this.clHide);
        this.to = setTimeout(function () {
            //that.locate();
            that.$element.css('visibility', '');
            that._playAnimation(that.start_anim, start_css_eff);
        }, that.start_anim.delay || 0.01);


        this.clTo = setTimeout(function () {
            that.show_cl = true;
            that.$element.addClass('ms-hover-active');
        }, (this.start_anim.delay || 0.01) + this.start_anim.duration + 1);

        if (this.autoHide) {
            clearTimeout(this.hto);
            this.hto = setTimeout(function () {
                that.hide();
            }, that.end_anim.time);
        }

    };

    /**
     * starts hide animation
     */
    p.hide = function () {

        // static layers doesn't support animations
        if (this.staticLayer) {
            return;
        }

        this.$element.removeClass('ms-hover-active');

        this.isShowing = false;

        // reads css value form LayerEffects
        var effect_css = MSLayerEffects[this.end_anim.eff_name].apply(null, this._parseEffParams(this.end_anim.eff_params));

        for (key in effect_css) {

            if (this._checkPosKey(key, effect_css)) continue;

            if (key === window._jcsspfx + 'TransformOrigin') {
                this.$element.css(key, effect_css[key]);
            }

            if (key in this.baseStyle) {
                effect_css[key] = this.baseStyle[key] + parseFloat(effect_css[key]) + 'px';
            }

        }

        this._playAnimation(this.end_anim, effect_css);

        clearTimeout(this.clHide);

        if (effect_css.opacity === 0) {
            this.clHide = setTimeout(function () {
                this.$element.css('visibility', 'hidden');
            }.bind(this), this.end_anim.duration + 1);
        }

        clearTimeout(this.to);
        clearTimeout(this.hto);
        clearTimeout(this.clTo);
    };

    /**
     * reset layer
     */
    p.reset = function () {
        if (this.staticLayer) {
            return;
        }

        this.isShowing = false;
        //this.$element.css(window._csspfx + 'animation-name', ''	);
        this.$element[0].style.display = 'none';
        this.$element.css('opacity', '');
        this.$element[0].style['transitionDuration'] = '';

        if (this.show_tween)
            this.show_tween.stop(true);

        clearTimeout(this.to);
        clearTimeout(this.hto);
    };

    /**
     * destroy layer
     */
    p.destroy = function () {
        this.reset();
        this.$element.remove();
    };

    /**
     * change the visibility status
     * @param  {Boolean} value
     */
    p.visible = function (value) {
        if (this.isVisible == value) return;

        this.isVisible = value;

        this.$element.css('display', (value ? '' : 'none'));
    };

    /**
     * Change the detestation of parallax position
     * @param  {Number} x
     * @param  {Number} y
     * @since  1.6.0
     */
    p.moveParallax = function (x, y, fast) {
        this._paraX = x;
        this._paraY = y;
        if (fast) {
            this._lastParaX = x;
            this._lastParaY = y;
            this.parallaxRender();
        }
    };

    /*------------------------------------*\
    	Private Methods
    \*------------------------------------*/

    /**
     * play layer animation
     * @param  {Obeject} animation layer animation object
     * @param  {Object} css       animation css object
     */
    p._playAnimation = function (animation, css) {
        var options = {};

        if (animation.ease) {
            options.ease = animation.ease;
        }

        options.transProperty = window._csspfx + 'transform,opacity';

        if (this.show_tween) {
            this.show_tween.stop(true);
        }

        this.show_tween = CTween.animate(this.$element, animation.duration, css, options);
    };

    /**
     * generate random value
     * @param  {String} value the pattern value min|max
     * @return {Number}
     */
    p._randomParam = function (value) {
        var min = Number(value.slice(0, value.indexOf('|')));
        var max = Number(value.slice(value.indexOf('|') + 1));

        return min + Math.random() * (max - min);
    };

    /**
     * parse effect function
     * @param  {String} eff_name effect function
     * @return {Object}
     */
    p._parseEff = function (eff_name) {

        var eff_params = [];

        if (eff_name.indexOf('(') !== -1) {
            var temp = eff_name.slice(0, eff_name.indexOf('(')).toLowerCase();
            var value;

            eff_params = eff_name.slice(eff_name.indexOf('(') + 1, -1).replace(/\"|\'|\s/g, '').split(',');
            eff_name = temp;

            for (var i = 0, l = eff_params.length; i < l; ++i) {
                value = eff_params[i];

                if (value in MSLayerEffects.presetEffParams) {
                    value = MSLayerEffects.presetEffParams[value];
                }

                eff_params[i] = value;
            }
        }

        return {
            eff_name: eff_name,
            eff_params: eff_params
        };
    };

    /**
     * parse effect function parameters
     * @param  {Aarray} params effect parameters
     * @return {Array}
     */
    p._parseEffParams = function (params) {
        var eff_params = [];
        for (var i = 0, l = params.length; i < l; ++i) {
            var value = params[i];
            if (typeof value === 'string' && value.indexOf('|') !== -1) value = this._randomParam(value);

            eff_params[i] = value;
        }

        return eff_params;
    };

    /**
     * calculates layer position based on initial positioning style and layer effect
     * @param  {string} key   positioning key
     * @param  {Object} style style object
     * @return {Boolean}
     */
    p._checkPosKey = function (key, style) {
        if (key === 'left' && !(key in this.baseStyle) && 'right' in this.baseStyle) {
            style.right = -parseInt(style.left) + 'px';
            delete style.left;
            return true;
        }

        if (key === 'top' && !(key in this.baseStyle) && 'bottom' in this.baseStyle) {
            style.bottom = -parseInt(style.top) + 'px';
            delete style.top;
            return true;
        }

        return false;
    };

    /**
     * checks for position key
     * @param  {String}  key
     * @return {Boolean}     [description]
     */
    p._isPosition = function (key) {
        return key === 'top' || key === 'left' || key === 'bottom' || key === 'right';
    };

    /**
     * calculate parallax position
     */
    p._parallaxCalc = function () {
        var x_def = this._paraX - this._lastParaX,
            y_def = this._paraY - this._lastParaY;

        this._lastParaX += x_def / 12;
        this._lastParaY += y_def / 12;

        if (Math.abs(x_def) < 0.019) {
            this._lastParaX = this._paraX;
        }

        if (Math.abs(y_def) < 0.019) {
            this._lastParaY = this._paraY;
        }

    }

    /**
     * Parallax move ticker function
     */
    p._parallaxCSS3DRenderer = function () {
        this._parallaxCalc();
        this.$parallaxElement[0].style[window._jcsspfx + 'Transform'] = 'translateX(' + this._lastParaX * this.parallax + 'px) translateY(' + this._lastParaY * this.parallax + 'px) translateZ(0)';
    };

    /**
     * parallax move ticker for CSS2 browsers
     * @return {[type]} [description]
     */
    p._parallaxCSS2DRenderer = function () {
        this._parallaxCalc();
        this.$parallaxElement[0].style[window._jcsspfx + 'Transform'] = 'translateX(' + this._lastParaX * this.parallax + 'px) translateY(' + this._lastParaY * this.parallax + 'px)';
    };

    /**
     * parallax move ticker for zombie browsers
     */
    p._parallax2DRenderer = function () {
        this._parallaxCalc();

        // change bottom instead of top if layer aligned to the bottom (origin)
        if (this.alignedToBot) {
            this.$parallaxElement[0].style.bottom = this._lastParaY * this.parallax + 'px';
        } else {
            this.$parallaxElement[0].style.top = this._lastParaY * this.parallax + 'px';
        }

        this.$parallaxElement[0].style.left = this._lastParaX * this.parallax + 'px';
    };

})(jQuery);

/* ================== bin-debug/js/pro/layers/ImageLayerElement.js =================== */
;
(function ($) {

    window.MSImageLayerElement = function () {
        MSLayerElement.call(this);
        this.needPreload = true;

        this.__cssConfig = [
            'width', 'height',
            'margin-top', 'padding-top',
            'margin-bottom', 'padding-left',
            'margin-right', 'padding-right',
            'margin-left', 'padding-bottom',

            'left', 'right',
            'top', 'bottom'
        ];

        this.type = 'image';
    };

    MSImageLayerElement.extend(MSLayerElement);

    var p = MSImageLayerElement.prototype;
    var _super = MSLayerElement.prototype;

    /*-------------- METHODS --------------*/

    p.create = function () {

        if (this.link) {
            var p = this.$element.parent();
            p.append(this.link);
            this.link.append(this.$element);
            this.link.removeClass('ms-layer');
            this.$element.addClass('ms-layer');
            p = null;
        }

        _super.create.call(this);

        if (this.$element.data('src') != undefined) {
            this.img_src = this.$element.data('src');
            this.$element.removeAttr('data-src');
        } else {
            var that = this;
            this.$element.on('load', function (event) {
                that.controller.preloadCount--;
                if (that.controller.preloadCount === 0)
                    that.controller._onlayersReady();
            }).each($.jqLoadFix);
        }

        if ($.browser.msie)
            this.$element.on('dragstart', function (event) {
                event.preventDefault();
            }); // disable native dragging
    };

    p.loadImage = function () {
        var that = this;

        this.$element.preloadImg(this.img_src, function (event) {
            //this.$element.width(event.width).height(event.height);
            that.controller.preloadCount--;
            if (that.controller.preloadCount === 0) that.controller._onlayersReady();
        });
    };

})(jQuery);

/* ================== bin-debug/js/pro/layers/VideoLayerElement.js =================== */
;
(function ($) {

    window.MSVideoLayerElement = function () {
        MSLayerElement.call(this);

        this.__cssConfig.push(
            'height'
        );

        this.type = 'video';
    };

    MSVideoLayerElement.extend(MSLayerElement);

    var p = MSVideoLayerElement.prototype;
    var _super = MSLayerElement.prototype;

    /*-------------- METHODS --------------*/
    p.__playVideo = function () {
        if (this.img) CTween.fadeOut(this.img, 500, 2);
        CTween.fadeOut(this.video_btn, 500, 2);
        this.video_frame.attr('src', 'about:blank').css('display', 'block');
        if (this.video_url.indexOf('?') == -1) this.video_url += '?';
        this.video_frame.attr('src', this.video_url + '&autoplay=1');
    };

    p.start = function () {
        _super.start.call(this);

        if (this.$element.data('autoplay')) {
            this.__playVideo();
        }
    };

    p.reset = function () {
        _super.reset.call(this);

        if (this.needPreload || this.$element.data('btn')) {
            this.video_btn.css('opacity', 1).css('display', 'block');
            this.video_frame.attr('src', 'about:blank').css('display', 'none');
        }

        if (this.needPreload) {
            this.img.css('opacity', 1).css('display', 'block');
            return;
        }

        this.video_frame.attr('src', this.video_url);
    };

    p.create = function () {
        _super.create.call(this);

        this.video_frame = this.$element.find('iframe').css({
            width: '100%',
            height: '100%'
        });
        this.video_url = this.video_frame.attr('src');

        var has_img = this.$element.has('img').length != 0;

        if (!has_img && !this.$element.data('btn')) return;

        this.video_frame.attr('src', 'about:blank').css('display', 'none');

        var that = this;

        this.video_btn = $('<div></div>').appendTo(this.$element).addClass('ms-video-btn').click(function () {
            that.__playVideo();
        });

        //this.video_frame.attr('src' , 'about:blank');

        if (!has_img) return;

        this.needPreload = true;
        this.img = this.$element.find('img:first').addClass('ms-video-img');

        if (this.img.data('src') !== undefined) {
            this.img_src = this.img.data('src');
            this.img.removeAttr('data-src');
        } else {
            var that = this;
            this.img.attr('src', this.img_src).on('load', function (event) {
                that.controller.preloadCount--;
                if (that.controller.preloadCount === 0)
                    that.controller._onlayersReady();
            }).each($.jqLoadFix);
        }

        if ($.browser.msie)
            this.img.on('dragstart', function (event) {
                event.preventDefault();
            }); // disables native dragging
    };

    p.loadImage = function () {
        var that = this;
        this.img.preloadImg(this.img_src, function (event) {
            that.controller.preloadCount--;
            if (that.controller.preloadCount === 0) that.controller._onlayersReady();
        });
    };

})(jQuery);

/* ================== bin-debug/js/pro/layers/HotspotLayer.js =================== */
;
(function ($) {

    "use strict";

    window.MSHotspotLayer = function () {
        MSLayerElement.call(this);

        this.__cssConfig = [
            'margin-top', 'padding-top',
            'margin-bottom', 'padding-left',
            'margin-right', 'padding-right',
            'margin-left', 'padding-bottom',

            'left', 'right',
            'top', 'bottom'
        ];


        this.ease = 'Expo';
        this.hide_start = true;
        this.type = 'hotspot';
    };

    MSHotspotLayer.extend(MSLayerElement);

    var p = MSHotspotLayer.prototype;
    var _super = MSLayerElement.prototype;

    /*-------------- METHODS --------------*/

    p._showTT = function () {
        if (!this.show_cl) return;

        clearTimeout(this.hto);
        if (this._tween) this._tween.stop(true);

        if (this.hide_start) {
            this.align = this._orgAlign;
            this._locateTT();

            this.tt.css({
                display: 'block'
            });
            this._tween = CTween.animate(this.tt, 900, this.to, {
                ease: 'easeOut' + this.ease
            });
            this.hide_start = false;
        }

    };

    p._hideTT = function () {
        if (!this.show_cl) return;
        if (this._tween) this._tween.stop(true);

        var that = this;

        clearTimeout(this.hto);
        this.hto = setTimeout(function () {
            that.hide_start = true;
            that._tween = CTween.animate(that.tt, 900, that.from, {
                ease: 'easeOut' + that.ease,
                complete: function () {
                    that.tt.css('display', 'none');
                }
            });
        }, 200);
    };

    p._updateClassName = function (name) {
        if (this._lastClass) this.tt.removeClass(this._lastClass);
        this.tt.addClass(name);
        this._lastClass = name;
    }

    p._alignPolicy = function () {
        var h = this.tt.outerHeight(false),
            w = Math.max(this.tt.outerWidth(false), parseInt(this.tt.css('max-width'))),
            ww = window.innerWidth,
            wh = window.innerHeight;

        switch (this.align) {
            case 'top':
                if (this.base_t < 0)
                    return 'bottom';
                break;
            case 'right':
                if (this.base_l + w > ww || this.base_t < 0)
                    return 'bottom';
                break;
            case 'left':
                if (this.base_l < 0 || this.base_t < 0)
                    return 'bottom';
                break;
        }

        return null;
    };

    p._locateTT = function () {
        var os = this.$element.offset(),
            os2 = this.slide.slider.$element.offset();

        var dist = 50,
            space = 15 //* this.factor;

        this.pos_x = os.left - os2.left - this.slide.slider.$element.scrollLeft();
        this.pos_y = os.top - os2.top - this.slide.slider.$element.scrollTop();

        this.from = {
            opacity: 0
        };
        this.to = {
            opacity: 1
        };

        this._updateClassName('ms-tooltip-' + this.align);
        this.tt_arrow.css('margin-left', '');

        var arrow_w = 15, //parseInt(this.tt_arrow.css('border-left')) + parseInt(this.tt_arrow.css('border-right')),
            arrow_h = 15; //parseInt(this.tt_arrow.css('border-top'))  + parseInt(this.tt_arrow.css('border-bottom'));

        //console.log(arrow_h,arrow_w);
        //
        switch (this.align) {
            case 'top':
                var w = Math.min(this.tt.outerWidth(false), parseInt(this.tt.css('max-width')));
                this.base_t = this.pos_y - this.tt.outerHeight(false) - arrow_h - space;
                this.base_l = this.pos_x - w / 2;

                if (this.base_l + w > window.innerWidth) {
                    this.tt_arrow.css('margin-left', -arrow_w / 2 + this.base_l + w - window.innerWidth + 'px');
                    this.base_l = window.innerWidth - w;
                }

                if (this.base_l < 0) {
                    this.base_l = 0;
                    this.tt_arrow.css('margin-left', -arrow_w / 2 + this.pos_x - this.tt.outerWidth(false) / 2 + 'px');
                }

                if (window._css3d) {
                    this.from[window._jcsspfx + 'Transform'] = 'translateY(-' + dist + 'px)';
                    this.to[window._jcsspfx + 'Transform'] = '';
                } else {
                    this.from.top = (this.base_t - dist) + 'px';
                    this.to.top = this.base_t + 'px';
                }

                break;
            case 'bottom':
                var w = Math.min(this.tt.outerWidth(false), parseInt(this.tt.css('max-width')));

                this.base_t = this.pos_y + arrow_h + space;
                this.base_l = this.pos_x - w / 2;

                if (this.base_l + w > window.innerWidth) {
                    this.tt_arrow.css('margin-left', -arrow_w / 2 + this.base_l + w - window.innerWidth + 'px');
                    this.base_l = window.innerWidth - w;
                }

                if (this.base_l < 0) {
                    this.base_l = 0;
                    this.tt_arrow.css('margin-left', -arrow_w / 2 + this.pos_x - this.tt.outerWidth(false) / 2 + 'px');
                }

                if (window._css3d) {
                    this.from[window._jcsspfx + 'Transform'] = 'translateY(' + dist + 'px)';
                    this.to[window._jcsspfx + 'Transform'] = '';
                } else {
                    this.from.top = (this.base_t + dist) + 'px';
                    this.to.top = this.base_t + 'px';
                }

                break;

            case 'right':
                this.base_l = this.pos_x + arrow_w + space;
                this.base_t = this.pos_y - this.tt.outerHeight(false) / 2;

                if (window._css3d) {
                    this.from[window._jcsspfx + 'Transform'] = 'translateX(' + dist + 'px)';
                    this.to[window._jcsspfx + 'Transform'] = '';
                } else {
                    this.from.left = (this.base_l + dist) + 'px';
                    this.to.left = this.base_l + 'px';
                }

                break;
            case 'left':
                this.base_l = this.pos_x - arrow_w - this.tt.outerWidth(false) - space;
                this.base_t = this.pos_y - this.tt.outerHeight(false) / 2;

                if (window._css3d) {
                    this.from[window._jcsspfx + 'Transform'] = 'translateX(-' + dist + 'px)';
                    this.to[window._jcsspfx + 'Transform'] = '';
                } else {
                    this.from.left = (this.base_l - dist) + 'px';
                    this.to.left = this.base_l + 'px';
                }

                break;
        }



        var policyAlign = this._alignPolicy();
        if (policyAlign !== null) {
            this.align = policyAlign;
            this._locateTT();
            return;
        }

        this.tt.css('top', parseInt(this.base_t) + 'px').
        css('left', parseInt(this.base_l) + 'px');

        this.tt.css(this.from);

    };

    p.start = function () {
        _super.start.call(this);
        this.tt.appendTo(this.slide.slider.$element);
        //this._locateTT();
        this.tt.css('display', 'none');
    };

    p.reset = function () {
        _super.reset.call(this);
        this.tt.detach();
    };

    /**
     * locate hotspot over slide
     * @override LayerElement.locate
     * @since 2.2.0
     */
    /*	p.locate = function(){
    		_super.locate.call(this);

    		if ( this.relativeToBG ) {
    			console.log(this.baseOffsetX , this.slide.$bg_img.width()  , this.slide.bgWidth)
    			this.$element[0].style.left = this.baseOffsetX * this.slide.$bg_img.width()  / this.slide.bgWidth + 'px';
    			this.$element[0].style.top  = this.baseOffsetY * this.slide.$bg_img.height() / this.slide.bgHeight + 'px';
    		} 

    	};
    */
    p.create = function () {
        var that = this;

        //@since 2.2.0
        //chnage offset progin to top left
        /*	this.relativeToBG = this.$element.data('relative') && (this.slide.fillMode === 'fill' || this.slide.fillMode === 'fit');
        	if ( this.relativeToBG ) {

        		var origin = this.$element.data('origin'),
        			osy = this.$element.data('offset-y'), 
        			osx = this.$element.data('offset-x');

        		if ( origin ) {
        			if ( origin.charAt(0) === 'b' ){
        				osy = this.slide.slider.options.height - this.$element.data('offset-y');
        				this.$element.data('offset-y',  osy);
        			}

        			if ( origin.charAt(1) === 'r' ){
        				osx = this.slide.slider.options.width - this.$element.data('offset-x');
        				this.$element.data('offset-x', osx);
        			}

        		}

        		this.$element.data('origin', 'tl');

        		this.baseOffsetX = osx;
        		this.baseOffsetY = osy;
        	}*/


        this._orgAlign = this.align = this.$element.data('align') !== undefined ? this.$element.data('align') : 'top';

        this.data = this.$element.html();

        this.$element.html('').on('mouseenter', function () {
            that._showTT();
        }).on('mouseleave', function () {
            that._hideTT();
        });

        this.point = $('<div><div class="ms-point-center"></div><div class="ms-point-border"></div></div>')
            .addClass('ms-tooltip-point')
            .appendTo(this.$element);

        var link = this.$element.data('link'),
            target = this.$element.data('target');

        if (link) {
            this.point.on('click', function () {
                window.open(link, target || '_self');
            });
        }

        this.tt = $('<div></div>')
            .addClass('ms-tooltip')
            //.addClass('ms-tooltip-'+this.align)
            .css('display', 'hidden')
            .css('opacity', 0);

        // @since v1.6.1
        if (this.$element.data('width') !== undefined) {
            this.tt.css('width', this.$element.data('width'))
                .css('max-width', this.$element.data('width'));
        }

        this.tt_arrow = $('<div></div>')
            .addClass('ms-tooltip-arrow')
            .appendTo(this.tt);

        this._updateClassName('ms-tooltip-' + this.align);

        this.ttcont = $('<div></div>')
            .addClass('ms-tooltip-cont')
            .html(this.data)
            .appendTo(this.tt)


        if (this.$element.data('stay-hover') === true) {
            this.tt.on('mouseenter', function () {
                if (that.hide_start) {
                    return
                }
                clearTimeout(that.hto);
                that._tween.stop(true);
                that._showTT();
            }).on('mouseleave', function () {
                that._hideTT();
            });
        }

        _super.create.call(this);
    };

})(jQuery);

/* ================== bin-debug/js/pro/layers/ButtonLayer.js =================== */
/**
 * Master Slider Button Layer
 * @author Averta
 * @since 1.7.2
 * @extends {MSLayerElement}
 */
(function ($) {

    window.MSButtonLayer = function () {
        MSLayerElement.call(this);

        this.type = 'button';
    };

    MSButtonLayer.extend(MSLayerElement);

    var p = MSButtonLayer.prototype;
    var _super = MSLayerElement.prototype;

    var positionKies = ['top', 'left', 'bottom', 'right'];

    /*-------------- METHODS --------------*/

    p.create = function () {
        _super.create.call(this);
        this.$element.wrap('<div class="ms-btn-container"></div>').css('position', 'relative');
        this.$container = this.$element.parent();
    };

    p.locate = function () {
        _super.locate.call(this);
        var key, tempValue;

        for (var i = 0; i < 4; i++) {
            key = positionKies[i];
            if (key in this.baseStyle) {
                tempValue = this.$element.css(key);
                this.$element.css(key, '');
                this.$container.css(key, tempValue);
            }
        }

        this.$container.width(this.$element.outerWidth(true))
            .height(this.$element.outerHeight(true));
    };

})(jQuery);

/* ================== bin-debug/js/pro/controls/SliderEvent.js =================== */
window.MSSliderEvent = function (type) {
    this.type = type;
};

MSSliderEvent.CHANGE_START = 'ms_changestart';
MSSliderEvent.CHANGE_END = 'ms_changeend';
MSSliderEvent.WAITING = 'ms_waiting';
MSSliderEvent.AUTOPLAY_CHANGE = 'ms_autoplaychange';
MSSliderEvent.VIDEO_PLAY = 'ms_videoPlay';
MSSliderEvent.VIDEO_CLOSE = 'ms_videoclose';
MSSliderEvent.INIT = 'ms_init';
MSSliderEvent.HARD_UPDATE = 'ms_hard_update';
MSSliderEvent.RESIZE = 'ms_resize';
MSSliderEvent.RESERVED_SPACE_CHANGE = 'ms_rsc'; // internal use
MSSliderEvent.DESTROY = 'ms_destroy';

/* ================== bin-debug/js/pro/controls/Slide.js =================== */
/**
 * Master Slider Slide Class
 * @author averta
 * @package Master Slider jQuery
 */
;
(function (window, document, $) {

    "use strict";

    window.MSSlide = function () {

        this.$element = null;
        this.$loading = $('<div></div>').addClass('ms-slide-loading');

        this.view = null;
        this.index = -1;

        this.__width = 0;
        this.__height = 0;

        this.fillMode = 'fill'; // fill , fit , stretch , tile , center

        this.selected = false;
        this.pselected = false;
        this.autoAppend = true;
        this.isSleeping = true;

        this.moz = $.browser.mozilla;
    };

    var p = MSSlide.prototype;

    /**
     * on swipe start handler
     */
    p.onSwipeStart = function () {
        //this.$layers.css(window._csspfx + 'transition-duration' , '0ms');
        if (this.link) {
            this.linkdis = true;
        }

        if (this.video) {
            this.videodis = true;
        }
    };

    /**
     * on swipe move handler
     */
    p.onSwipeMove = function (e) {
        var move = Math.max(Math.abs(e.data.distanceX), Math.abs(e.data.distanceY));
        this.swipeMoved = move > 4;
    };

    /**
     * on swipe cancel handler
     */
    p.onSwipeCancel = function (e) {
        if (this.swipeMoved) {
            this.swipeMoved = false;
            return;
        }

        if (this.link) {
            this.linkdis = false;
        }

        if (this.video) {
            this.videodis = false;
        }
        //this.$layers.css(window._csspfx + 'transition-duration' , this.view.__slideDuration + 'ms');
    };

    /**
     * setup layer controller for the slide
     * @since 2.11.0
     */
    p.setupLayerController = function () {
        this.hasLayers = true;
        this.layerController = new MSLayerController(this);
    };
    /**
     * this method called after loading all assets related to this slide
     */
    p.assetsLoaded = function () {
        this.ready = true;
        this.slider.api._startTimer();

        if (this.selected || (this.pselected && this.slider.options.instantStartLayers)) {

            if (this.hasLayers) {
                this.layerController.showLayers();
            }

            if (this.vinit) {
                this.bgvideo.play();
                if (!this.autoPauseBgVid) {
                    this.bgvideo.currentTime = 0;
                }
            }

        }
        if (!this.isSleeping) {
            this.setupBG();
        }

        CTween.fadeOut(this.$loading, 300, true);

        //sequence loading
        if ((this.slider.options.preload === 0 || this.slider.options.preload === 'all') && this.index < this.view.slideList.length - 1) {
            this.view.slideList[this.index + 1].loadImages();
        } else if (this.slider.options.preload === 'all' && this.index === this.view.slideList.length - 1) {
            this.slider._removeLoading();
        }

    };

    /**
     * adds backgroun image to the slider
     * @param {Element} img slide image element
     */
    p.setBG = function (img) {
        this.hasBG = true;
        var that = this;

        this.$imgcont = $('<div></div>').addClass('ms-slide-bgcont');

        this.$element.append(this.$loading)
            .append(this.$imgcont);

        this.$bg_img = $(img).css('visibility', 'hidden');
        this.$imgcont.append(this.$bg_img);

        this.bgAligner = new MSAligner(that.fillMode, that.$imgcont, that.$bg_img);
        this.bgAligner.widthOnly = this.slider.options.autoHeight;

        if (that.slider.options.autoHeight && (that.pselected || that.selected)) {
            that.slider.setHeight(that.slider.options.height);
        }

        if (this.$bg_img.data('src') !== undefined) {
            this.bg_src = this.$bg_img.data('src');
            this.$bg_img.removeAttr('data-src');
        } else {
            this.$bg_img.one('load', function (event) {
                    that._onBGLoad(event);
                })
                .each($.jqLoadFix);
        }

    };

    /**
     * align and resize backgrund image over slide
     */
    p.setupBG = function () {

        //if(this.isSettedup) return;
        //this.isSettedup = true;

        if (!this.initBG && this.bgLoaded) {
            this.initBG = true;
            this.$bg_img.css('visibility', '');
            this.bgWidth = this.bgNatrualWidth || this.$bg_img.width();
            this.bgHeight = this.bgNatrualHeight || this.$bg_img.height();

            CTween.fadeIn(this.$imgcont, 300);

            if (this.slider.options.autoHeight) {
                this.$imgcont.height(this.bgHeight * this.ratio);
            }

            this.bgAligner.init(this.bgWidth, this.bgHeight);
            this.setSize(this.__width, this.__height);

            if (this.slider.options.autoHeight && (this.pselected || this.selected))
                this.slider.setHeight(this.getHeight());
        }

    };



    /**
     * start loading images
     */
    p.loadImages = function () {
        if (this.ls) {
            return;
        }

        this.ls = true;

        if (this.bgvideo) {
            this.bgvideo.load();
        }
        if (this.hasBG && this.bg_src) {
            var that = this;
            this.$bg_img.preloadImg(this.bg_src, function (event) {
                that._onBGLoad(event);
            });
        }

        if (this.hasLayers) {
            this.layerController.loadLayers(this._onLayersLoad);
        }
        // There is nothing to preload? so slide is ready to show.
        if (!this.hasBG && !this.hasLayers) {
            this.assetsLoaded();
        }

    };

    /**
     * layerController on assets load callback
     */
    p._onLayersLoad = function () {
        this.layersLoaded = true;
        if (!this.hasBG || this.bgLoaded) {
            this.assetsLoaded();
        }
    };
    /**
     * on background image loaded
     * @param  {Event} event
     */
    p._onBGLoad = function (event) {
        this.bgNatrualWidth = event.width;
        this.bgNatrualHeight = event.height;

        this.bgLoaded = true;

        if ($.browser.msie) {
            this.$bg_img.on('dragstart', function (event) {
                event.preventDefault();
            }); // disables native dragging
        }

        if (!this.hasLayers || this.layerController.ready) {
            this.assetsLoaded();
        }
    };

    /* -----------------------------------------------------*/

    /**
     * add video background to the slide
     * @param {jQuery Element} $video
     */
    p.setBGVideo = function ($video) {

        if (!$video[0].play) {
            return;
        }

        // disables video in mobile devices
        if (window._mobile && !this.slider.options.mobileBGVideo) {
            $video.remove();
            return;
        }

        this.bgvideo = $video[0];
        var that = this;

        $video.addClass('ms-slide-bgvideo');

        if ($video.data('loop') !== false) {
            this.bgvideo.addEventListener('ended', function () {
                //that.bgvideo.currentTime = -1;
                that.bgvideo.play();
            });
        }

        if ($video.data('mute') !== false) {
            this.bgvideo.muted = true;
        }

        if ($video.data('autopause') === true) {
            this.autoPauseBgVid = true;
        }

        this.bgvideo_fillmode = $video.data('fill-mode') || 'fill'; // fill , fit , none

        if (this.bgvideo_fillmode !== 'none') {
            this.bgVideoAligner = new MSAligner(this.bgvideo_fillmode, this.$element, $video);

            this.bgvideo.addEventListener('loadedmetadata', function () {
                if (that.vinit) return;

                that.vinit = true;
                that.video_aspect = that.bgVideoAligner.baseHeight / that.bgVideoAligner.baseWidth;
                that.bgVideoAligner.init(that.bgvideo.videoWidth, that.bgvideo.videoHeight);
                that._alignBGVideo();
                CTween.fadeIn($(that.bgvideo), 200);

                if (that.selected) {
                    that.bgvideo.play();
                }
            });
        }

        $video.css('opacity', 0);

        this.$bgvideocont = $('<div></div>').addClass('ms-slide-bgvideocont').append($video);

        if (this.hasBG) {
            this.$imgcont.before(this.$bgvideocont);
        } else {
            this.$bgvideocont.appendTo(this.$element);
        }
    };

    /**
     * align video in slide
     */
    p._alignBGVideo = function () {
        if (!this.bgvideo_fillmode || this.bgvideo_fillmode === 'none') {
            return;
        }
        this.bgVideoAligner.align();
    };

    /* -----------------------------------------------------*/

    /**
     * resize slide
     * @param {Number} width
     * @param {Number} height
     * @param {Boolean} hard   after resizing reinitializes layers
     */
    p.setSize = function (width, height, hard) {

        this.__width = width;

        if (this.slider.options.autoHeight) {
            if (this.bgLoaded) {
                this.ratio = this.__width / this.bgWidth;
                height = Math.floor(this.ratio * this.bgHeight);
                this.$imgcont.height(height);
            } else {
                this.ratio = width / this.slider.options.width;
                height = this.slider.options.height * this.ratio;
            }
        }

        this.__height = height;
        this.$element.width(width).height(height);

        if (this.hasBG && this.bgLoaded) this.bgAligner.align();

        this._alignBGVideo();

        if (this.hasLayers) {
            this.layerController.setSize(width, height, hard);
        }
    };

    /**
     * calculates slide height
     * @return {Number} slide height
     */
    p.getHeight = function () {

        if (this.hasBG && this.bgLoaded) {
            return this.bgHeight * this.ratio;
        }

        return Math.max(this.$element[0].clientHeight, this.slider.options.height * this.ratio);
    };

    /* -----------------------------------------------------*/
    // YouTube and Vimeo videos

    /**
     * playe embeded video
     */
    p.__playVideo = function () {

        if (this.vplayed || this.videodis) {
            return;
        }

        this.vplayed = true;

        if (!this.slider.api.paused) {
            this.slider.api.pause();
            this.roc = true; // resume on close;
        }

        this.vcbtn.css('display', '');
        CTween.fadeOut(this.vpbtn, 500, false);
        CTween.fadeIn(this.vcbtn, 500);
        CTween.fadeIn(this.vframe, 500);
        this.vframe.css('display', 'block').attr('src', this.video + '&autoplay=1');
        this.view.$element.addClass('ms-def-cursor');

        // remove perspective style from view if it's Firefox.
        // it fixes video fullscreen issue in Firefox
        if (this.moz) {
            this.view.$element.css('perspective', 'none');
        }

        // if swipe navigation enabled
        if (this.view.swipeControl) {
            this.view.swipeControl.disable();
        }

        this.slider.slideController.dispatchEvent(new MSSliderEvent(MSSliderEvent.VIDEO_PLAY));
    };

    /**
     * close embeded video
     */
    p.__closeVideo = function () {

        if (!this.vplayed) {
            return;
        }

        this.vplayed = false;

        if (this.roc) {
            this.slider.api.resume();
        }

        var that = this;

        CTween.fadeIn(this.vpbtn, 500);
        CTween.animate(this.vcbtn, 500, {
            opacity: 0
        }, {
            complete: function () {
                that.vcbtn.css('display', 'none');
            }
        });
        CTween.animate(this.vframe, 500, {
            opacity: 0
        }, {
            complete: function () {
                that.vframe.attr('src', 'about:blank').css('display', 'none');
            }
        });

        //  video fullscreen issue in Firefox
        if (this.moz) {
            this.view.$element.css('perspective', '');
        }

        // if swipe navigation enabled
        if (this.view.swipeControl) {
            this.view.swipeControl.enable();
        }

        this.view.$element.removeClass('ms-def-cursor');
        this.slider.slideController.dispatchEvent(new MSSliderEvent(MSSliderEvent.VIDEO_CLOSE));
    };

    /* -----------------------------------------------------*/

    /**
     * create slide - it adds requierd elements over slide
     */
    p.create = function () {
        var that = this;

        if (this.hasLayers) {
            this.layerController.create();
        }
        if (this.link) {
            this.link.addClass('ms-slide-link').html('').click(function (e) {
                if (that.linkdis) {
                    e.preventDefault();
                }
            });

            // this.$element.css('cursor' , 'pointer')
            //           .click(function(){ if(!that.linkdis) window.open(that.link , that.link_targ || '_self'); });
        }

        if (this.video) {

            if (this.video.indexOf('?') === -1) {
                this.video += '?';
            }

            this.vframe = $('<iframe></iframe>')
                .addClass('ms-slide-video')
                .css({
                    width: '100%',
                    height: '100%',
                    display: 'none'
                })
                .attr('src', 'about:blank')
                .attr('allowfullscreen', 'true')
                .appendTo(this.$element);

            this.vpbtn = $('<div></div>')
                .addClass('ms-slide-vpbtn')
                .click(function () {
                    that.__playVideo();
                })
                .appendTo(this.$element);

            this.vcbtn = $('<div></div>')
                .addClass('ms-slide-vcbtn')
                .click(function () {
                    that.__closeVideo();
                })
                .appendTo(this.$element)
                .css('display', 'none');

            if (window._touch) {
                this.vcbtn.removeClass('ms-slide-vcbtn')
                    .addClass('ms-slide-vcbtn-mobile')
                    .append('<div class="ms-vcbtn-txt">Close video</div>')
                    .appendTo(this.view.$element.parent());
            }
        }

        if (!this.slider.options.autoHeight && this.hasBG) {
            this.$imgcont.css('height', '100%');

            if (this.fillMode === 'center' || this.fillMode === 'stretch') {
                this.fillMode = 'fill';
            }
        }

        if (this.slider.options.autoHeight) {
            this.$element.addClass('ms-slide-auto-height');
        }

        this.sleep(true);
    };

    /**
     * destory the slide
     */
    p.destroy = function () {
        if (this.hasLayers) {
            this.layerController.destroy();
            this.layerController = null;
        }
        this.$element.remove();
        this.$element = null;
    };

    /**
     * everything require to do before selecting slide
     */
    p.prepareToSelect = function () {

        if (this.pselected || this.selected) {
            return;
        }

        this.pselected = true;

        if (this.link || this.video) {
            this.view.addEventListener(MSViewEvents.SWIPE_START, this.onSwipeStart, this);
            this.view.addEventListener(MSViewEvents.SWIPE_MOVE, this.onSwipeMove, this);
            this.view.addEventListener(MSViewEvents.SWIPE_CANCEL, this.onSwipeCancel, this);
            this.linkdis = false;
            this.swipeMoved = false;
        }

        this.loadImages();

        if (this.hasLayers) {
            this.layerController.prepareToShow();
        }

        if (this.ready) {
            if (this.bgvideo) {
                this.bgvideo.play();
            }

            if (this.hasLayers && this.slider.options.instantStartLayers) {
                this.layerController.showLayers();
            }
        }
        if (this.moz) {
            this.$element.css('margin-top', '');
        }


    };

    /*p.prepareToUnselect = function(){
        if(!this.pselected || !this.selected) return;

        this.pselected = false;

    };*/

    /**
     * select slide
     */
    p.select = function () {
        if (this.selected) {
            return;
        }

        this.selected = true;
        this.pselected = false;
        this.$element.addClass('ms-sl-selected');

        if (this.hasLayers) {

            if (this.slider.options.autoHeight) {
                this.layerController.updateHeight();
            }

            if (!this.slider.options.instantStartLayers) {
                this.layerController.showLayers();
            }

            //this.view.addEventListener(MSViewEvents.SCROLL        , this.updateLayers  , this)
        }


        if (this.ready && this.bgvideo) {
            this.bgvideo.play();
        }
        // @since 1.8.0
        // Autoplay iframe video
        if (this.videoAutoPlay) {
            this.videodis = false;
            this.vpbtn.trigger('click');
        }

    };

    /**
     * remove selected status
     */
    p.unselect = function () {
        this.pselected = false;

        if (this.moz) {
            this.$element.css('margin-top', '0.1px');
        }

        if (this.link || this.video) {
            this.view.removeEventListener(MSViewEvents.SWIPE_START, this.onSwipeStart, this);
            this.view.removeEventListener(MSViewEvents.SWIPE_MOVE, this.onSwipeMove, this);
            this.view.removeEventListener(MSViewEvents.SWIPE_CANCEL, this.onSwipeCancel, this);
        }

        if (this.bgvideo) {
            this.bgvideo.pause();
            if (!this.autoPauseBgVid && this.vinit)
                this.bgvideo.currentTime = 0;
        }

        // hide layers
        if (this.hasLayers) {
            this.layerController.hideLayers();
        }
        if (!this.selected) {
            return;
        }

        this.selected = false;

        this.$element.removeClass('ms-sl-selected');
        if (this.video && this.vplayed) {
            this.__closeVideo();
            this.roc = false;
        }

    };

    /**
     * remove slide from DOM
     */
    p.sleep = function (force) {
        if (this.isSleeping && !force) {
            return;
        }

        this.isSleeping = true;

        if (this.autoAppend) {
            this.$element.detach();
        }

        if (this.hasLayers) {
            this.layerController.onSlideSleep();
        }
    };

    /**
     * add slide to the DOM
     */
    p.wakeup = function () {
        if (!this.isSleeping) {
            return;
        }

        this.isSleeping = false;

        if (this.autoAppend) {
            this.view.$slideCont.append(this.$element);
        }

        if (this.moz) {
            this.$element.css('margin-top', '0.1px');
        }

        this.setupBG();

        // aling bg
        if (this.hasBG) {
            this.bgAligner.align();
        }

        if (this.hasLayers) {
            this.layerController.onSlideWakeup();
        }
    };

})(window, document, jQuery);

/* ================== bin-debug/js/pro/controls/SlideController.js =================== */
;
(function ($) {

    "use strict";

    var SliderViewList = {};

    window.MSSlideController = function (slider) {

        this._delayProgress = 0;

        this._timer = new averta.Timer(100);
        this._timer.onTimer = this.onTimer;
        this._timer.refrence = this;

        this.currentSlide = null;

        this.slider = slider;
        this.so = slider.options;

        averta.EventDispatcher.call(this);

    };

    MSSlideController.registerView = function (name, _class) {
        if (name in SliderViewList) {
            throw new Error(name + ', is already registered.');
            return;
        }

        SliderViewList[name] = _class;
    };

    MSSlideController.SliderControlList = {};
    MSSlideController.registerControl = function (name, _class) {
        if (name in MSSlideController.SliderControlList) {
            throw new Error(name + ', is already registered.');
            return;
        }

        MSSlideController.SliderControlList[name] = _class;
    };

    var p = MSSlideController.prototype;

    /*-------------- METHODS --------------*/


    p.setupView = function () {

        var that = this;
        this.resize_listener = function () {
            that.__resize();
        };

        // in @version 1.5.7 it will be added in Masterslider.js _setupSliderLayout function
        //$(window).bind('resize', this.resize_listener);

        //if(this.so.smoothHeight) this.so.autoHeight = true;

        var viewOptions = {
            spacing: this.so.space,
            mouseSwipe: this.so.mouse,
            loop: this.so.loop,
            autoHeight: this.so.autoHeight,
            swipe: this.so.swipe,
            speed: this.so.speed,
            dir: this.so.dir,
            viewNum: this.so.inView,
            critMargin: this.so.critMargin
        };

        if (this.so.viewOptions)
            $.extend(viewOptions, this.so.viewOptions);

        if (this.so.autoHeight) this.so.heightLimit = false;

        //this.view.slideDuration = this.so.duration;

        var viewClass = SliderViewList[this.slider.options.view] || MSBasicView;
        if (viewClass._3dreq && (!window._css3d || $.browser.msie)) viewClass = viewClass._fallback || MSBasicView;

        this.view = new viewClass(viewOptions);

        if (this.so.overPause) {
            var that = this;
            this.slider.$element.mouseenter(function () {
                that.is_over = true;
                that._stopTimer();
            }).mouseleave(function () {
                that.is_over = false;
                that._startTimer();
            });
        }
    };

    p.onChangeStart = function () {

        this.change_started = true;

        if (this.currentSlide) this.currentSlide.unselect();
        this.currentSlide = this.view.currentSlide;
        this.currentSlide.prepareToSelect();
        //this.__appendSlides();
        if (this.so.endPause && this.currentSlide.index === this.slider.slides.length - 1) {
            this.pause();
            //this._timer.reset();
            this.skipTimer();
        }

        if (this.so.autoHeight) {
            this.slider.setHeight(this.currentSlide.getHeight());
        }

        if (this.so.deepLink) {
            this.__updateWindowHash();
        }

        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.CHANGE_START));
    };

    p.onChangeEnd = function () {
        //if(!this.currentSlide.selected)
        //	this._timer.reset();
        this.change_started = false;

        this._startTimer();
        this.currentSlide.select();

        if (this.so.preload > 1) {
            var loc, i, l = this.so.preload - 1,
                slide;

            // next slides
            for (i = 1; i <= l; ++i) {
                loc = this.view.index + i;

                if (loc >= this.view.slideList.length) {
                    if (this.so.loop) {
                        loc = loc - this.view.slideList.length;
                    } else {
                        i = l;
                        continue;
                    }
                }

                slide = this.view.slideList[loc];
                if (slide) {
                    slide.loadImages();
                }

            }

            // previous slides
            if (l > this.view.slideList.length / 2)
                l = Math.floor(this.view.slideList.length / 2);

            for (i = 1; i <= l; ++i) {

                loc = this.view.index - i;

                if (loc < 0) {
                    if (this.so.loop) {
                        loc = this.view.slideList.length + loc;
                    } else {
                        i = l;
                        continue;
                    }
                }

                slide = this.view.slideList[loc];
                if (slide) {
                    slide.loadImages();
                }

            }
        }

        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.CHANGE_END));

    };

    p.onSwipeStart = function () {
        //this._timer.reset();
        this.skipTimer();
    };

    p.skipTimer = function () {
        this._timer.reset();
        this._delayProgress = 0;
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.WAITING));
    };

    p.onTimer = function (time) {

        if (this._timer.getTime() >= this.view.currentSlide.delay * 1000) {
            //this._timer.reset();
            this.skipTimer();
            this.view.next();
            this.hideCalled = false;
        }
        this._delayProgress = this._timer.getTime() / (this.view.currentSlide.delay * 10);

        if (this.so.hideLayers && !this.hideCalled && this.view.currentSlide.delay * 1000 - this._timer.getTime() <= 300) {
            var currentSlide = this.view.currentSlide;
            if (currentSlide.hasLayers) {
                currentSlide.layerController.animHideLayers();
            }
            this.hideCalled = true;
        }

        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.WAITING));
    };

    p._stopTimer = function () {
        if (this._timer)
            this._timer.stop();
    };

    p._startTimer = function () {
        if (!this.paused && !this.is_over && this.currentSlide && this.currentSlide.ready && !this.change_started)
            this._timer.start();
    };

    p.__appendSlides = function () {
        var slide, loc, i = 0,
            l = this.view.slideList.length - 1;

        // detach all
        for (i; i < l; ++i) {
            slide = this.view.slideList[i];
            if (!slide.detached) {
                slide.$element.detach();
                slide.detached = true;
            }
        }

        // append current slide
        this.view.appendSlide(this.view.slideList[this.view.index]);

        l = 3;

        // next slides
        for (i = 1; i <= l; ++i) {
            loc = this.view.index + i;

            if (loc >= this.view.slideList.length) {
                if (this.so.loop) {
                    loc = loc - this.view.slideList.length;
                } else {
                    i = l;
                    continue;
                }
            }

            slide = this.view.slideList[loc];
            slide.detached = false;
            this.view.appendSlide(slide);

        }

        // previous slides
        if (l > this.view.slideList.length / 2)
            l = Math.floor(this.view.slideList.length / 2);

        for (i = 1; i <= l; ++i) {

            loc = this.view.index - i;

            if (loc < 0) {
                if (this.so.loop) {
                    loc = this.view.slideList.length + loc;
                } else {
                    i = l;
                    continue;
                }
            }

            slide = this.view.slideList[loc];
            slide.detached = false;
            this.view.appendSlide(slide);
        }

    }

    p.__resize = function (hard) {
        if (!this.created) return;

        this.width = this.slider.$element[0].clientWidth || this.so.width;

        if (!this.so.fullwidth) {
            this.width = Math.min(this.width, this.so.width);
            //this.view.$element.css('left' , (this.slider.$element[0].clientWidth - this.width) / 2 + 'px');
        }

        if (this.so.fullheight) {
            this.so.heightLimit = false;
            this.so.autoHeight = false;
            this.height = this.slider.$element[0].clientHeight;
        } else {
            this.height = this.width / this.slider.aspect;
        }
        if (this.so.autoHeight) {
            this.currentSlide.setSize(this.width, null, hard);
            this.view.setSize(this.width, this.currentSlide.getHeight(), hard);
        } else {
            this.view.setSize(this.width, (Math.max(this.so.minHeight, (this.so.heightLimit ? Math.min(this.height, this.so.height) : this.height))), hard);
        }

        if (this.slider.$controlsCont) {
            if (this.so.centerControls && this.so.fullwidth) {
                this.view.$element.css('left', Math.min(0, -(this.slider.$element[0].clientWidth - this.so.width) / 2) + 'px');
            }
        }

        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.RESIZE));
    };

    p.__dispatchInit = function () {
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.INIT));
    };

    /**
     * used by deep link feature, uptades window hash value on slide changes
     * @since 2.1.0
     */
    p.__updateWindowHash = function () {
        var hash = window.location.hash,
            dl = this.so.deepLink,
            dlt = this.so.deepLinkType,
            eq = dlt === 'path' ? '\/' : '=',
            sep = dlt === 'path' ? '\/' : '&',
            sliderHash = dl + eq + (this.view.index + 1),
            regTest = new RegExp(dl + eq + '[0-9]+', 'g');

        if (hash === '') {
            window.location.hash = sep + sliderHash;
        } else if (regTest.test(hash)) {
            window.location.hash = hash.replace(regTest, sliderHash);
        } else {
            window.location.hash = hash + sep + sliderHash;
        }
    };

    p.__curentSlideInHash = function () {
        var hash = window.location.hash,
            dl = this.so.deepLink,
            dlt = this.so.deepLinkType,
            eq = dlt === 'path' ? '\/' : '=',
            regTest = new RegExp(dl + eq + '[0-9]+', 'g');

        if (regTest.test(hash)) {
            var index = Number(hash.match(regTest)[0].match(/[0-9]+/g).pop());
            if (!isNaN(index)) {
                return index - 1;
            }
        }

        return -1;
    };

    p.__onHashChanged = function () {
        var index = this.__curentSlideInHash();
        if (index !== -1) {
            this.gotoSlide(index);
        }
    };

    p.__findLayerById = function (layerId) {

        if (!this.currentSlide) {
            return null;
        }
        var layer;

        if (this.currentSlide.layerController) {
            layer = this.currentSlide.layerController.getLayerById(layerId);
        }

        if (!layer && this.slider.overlayLayers) {
            return this.slider.overlayLayers.layerController.getLayerById(layerId);
        }

        return layer;
    };

    p.setup = function () {

        this.created = true;
        this.paused = !this.so.autoplay;

        //this.slider.$element.append(this.view.$element);
        this.view.addEventListener(MSViewEvents.CHANGE_START, this.onChangeStart, this);
        this.view.addEventListener(MSViewEvents.CHANGE_END, this.onChangeEnd, this);
        this.view.addEventListener(MSViewEvents.SWIPE_START, this.onSwipeStart, this);

        //this.currentSlide = this.view.slides[this.so.start - 1];
        this.currentSlide = this.view.slideList[this.so.start - 1];
        this.__resize();

        var slideInHash = this.__curentSlideInHash(),
            startSlide = slideInHash !== -1 ? slideInHash : this.so.start - 1;
        this.view.create(startSlide);

        if (this.so.preload === 0) {
            this.view.slideList[0].loadImages();
        }

        this.scroller = this.view.controller;

        if (this.so.wheel) {
            var that = this;
            var last_time = new Date().getTime();
            this.wheellistener = function (event) {

                var e = window.event || event.orginalEvent || event;
                e.preventDefault();

                var current_time = new Date().getTime();
                if (current_time - last_time < 400) return;
                last_time = current_time;

                var delta = Math.abs(e.detail || e.wheelDelta);

                if ($.browser.mozilla) {
                    delta *= 100;
                }

                var scrollThreshold = 15;

                // --- Scrolling up ---
                if (e.detail < 0 || e.wheelDelta > 0) {
                    if (delta >= scrollThreshold) {
                        that.previous(true);
                    }
                }
                // --- Scrolling down ---
                else {
                    if (delta >= scrollThreshold) {
                        that.next(true);
                    }
                }

                return false;
            };

            if ($.browser.mozilla) this.slider.$element[0].addEventListener('DOMMouseScroll', this.wheellistener);
            else this.slider.$element.bind('mousewheel', this.wheellistener);
        }

        // if(this.so.wheel){
        // 	var that = this;
        // 	var last_time = new Date().getTime();
        // 	this.wheellistener = function(event){
        // 		var current_time = new Date().getTime();
        // 		if(current_time - last_time < 550) return;
        // 		last_time = current_time;
        // 		var e = window.event || event.orginalEvent || event;
        // 		var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
        // 		if(delta < 0)		that.next();
        // 		else if(delta > 0)	that.previous();
        // 		return false;
        // 	};

        // 	if($.browser.mozilla) this.slider.$element[0].addEventListener('DOMMouseScroll' , this.wheellistener);
        // 	else this.slider.$element.bind('mousewheel', this.wheellistener);
        // }

        if (this.slider.$element[0].clientWidth === 0)
            this.slider.init_safemode = true;

        this.__resize();

        var that = this;
        if (this.so.deepLink) {
            $(window).on('hashchange', function () {
                that.__onHashChanged();
            });
        }
    };

    p.index = function () {
        return this.view.index;
    };

    p.count = function () {
        return this.view.slidesCount;
    };

    p.next = function (checkLoop) {
        this.skipTimer();
        this.view.next(checkLoop);
    };

    p.previous = function (checkLoop) {
        this.skipTimer();
        this.view.previous(checkLoop);
    };

    p.gotoSlide = function (index) {
        index = Math.min(index, this.count() - 1);
        this.skipTimer();
        this.view.gotoSlide(index);
    };

    p.destroy = function (reset) {
        this.dispatchEvent(new MSSliderEvent(MSSliderEvent.DESTROY));
        this.slider.destroy(reset);
    };

    p._destroy = function () {
        this._timer.reset();
        this._timer = null;

        $(window).unbind('resize', this.resize_listener);
        this.view.destroy();
        this.view = null;

        if (this.so.wheel) {
            if ($.browser.mozilla) this.slider.$element[0].removeEventListener('DOMMouseScroll', this.wheellistener);
            else this.slider.$element.unbind('mousewheel', this.wheellistener);
            this.wheellistener = null;
        }

        this.so = null;
    };

    /**
     * run layer actions like next, previous,...
     * @param  {String} action
     * @since v1.7.2
     */
    p.runAction = function (action) {
        var actionParams = [];

        if (action.indexOf('(') !== -1) {
            var temp = action.slice(0, action.indexOf('('));
            actionParams = action.slice(action.indexOf('(') + 1, -1).replace(/\"|\'|\s/g, '').split(',');
            action = temp;
        }

        if (action in this) {
            this[action].apply(this, actionParams);
        } else if (console) {
            console.log('Master Slider Error: Action "' + action + '" not found.');
        }
    };

    p.update = function (hard) {
        if (this.slider.init_safemode && hard)
            this.slider.init_safemode = false;
        this.__resize(hard);

        if (hard) {
            this.dispatchEvent(new MSSliderEvent(MSSliderEvent.HARD_UPDATE));
        }

    };

    p.locate = function () {
        this.__resize();
    };

    p.resume = function () {
        if (!this.paused) return;
        this.paused = false;
        this._startTimer();
    };

    p.pause = function () {
        if (this.paused) return;
        this.paused = true;
        this._stopTimer();
    };

    p.currentTime = function () {
        return this._delayProgress;
    };


    p.showLayer = function (layerId, delay) {
        var layer = this.__findLayerById(layerId);
        if (layer) {
            if (!delay) {
                layer.start();
            } else {
                clearTimeout(layer.actionTimeout);
                layer.actionTimeout = setTimeout(this.showLayer, delay, layerId, 0);
            }
        }
    };

    p.hideLayer = function (layerId, delay) {
        var layer = this.__findLayerById(layerId);
        if (layer) {
            if (!delay) {
                layer.hide();
            } else {
                clearTimeout(layer.actionTimeout);
                layer.actionTimeout = setTimeout(this.hideLayer, delay, layerId, 0);
            }
        }
    }

    p.toggleLayer = function (layerId, delay) {
        var layer = this.__findLayerById(layerId);
        if (layer) {
            if (!delay) {
                layer.isShowing ? layer.hide() : layer.start();
            } else {
                clearTimeout(layer.actionTimeout);
                layer.actionTimeout = setTimeout(this.toggleLayer, delay, layerId, 0);
            }
        }
    }

    p.showLayers = function (layerIds, delay) {
        var self = this;
        $.each(layerIds.replace(/\s+/g, '').split('|'), function (index, layerId) {
            self.showLayer(layerId, delay);
        });
    };


    p.hideLayers = function (layerIds, delay) {
        var self = this;
        $.each(layerIds.replace(/\s+/g, '').split('|'), function (index, layerId) {
            self.hideLayer(layerId, delay);
        });
    };

    p.toggleLayers = function (layerIds, delay) {
        var self = this;
        $.each(layerIds.replace(/\s+/g, '').split('|'), function (index, layerId) {
            self.toggleLayer(layerId, delay);
        });
    };

    averta.EventDispatcher.extend(p);
})(jQuery);

/* ================== bin-debug/js/pro/MasterSlider.js =================== */
/**
 * Master Slider Main JavaScript File
 */

;
(function ($) {

    "use strict";

    var LayerTypes = {
        'image': MSImageLayerElement,
        'text': MSLayerElement,
        'video': MSVideoLayerElement,
        'hotspot': MSHotspotLayer,
        'button': MSButtonLayer
    };
    window.MasterSlider = function () {

        // Default Options
        this.options = {
            forceInit: true, // Force calling init even an error occurs in jQuery's dom ready method.
            autoplay: false, // Enables the autoplay slideshow.
            loop: false, // Enables the continuous sliding mode.
            mouse: true, // Whether the user can use mouse drag navigation.
            swipe: true, // Whether the drag/swipe navigation is enabled.
            grabCursor: true, // Whether the slider uses grab mouse cursor.
            space: 0, // The spacing value between slides in pixels.
            fillMode: 'fill', // Specifies the slide background scaling method. Its acceptable values are "fill", "fit", "stretch", "center" and "tile".
            start: 1, // The slider starting slide number.
            view: 'basic', // The slide changing transition.
            width: 300, // The base width of slides. It helps the slider to resize in correct ratio.
            height: 150, // The base height of slides, It helps the slider to resize in correct ratio.
            inView: 15, // Specifies number of slides which will be added at a same time in DOM.
            critMargin: 1, //
            mobileBGVideo: false, // Whether show background videos in mobile devices.
            heightLimit: true, // It force the slide to use max height value as its base specified height value.
            smoothHeight: true, // Whether the slider uses smooth animation while its height changes.
            autoHeight: false, // Whether the slider adapts its height to each slide height or not. It overrides heightLimit option.
            minHeight: -1, // @since 2.13.0, Specifies min height value for the slider, it prevents slider to shows too narrow in small screens.
            fullwidth: false, // It enables the slider to adapt width to its parent element. It's very useful for creating full-width sliders. In default it takes max width as its base width value.
            fullheight: false, // It enables the slider to adapt height to its parent element.
            autofill: false, // It enables the slider to adapt width and height to its parent element, It's very useful for creating fullscreen or fullwindow slider.
            layersMode: 'center', // It accepts two values "center" and "full". The "center" value indicates that the slider aligns layers to the center. This option is only effective in full width mode.
            hideLayers: false, // Whether the slider hides all layers before changing slide.
            endPause: false, // Whether the slider pauses slideshow when it stays at the last slide.
            centerControls: true, // Whether the slider aligns UI controls to center. This option is only effective in full width mode.
            overPause: true, // Whether the slider pauses slideshow on hover.
            shuffle: false, // Enables the shuffle slide order.
            speed: 17, // Specifies slide changing speed. It accepts float values between 0 and 100.
            dir: 'h', // Specifies slide changing direction. It accepts two values "h" (horizontal) and "v" (vertical).
            preload: 0, // Specifies number of slides which will be loaded by slider. 0 value means the slider loads slides in sequence.
            wheel: false, // Whether slider uses mouse wheel for navigation.
            layout: 'boxed', // It accepts 'fullwidth', 'fullscreen', 'fillwidth', 'autofill', 'partialview', 'boxed'. It overrides 'fullwidth' and 'autofill' (added in v1.5.6)
            autofillTarget: null, // @since 2.13.0, Specifies the parent element of slider width jQuery selector, it used for sizing slider with autofill layout. Default value is the first parent element of slider.
            fullscreenMargin: 0, // Specifies margin amount to the bottom of slider, it's only effective on fullscreen slider.
            instantStartLayers: false, // @since 1.5.0, Whether instantly shows slide layers.
            parallaxMode: 'mouse', // @since 1.6.0, Specifies mode of parallax effect accepts: "mouse", "mouse:x-only", "mouse:y-only" and "swipe"
            rtl: false, // @since 1.8.0, Whether Right-to-left direction slider.
            deepLink: null, // @since 2.1.0, null value disables slider deep-linking any string values identifies the slider in page's url like /#msslider-1
            deepLinkType: 'path', // @since 2.1.0, type of hash value in page's url possible values, path and query (  #gallery/1 || #gallery=4 )
            disablePlugins: [] // @since 2.9.6, list of disabled Master Slider plugin names for this instance.
        };

        this.slides = [];
        this.activePlugins = [];
        this.$element = null;

        // used by new layout method. to force fullwidth or fullscreen
        this.lastMargin = 0;

        // Reserved side spaces of slider
        this.leftSpace = 0;
        this.topSpace = 0;
        this.rightSpace = 0;
        this.bottomSpace = 0;

        // hold on stack
        this._holdOn = 0;

        var that = this;
        this.resize_listener = function () {
            that._resize();
        };
        $(window).bind('resize', this.resize_listener);

    };

    MasterSlider.author = 'Averta Ltd. (www.averta.net)';
    MasterSlider.version = '2.51.2';
    MasterSlider.releaseDate = 'Jun 2017';

    // Master Slider plugins.
    MasterSlider._plugins = []
    var MS = MasterSlider;
    MS.registerPlugin = function (plugin) {
        if (MS._plugins.indexOf(plugin) === -1) {
            MS._plugins.push(plugin);
        }
    };

    var p = MasterSlider.prototype;

    /*-------------- METHODS --------------*/

    /**
     * create one slide object for each slide and add it to slide controller
     * @since 1.0
     * @private
     */
    p.__setupSlides = function () {
        var that = this,
            new_slide,
            ind = 0;

        this.$element.children('.ms-slide').each(function (index) {

            var $slide_ele = $(this);

            new_slide = new MSSlide();
            new_slide.$element = $slide_ele;
            new_slide.slider = that;
            new_slide.delay = $slide_ele.data('delay') !== undefined ? $slide_ele.data('delay') : 3;
            new_slide.fillMode = $slide_ele.data('fill-mode') !== undefined ? $slide_ele.data('fill-mode') : that.options.fillMode;
            new_slide.index = ind++;
            new_slide.id = $slide_ele.data('id');

            // Slide Background Image
            var slide_img = $slide_ele.children('img:not(.ms-layer)');
            if (slide_img.length > 0) {
                new_slide.setBG(slide_img[0]);
            }

            // Slide Video Background
            var slide_video = $slide_ele.children('video');
            if (slide_video.length > 0) new_slide.setBGVideo(slide_video);
            // controls
            if (that.controls) {
                for (var i = 0, l = that.controls.length; i < l; ++i)
                    that.controls[i].slideAction(new_slide);
            }

            // Slide Link and Video
            var slide_link = $slide_ele.children('a').each(function (index) {
                var $this = $(this);
                if (this.getAttribute('data-type') === 'video') {
                    new_slide.video = this.getAttribute('href');

                    new_slide.videoAutoPlay = $this.data('autoplay');

                    $this.remove();
                } else if (!$this.hasClass('ms-layer')) {
                    new_slide.link = $(this);
                    //new_slide.link_targ = this.getAttribute('target');
                    //$this.remove();
                }
            }); //.remove();

            // Slide Layers
            that.__createSlideLayers(new_slide, $slide_ele.find('.ms-layer'));
            that.slides.push(new_slide);
            that.slideController.view.addSlide(new_slide);

        });
    };

    /**
     * Setups the overlay layers to the slider
     * @since 2.50
     */
    p._setupOverlayLayers = function () {
        var self = this,
            $ollayers = this.$element.children('.ms-overlay-layers').eq(0);

        if (!$ollayers.length) {
            return;
        }

        var overlayLayers = new MSOverlayLayers(this);
        overlayLayers.$element = $ollayers;
        self.__createSlideLayers(overlayLayers, $ollayers.find('.ms-layer'));

        this.view.$element.prepend($ollayers);
        this.overlayLayers = overlayLayers;
        overlayLayers.create();
    };

    /**
     * Creates layers of specified layer
     * @param  {MSSlide} slide
     * @param  {Array} layers
     * @since 1.0
     * @private
     */
    p.__createSlideLayers = function (slide, layers) {
        if (layers.length == 0) return;
        slide.setupLayerController();

        layers.each(function (index, domEle) {
            var $layer_element = $(this),
                $parent_ele;

            if (domEle.nodeName === 'A' && $layer_element.find('>img').data('type') === 'image') {
                $parent_ele = $(this);
                $layer_element = $parent_ele.find('img');
            }

            var layer = new(LayerTypes[$layer_element.data('type') || 'text'])();
            layer.$element = $layer_element;
            layer.link = $parent_ele;
            layer.id = layer.$element.data('id');
            layer.waitForAction = layer.$element.data('wait');
            layer.masked = layer.$element.data('masked');
            layer.maskWidth = layer.$element.data('mask-width');
            layer.maskHeight = layer.$element.data('mask-height');

            var eff_parameters = {},
                end_eff_parameters = {};

            if ($layer_element.data('effect') !== undefined) eff_parameters.name = $layer_element.data('effect');
            if ($layer_element.data('ease') !== undefined) eff_parameters.ease = $layer_element.data('ease');
            if ($layer_element.data('duration') !== undefined) eff_parameters.duration = $layer_element.data('duration');
            if ($layer_element.data('delay') !== undefined) eff_parameters.delay = $layer_element.data('delay');

            if ($layer_element.data('hide-effect')) end_eff_parameters.name = $layer_element.data('hide-effect');
            if ($layer_element.data('hide-ease')) end_eff_parameters.ease = $layer_element.data('hide-ease');
            if ($layer_element.data('hide-duration') !== undefined) end_eff_parameters.duration = $layer_element.data('hide-duration');
            if ($layer_element.data('hide-time') !== undefined) end_eff_parameters.time = $layer_element.data('hide-time');


            layer.setStartAnim(eff_parameters);
            layer.setEndAnim(end_eff_parameters);

            slide.layerController.addLayer(layer);

        });

    };
    /**
     * remove slider initialize loading
     * @since 1.0
     * @private
     */
    p._removeLoading = function () {
        $(window).unbind('resize', this.resize_listener);
        this.$element.removeClass('before-init')
            .css('visibility', 'visible')
            .css('height', '')
            .css('opacity', 0);
        CTween.fadeIn(this.$element);
        this.$loading.remove();

        if (this.slideController)
            this.slideController.__resize();
    };

    /**
     * resize listener, it only used for aligning slider loading and after slider init it will be removed
     * @param  {Event} e
     * @since 1.0
     * @private
     */
    p._resize = function (e) {
        if (this.$loading) {
            var h = this.$loading[0].clientWidth / this.aspect;
            h = this.options.heightLimit ? Math.min(h, this.options.height) : h;

            this.$loading.height(h);
            this.$element.height(h);
        }
    };

    /**
     * changes the order of slides element before setup slides
     * @since 1.0
     * @private
     */
    p._shuffleSlides = function () {
        var slides = this.$element.children('.ms-slide'),
            r;

        for (var i = 0, l = slides.length; i < l; ++i) {
            r = Math.floor(Math.random() * (l - 1));
            if (i != r) {
                this.$element[0].insertBefore(slides[i], slides[r]);
                slides = this.$element.children('.ms-slide');
            }
        }
    };

    /**
     * New method of setting up the layout of slider
     * @since 1.5.6
     */
    p._setupSliderLayout = function () {

        // create side spaces
        this._updateSideMargins();
        this.lastMargin = this.leftSpace;

        var lo = this.options.layout;


        if (lo !== 'boxed' && lo !== 'partialview') {
            this.options.fullwidth = true; // enable slider fullscreen for fullwidth, fillwidth, autofill and fullscreen layouts.
        }
        if (lo === 'fullscreen' || lo === 'autofill') {
            this.options.fullheight = true;

            if (lo === 'autofill') {
                this.$autofillTarget = $(this.options.autofillTarget);
                if (this.$autofillTarget.length === 0) {
                    this.$autofillTarget = this.$element.parent();
                }
            }

        }

        // partial view
        if (lo === 'partialview') {
            this.$element.addClass('ms-layout-partialview');
        }
        if (lo === 'fullscreen' || lo === 'fullwidth' || lo === 'autofill') {
            $(window).bind('resize', {
                that: this
            }, this._updateLayout);
            this._updateLayout();
        }

        // bind resize handler of slidecontroller __resize
        $(window).bind('resize', this.slideController.resize_listener);
    };

    /**
     * updates layout of slider based on window size
     * @param  {Event} event
     * @since 1.5.6
     */
    p._updateLayout = function (event) {
        var that = event ? event.data.that : this,
            lo = that.options.layout,
            $element = that.$element,
            $win = $(window);

        // height
        if (lo === 'fullscreen') {
            document.body.style.overflow = 'hidden';
            $element.height($win.height() - that.options.fullscreenMargin - that.topSpace - that.bottomSpace);
            document.body.style.overflow = '';
        } else if (lo === 'autofill') {
            $element.height(that.$autofillTarget.height() - that.options.fullscreenMargin - that.topSpace - that.bottomSpace)
                .width(that.$autofillTarget.width() - that.leftSpace - that.rightSpace);
            return;
        }
        // width
        $element.width($win.width() - that.leftSpace - that.rightSpace);
        var margin = -$element.offset().left + that.leftSpace + that.lastMargin;
        $element.css('margin-left', margin);
        that.lastMargin = margin;
        //
    };


    /**
     * initialize the slider, called by document ready
     * <code>holdOn</code> property prevents auto initialize slider after document ready it used by plugins of slider like Flickr
     * @since 1.0
     * @protected
     */
    p._init = function () {

        if (this._holdOn > 0 || !this._docReady) {
            return;
        }

        this.initialized = true;

        if (this.options.preload !== 'all') {
            this._removeLoading();
        }
        //else
        //	this.$element.css('width' , this.$loading[0].clientWidth);

        if (this.options.shuffle) this._shuffleSlides();

        MSLayerEffects.setup();
        this.slideController.setupView();
        this.view = this.slideController.view;

        this.$controlsCont = $('<div></div>').addClass('ms-inner-controls-cont'); //.appendTo(this.$element);
        if (this.options.centerControls) {
            this.$controlsCont.css('max-width', this.options.width + 'px');
        }

        this.$controlsCont.prepend(this.view.$element);

        this.$msContainer = $('<div></div>').addClass('ms-container').prependTo(this.$element).append(this.$controlsCont);

        if (this.controls) {
            for (var i = 0, l = this.controls.length; i < l; ++i) {
                this.controls[i].setup();
            }
        }
        /*else{
        	this.$element.append(this.view.$element);
        }*/

        this._setupSliderLayout();
        this.__setupSlides();
        this.slideController.setup();
        this._setupOverlayLayers();

        if (this.controls) {
            for (i = 0, l = this.controls.length; i < l; ++i)
                this.controls[i].create();
        }

        if (this.options.autoHeight) {
            this.slideController.view.$element.height(this.slideController.currentSlide.getHeight());
        }

        // add grab cursor
        if (this.options.swipe && !window._touch && this.options.grabCursor && this.options.mouse) {
            var $view = this.view.$element;

            $view.mousedown(function () {
                $view.removeClass('ms-grab-cursor');
                $view.addClass('ms-grabbing-cursor');

                if ($.browser.msie && window.ms_grabbing_curosr) {
                    $view[0].style.cursor = 'url(' + window.ms_grabbing_curosr + '), move';
                }

            }).addClass('ms-grab-cursor');

            $(document).mouseup(function () {
                $view.removeClass('ms-grabbing-cursor');
                $view.addClass('ms-grab-cursor');

                if ($.browser.msie && window.ms_grab_curosr) {
                    $view[0].style.cursor = 'url(' + window.ms_grab_curosr + '), move';
                }

            });
        }

        this.slideController.__dispatchInit();
    };

    /**
     * changes the height of slider, it used in autoheight slider
     * @param {Number} value
     * @since 1.0
     * @public
     */
    p.setHeight = function (value) {
        if (this.options.smoothHeight) {
            if (this.htween) {
                if (this.htween.reset) this.htween.reset();
                else this.htween.stop(true);
            }
            this.htween = CTween.animate(this.slideController.view.$element, 500, {
                height: value
            }, {
                ease: 'easeOutQuart'
            });
        } else
            this.slideController.view.$element.height(value);
    };

    /**
     * reserves white space in sides of slider, it used by controls
     * @param  {String} side  left|right|top|bottom
     * @param  {Number} space
     * @returns {Number} start position in space.
     * @since 1.5.7
     * @public
     */
    p.reserveSpace = function (side, space) {
        var sideSpace = side + 'Space',
            pos = this[sideSpace];

        this[sideSpace] += space;

        this._updateSideMargins();

        return pos;
    };

    /**
     * returns the reserved space, it used by controls and called when aligned control hides
     * @param  {String} side
     * @param  {Number} space
     * @since 1.5.7
     * @public
     */
    /*p.returnSpace = function(side, space){
    	var sideSpace = side+'Space';
    	this[sideSpace] = Math.max(0 , this[sideSpace] - space);

    	this.api.dispatchEvent(new MSSliderEvent(MSSliderEvent.RESERVED_SPACE_CHANGE));
    	this._updateSideMargins();
    };*/

    p._updateSideMargins = function () {
        this.$element.css('margin', this.topSpace + 'px ' + this.rightSpace + 'px ' + this.bottomSpace + 'px ' + this.leftSpace + 'px');
    }

    p._realignControls = function () {
        this.rightSpace = this.leftSpace = this.topSpace = this.bottomSpace = 0;
        this._updateSideMargins();
        this.api.dispatchEvent(new MSSliderEvent(MSSliderEvent.RESERVED_SPACE_CHANGE));
    };

    /*------------------------- Public Methods -----------------------*/

    /**
     * Adds new control to the slider
     * @param  {String} control
     * @param  {Object} options [description]
     * @since 1.0
     * @public
     */
    p.control = function (control, options) {
        if (!(control in MSSlideController.SliderControlList)) return;
        if (!this.controls) this.controls = [];
        var ins = new MSSlideController.SliderControlList[control](options);
        ins.slider = this;
        this.controls.push(ins);

        return this;
    };

    /**
     * Hold on slider from initialization
     * @since 2.9.6
     * @public
     */
    p.holdOn = function () {
        this._holdOn++;
    };

    /**
     * Let the slider to initialize
     * @since 2.9.6
     */
    p.release = function () {
        this._holdOn--;
        this._init();
    };

    /**
     * setup slider
     * @param  {String|jQuery object} id
     * @param  {Object} options
     * @since 1.0
     * @public
     */
    p.setup = function (target, options) {
        if (typeof target === 'string') {
            this.$element = $('#' + target);
        } else {
            this.$element = target.eq(0);
        }

        //create a copy from slider markup, it will be used in destroy method.
        this.setupMarkup = this.$element.html();

        if (this.$element.length === 0) {
            //if(console) console.log('Master Slider Error: #'+id+' not found.');
            return;
        }

        this.$element.addClass('master-slider').addClass('before-init');

        // IE prefix class
        // add browser prefix class name
        if ($.browser.msie) {
            this.$element.addClass('ms-ie')
                .addClass('ms-ie' + $.browser.version.slice(0, $.browser.version.indexOf('.')));
        } else if ($.browser.webkit) {
            this.$element.addClass('ms-wk');
        } else if ($.browser.mozilla) {
            this.$element.addClass('ms-moz');
        }


        // Android prefix class
        var ua = navigator.userAgent.toLowerCase();
        var isAndroid = ua.indexOf("android") > -1;
        if (isAndroid) {
            this.$element.addClass('ms-android');
        }

        var that = this;
        $.extend(this.options, options);

        this.aspect = this.options.width / this.options.height;

        this.$loading = $('<div></div>').
        addClass('ms-loading-container').
        insertBefore(this.$element).
        append($('<div></div>').addClass('ms-loading'));

        this.$loading.parent().css('position', 'relative');

        // old methods
        if (this.options.autofill) {
            this.options.fullwidth = true;
            this.options.fullheight = true;
        }

        if (this.options.fullheight) {
            this.$element.addClass('ms-fullheight');
        }

        //this._setupSliderLayout();
        this._resize();

        // define slide controller and api
        this.slideController = new MSSlideController(this);
        this.api = this.slideController;

        // setup plugins
        for (var i = 0, l = MS._plugins.length; i !== l; i++) {
            var plugin = MS._plugins[i];

            if (this.options.disablePlugins.indexOf(plugin.name) === -1) {
                this.activePlugins.push(new plugin(this));
            }
        }

        if (this.options.forceInit) {
            MasterSlider.addJQReadyErrorCheck(this);
        }

        $(document).ready(function () {
            if (!that.initialized) {
                that._docReady = true;
                that._init();
            }
        });

        return this;
    };

    /**
     * destroy the slider instance
     * @param  {Boolean} insertMarkup	 whether add slider markup after destroy.
     * @since 1.4
     * @public
     */
    p.destroy = function (insertMarkup) {

        // destroy active plugins
        for (var i = 0, l = this.activePlugins.length; i !== l; i++) {
            this.activePlugins[i].destroy();
        }

        if (this.controls) {
            for (i = 0, l = this.controls.length; i !== l; i++)
                this.controls[i].destroy();
        }

        if (this.slideController) this.slideController._destroy();

        if (this.$loading) this.$loading.remove();

        if (insertMarkup) {
            this.$element.html(this.setupMarkup).css('visibility', 'hidden');
        } else {
            this.$element.remove();
        }

        var lo = this.options.layout;
        if (lo === 'fullscreen' || lo === 'fullwidth') {
            $(window).unbind('resize', this._updateLayout);
        }

        this.view = null;
        this.slides = null;
        this.options = null;
        this.slideController = null;
        this.api = null;
        this.resize_listener = null;


        this.activePlugins = null;
    };

})(jQuery);

/**
 * Master Slider jQuery Plugin
 * @author Averta
 */
(function ($, window, document, undefined) {

    var pluginName = "masterslider",
        defaults = {
            controls: {}
        };

    function MasterSliderPlugin(element, options) {
        this.element = element;
        this.$element = $(element);
        this.settings = $.extend({}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.init();
    }

    $.extend(MasterSliderPlugin.prototype, {
        init: function () {

            var self = this;

            // create new instance form Master Slider
            this._slider = new MasterSlider();

            // add controls
            for (var control in this.settings.controls) {
                this._slider.control(control, this.settings.controls[control]);
            }

            this._slider.setup(this.$element, this.settings);

            // override api eventdisaptcher method
            var _superDispatch = this._slider.api.dispatchEvent;
            this._slider.api.dispatchEvent = function (event) {
                self.$element.trigger(event.type);
                _superDispatch.call(this, event);
            };

        },

        api: function () {
            return this._slider.api;
        },

        slider: function () {
            return this._slider;
        }

    });

    $.fn[pluginName] = function (options) {
        var args = arguments,
            plugin = 'plugin_' + pluginName;

        // Is the first parameter an object (options), or was omitted,
        // instantiate a new instance of the plugin.
        if (options === undefined || typeof options === 'object') {
            return this.each(function () {

                // Only allow the plugin to be instantiated once,
                // so we check that the element has no plugin instantiation yet
                if (!$.data(this, plugin)) {
                    $.data(this, plugin, new MasterSliderPlugin(this, options));
                }
            });

            // If the first parameter is a string and it doesn't start
            // with an underscore or "contains" the `init`-function,
            // treat this as a call to a public method.
        } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {

            // Cache the method call
            // to make it possible
            // to return a value
            var returns;

            this.each(function () {
                var instance = $.data(this, plugin);

                // Tests that there's already a plugin-instance
                // and checks that the requested public method exists
                if (instance instanceof MasterSliderPlugin && typeof instance[options] === 'function') {

                    // Call the method of our plugin instance,
                    // and pass it the supplied arguments.
                    returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
                }

                // Map slider api functions to slider jq plugin
                if (instance instanceof MasterSliderPlugin && typeof instance._slider.api[options] === 'function') {
                    returns = instance._slider.api[options].apply(instance._slider.api, Array.prototype.slice.call(args, 1));
                }

                // Allow instances to be destroyed via the 'destroy' method
                if (options === 'destroy') {
                    $.data(this, plugin, null);
                }
            });

            // If the earlier cached method
            // gives a value back return the value,
            // otherwise return this to preserve chainability.
            return returns !== undefined ? returns : this;
        }
    };

})(jQuery, window, document);

;
(function ($, window, document, undefined) {
    "use strict";

    /* ------------------------------------------------------------------------------ */

    var sliderInstances = [];
    MasterSlider.addJQReadyErrorCheck = function (slider) {
        sliderInstances.push(slider);
    };

    var _ready = $.fn.ready,
        _onerror = window.onerror;

    // override jQuery ready
    $.fn.ready = function () {

        // override window on load event
        window.onerror = function () {

            if (sliderInstances.length !== 0) {
                for (var i = 0, l = sliderInstances.length; i !== l; i++) {
                    var slider = sliderInstances[i];
                    if (!slider.initialized) {
                        slider._docReady = true;
                        slider._init();
                    }
                }
            }

            if (_onerror) {
                return _onerror.apply(this, arguments);
            }

            return false;
        }

        return _ready.apply(this, arguments);
    };

})(jQuery, window, document);

/* ================== bin-debug/js/pro/views/ViewEvents.js =================== */
window.MSViewEvents = function (type, data) {
    this.type = type;
    this.data = data;
};

MSViewEvents.SWIPE_START = 'swipeStart';
MSViewEvents.SWIPE_END = 'swipeEnd';
MSViewEvents.SWIPE_MOVE = 'swipeMove';
MSViewEvents.SWIPE_CANCEL = 'swipeCancel';
MSViewEvents.SCROLL = 'scroll';
MSViewEvents.CHANGE_START = 'slideChangeStart';
MSViewEvents.CHANGE_END = 'slideChangeEnd';

/* ================== bin-debug/js/pro/views/BasicView.js =================== */
;
(function ($) {

    "use strict";

    window.MSBasicView = function (options) {

        this.options = {
            loop: false,
            dir: 'h',
            autoHeight: false,
            spacing: 5,
            mouseSwipe: true,
            swipe: true,
            speed: 17,
            minSlideSpeed: 2,
            viewNum: 20,
            critMargin: 1
        };

        $.extend(this.options, options);

        this.dir = this.options.dir;
        this.loop = this.options.loop;
        this.spacing = this.options.spacing;

        this.__width = 0;
        this.__height = 0;

        this.__cssProb = this.dir === 'h' ? 'left' : 'top';
        this.__offset = this.dir === 'h' ? 'offsetLeft' : 'offsetTop';
        this.__dimension = this.dir === 'h' ? '__width' : '__height';

        this.__translate_end = window._css3d ? ' translateZ(0px)' : '';

        this.$slideCont = $('<div></div>').addClass('ms-slide-container');
        this.$element = $('<div></div>').addClass('ms-view').addClass('ms-basic-view').append(this.$slideCont);

        this.currentSlide = null;
        this.index = -1;
        this.slidesCount = 0;

        this.slides = [];
        this.slideList = []; // All of slides with added priority sort;
        this.viewSlidesList = [];

        this.css3 = window._cssanim;
        this.start_buffer = 0;
        this.firstslide_snap = 0;

        this.slideChanged = false;

        this.controller = new Controller(0, 0, {
            snapping: true,
            snapsize: 100,
            paging: true,
            snappingMinSpeed: this.options.minSlideSpeed,
            friction: (100 - this.options.speed * 0.5) / 100,
            endless: this.loop
        });

        this.controller.renderCallback(this.dir === 'h' ? this._horizUpdate : this._vertiUpdate, this);
        this.controller.snappingCallback(this.__snapUpdate, this);
        this.controller.snapCompleteCallback(this.__snapCompelet, this);

        averta.EventDispatcher.call(this);
    };

    var p = MSBasicView.prototype;

    /*-------------- METHODS --------------*/

    p.__snapCompelet = function (snap, type) {
        // if(this.loop && Math.abs(this.__contPos) > 20000){
        // 	this.__locateSlides();
        // 	this.gotoSlide(this.index , true);
        // }
        //

        if (!this.slideChanged) {
            return;
        }

        this.slideChanged = false;

        this.__locateSlides();
        this.start_buffer = 0;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_END));
    };

    p.__snapUpdate = function (controller, snap, change) {

        if (this.loop) {
            var target_index = this.index + change;
            this.updateLoop(target_index);

            if (target_index >= this.slidesCount) target_index = target_index - this.slidesCount;
            if (target_index < 0) target_index = this.slidesCount + target_index;

            this.index = target_index;
        } else {
            if (snap < 0 || snap >= this.slidesCount) return
            this.index = snap;
        }

        this._checkCritMargins();

        if ($.browser.mozilla) {
            this.slideList[this.index].$element[0].style.marginTop = '0.1px';
            if (this.currentSlide) {
                this.currentSlide.$element[0].style.marginTop = '';
            }
        }
        var new_slide = this.slideList[this.index];
        if (new_slide === this.currentSlide) return;
        this.currentSlide = new_slide;

        if (this.autoUpdateZIndex) {
            this.__updateSlidesZindex();
        }

        this.slideChanged = true;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_START));
    };


    p._checkCritMargins = function () {
        if (this.normalMode) return;

        var hlf = Math.floor(this.options.viewNum / 2),
            inView = this.viewSlidesList.indexOf(this.slideList[this.index]),
            size = (this[this.__dimension] + this.spacing),
            cm = this.options.critMargin;

        if (this.loop) {
            if (inView <= cm || inView >= this.viewSlidesList.length - cm) {
                size *= (inView - hlf);
                this.__locateSlides(false, size + this.start_buffer);
                this.start_buffer += size;
            }

            return;
        }

        if ((inView < cm && this.index >= cm) || (inView >= this.viewSlidesList.length - cm && this.index < this.slidesCount - cm)) {
            this.__locateSlides(false);
        }

    };


    p._vertiUpdate = function (controller, value) {

        this.__contPos = value;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.SCROLL));

        if (this.css3) {
            this.$slideCont[0].style[window._jcsspfx + 'Transform'] = 'translateY(' + -value + 'px)' + this.__translate_end;
            return;
        }

        this.$slideCont[0].style.top = -value + 'px';

    };

    p._horizUpdate = function (controller, value) {

        this.__contPos = value;
        this.dispatchEvent(new MSViewEvents(MSViewEvents.SCROLL));

        if (this.css3) {
            this.$slideCont[0].style[window._jcsspfx + 'Transform'] = 'translateX(' + -value + 'px)' + this.__translate_end;
            return;
        }

        this.$slideCont[0].style.left = -value + 'px';

    };


    p.__updateViewList = function () {

        if (this.normalMode) {
            this.viewSlidesList = this.slides;
            return;
        }

        var temp = this.viewSlidesList.slice();

        // update view list
        this.viewSlidesList = [];
        var i = 0,
            hlf = Math.floor(this.options.viewNum / 2),
            l;

        if (this.loop) {
            for (; i !== this.options.viewNum; i++)
                this.viewSlidesList.push(this.slides[this.currentSlideLoc - hlf + i]);
        } else {
            // before
            for (i = 0; i !== hlf && this.index - i !== -1; i++)
                this.viewSlidesList.unshift(this.slideList[this.index - i]);
            // after
            for (i = 1; i !== hlf && this.index + i !== this.slidesCount; i++)
                this.viewSlidesList.push(this.slideList[this.index + i]);
        }

        for (i = 0, l = temp.length; i !== l; i++)
            if (this.viewSlidesList.indexOf(temp[i]) === -1)
                temp[i].sleep();

        temp = null;

        if (this.currentSlide) {
            this.__updateSlidesZindex();
        }
    };

    p.__locateSlides = function (move, start) {

        this.__updateViewList();

        start = !this.loop ? this.slides.indexOf(this.viewSlidesList[0]) * (this[this.__dimension] + this.spacing) : start || 0;

        // old method
        /*for(i = 0; i < this.slidesCount ; ++i){
        	var pos =  i * (this[this.__dimension] + this.spacing);

        	this.slides[i].position = pos;
        	this.slides[i].$element[0].style[this.__cssProb] =  pos + 'px';
        }*/

        var l = this.viewSlidesList.length,
            slide;

        for (var i = 0; i !== l; i++) {
            var pos = start + i * (this[this.__dimension] + this.spacing);
            slide = this.viewSlidesList[i];
            slide.wakeup();
            slide.position = pos;
            slide.$element[0].style[this.__cssProb] = pos + 'px';
        }

        if (move !== false) this.controller.changeTo(this.slideList[this.index].position, false, null, null, false);

    };

    p.__createLoopList = function () {
        var return_arr = [];
        var i = 0,
            count = this.slidesCount / 2;

        var before_count = (this.slidesCount % 2 === 0) ? count - 1 : Math.floor(count);
        var after_count = (this.slidesCount % 2 === 0) ? count : Math.floor(count);

        this.currentSlideLoc = before_count;

        // before
        for (i = 1; i <= before_count; ++i)
            return_arr.unshift(this.slideList[(this.index - i < 0) ? this.slidesCount - i + this.index : this.index - i]);

        // current
        return_arr.push(this.slideList[this.index]);

        // after
        for (i = 1; i <= after_count; ++i)
            return_arr.push(this.slideList[(this.index + i >= this.slidesCount) ? this.index + i - this.slidesCount : this.index + i]);

        return return_arr;

    };

    /*
     * Calculate shortest distance from index to target.
     * It will used in loop gesture.
     *
     * Negative values means left direction.
     */

    p.__getSteps = function (index, target) {
        var right = (target < index) ? this.slidesCount - index + target : target - index;
        var left = Math.abs(this.slidesCount - right);

        return (right < left) ? right : -left;
    };

    p.__pushEnd = function () {
        var first_slide = this.slides.shift();
        var last_slide = this.slides[this.slidesCount - 2];

        this.slides.push(first_slide);

        if (!this.normalMode) return;

        var pos = last_slide.$element[0][this.__offset] + this.spacing + this[this.__dimension];
        first_slide.$element[0].style[this.__cssProb] = pos + 'px';
        first_slide.position = pos;
    };

    p.__pushStart = function () {
        var last_slide = this.slides.pop();
        var first_slide = this.slides[0];

        this.slides.unshift(last_slide);

        if (!this.normalMode) return;

        var pos = first_slide.$element[0][this.__offset] - this.spacing - this[this.__dimension];
        last_slide.$element[0].style[this.__cssProb] = pos + 'px';
        last_slide.position = pos;
    };

    // @since 1.7.0
    // adds z-index to slides
    p.__updateSlidesZindex = function () {


        var slide,
            l = this.viewSlidesList.length,
            hlf = Math.floor(l / 2);

        if (this.loop) {
            var loc = this.viewSlidesList.indexOf(this.currentSlide);
            for (var i = 0; i !== l; i++) {
                slide = this.viewSlidesList[i];
                this.viewSlidesList[i].$element.css('z-index', i <= loc ? i + 1 : l - i);
            }
        } else {

            var beforeNum = this.currentSlide.index - this.viewSlidesList[0].index,
                afterNum = l - beforeNum,
                diff = beforeNum - afterNum;

            for (var i = 0; i !== l; i++) {
                this.viewSlidesList[i].$element.css('z-index', i <= beforeNum ? i + 1 : l - i);
            }

            this.currentSlide.$element.css('z-index', l);
        }

    };

    p.addSlide = function (slide) {
        slide.view = this;
        this.slides.push(slide);
        this.slideList.push(slide);
        this.slidesCount++;
    };

    p.appendSlide = function (slide) {
        this.$slideCont.append(slide.$element);
    };

    p.updateLoop = function (index) {
        if (this.loop) {
            var steps = this.__getSteps(this.index, index);

            for (var i = 0, l = Math.abs(steps); i < l; ++i) {
                if (steps < 0) this.__pushStart();
                else this.__pushEnd();
            }
        }
    };

    p.gotoSlide = function (index, fast) {
        this.updateLoop(index);
        this.index = index;

        var target_slide = this.slideList[index];

        this._checkCritMargins();

        this.controller.changeTo(target_slide.position, !fast, null, null, false);
        if (target_slide === this.currentSlide) return;
        this.slideChanged = true;
        this.currentSlide = target_slide;

        if (this.autoUpdateZIndex) {
            this.__updateSlidesZindex();
        }

        this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_START));
        if (fast) this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_END));
    };

    p.next = function (checkLoop) {
        if (checkLoop && !this.loop && this.index + 1 >= this.slidesCount) {
            this.controller.bounce(10);
            return;
        }

        this.gotoSlide((this.index + 1 >= this.slidesCount) ? 0 : this.index + 1);
    };

    p.previous = function (checkLoop) {
        if (checkLoop && !this.loop && this.index - 1 < 0) {
            this.controller.bounce(-10);
            return;
        }

        this.gotoSlide((this.index - 1 < 0) ? this.slidesCount - 1 : this.index - 1);
    };

    /* --------------- Swipe control ------------------*/

    p.setupSwipe = function () {

        this.swipeControl = new averta.TouchSwipe(this.$element);
        this.swipeControl.swipeType = this.dir === 'h' ? 'horizontal' : 'vertical';
        var that = this;

        if (this.dir === 'h') {
            this.swipeControl.onSwipe = function (status) {
                that.horizSwipeMove(status);
            };
        } else {
            this.swipeControl.onSwipe = function (status) {
                that.vertSwipeMove(status);
            };
        }

    };

    p.vertSwipeMove = function (status) {
        var phase = status.phase;
        if (phase === 'start') {
            this.controller.stop();
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_START, status));
        } else if (phase === 'move' && (!this.loop || Math.abs(this.currentSlide.position - this.controller.value + status.moveY) < this.cont_size / 2)) {
            this.controller.drag(status.moveY);
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_MOVE, status));
        } else if (phase === 'end' || phase === 'cancel') {

            var speed = status.distanceY / status.duration * 50 / 3,
                speedh = Math.abs(status.distanceY / status.duration * 50 / 3);

            if (Math.abs(speed) > 0.1 && Math.abs(speed) >= speedh) {
                this.controller.push(-speed);
                if (speed > this.controller.options.snappingMinSpeed)
                    this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_END, status));
            } else {
                this.controller.cancel();
                this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_CANCEL, status));
            }

        }
    };

    p.horizSwipeMove = function (status) {
        var phase = status.phase;

        if (phase === 'start') {
            this.controller.stop();
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_START, status));
        } else if (phase === 'move' && (!this.loop || Math.abs(this.currentSlide.position - this.controller.value + status.moveX) < this.cont_size / 2)) {
            this.controller.drag(status.moveX);
            this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_MOVE, status));
        } else if (phase === 'end' || phase === 'cancel') {

            var speed = status.distanceX / status.duration * 50 / 3,
                speedv = Math.abs(status.distanceY / status.duration * 50 / 3);

            if (Math.abs(speed) > 0.1 && Math.abs(speed) >= speedv) {
                this.controller.push(-speed);
                if (speed > this.controller.options.snappingMinSpeed)
                    this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_END, status));
            } else {
                this.controller.cancel();
                this.dispatchEvent(new MSViewEvents(MSViewEvents.SWIPE_CANCEL, status));
            }

        }
    };

    /* ------------------------------------------------*/

    p.setSize = function (width, height, hard) {
        if (this.lastWidth === width && height === this.lastHeight && !hard) return;

        this.$element.width(width).height(height);

        for (var i = 0; i < this.slidesCount; ++i)
            this.slides[i].setSize(width, height, hard);

        this.__width = width;
        this.__height = height;

        if (this.__created) {
            this.__locateSlides();

            this.cont_size = (this.slidesCount - 1) * (this[this.__dimension] + this.spacing);
            if (!this.loop) this.controller._max_value = this.cont_size;

            this.controller.options.snapsize = this[this.__dimension] + this.spacing;
            this.controller.changeTo(this.currentSlide.position, false, null, null, false);
            this.controller.cancel();

            this.lastWidth = width;
            this.lastHeight = height;
        }
    };

    p.create = function (index) {

        this.__created = true;

        this.index = Math.min((index || 0), this.slidesCount - 1);
        this.lastSnap = this.index; // it will be used to check snap changed or not on snap complete

        if (this.loop)
            this.slides = this.__createLoopList();

        this.normalMode = this.slidesCount <= this.options.viewNum;

        for (var i = 0; i < this.slidesCount; ++i)
            this.slides[i].create();

        this.__locateSlides();

        this.controller.options.snapsize = this[this.__dimension] + this.spacing;
        if (!this.loop) this.controller._max_value = (this.slidesCount - 1) * (this[this.__dimension] + this.spacing);

        this.gotoSlide(this.index, true);

        if (this.options.swipe && (window._touch || this.options.mouseSwipe))
            this.setupSwipe();

    };

    p.destroy = function () {
        if (!this.__created) return;

        for (var i = 0; i < this.slidesCount; ++i)
            this.slides[i].destroy();

        this.slides = null;
        this.slideList = null;
        this.$element.remove();

        this.controller.destroy();
        this.controller = null;
    };

    averta.EventDispatcher.extend(p);

    MSSlideController.registerView('basic', MSBasicView);

})(jQuery);

/* ================== bin-debug/js/pro/views/WaveView.js =================== */
;
(function ($) {

    "use strict";

    window.MSWaveView = function (options) {
        MSBasicView.call(this, options);
        this.$element.removeClass('ms-basic-view').addClass('ms-wave-view');
        this.$slideCont.css(window._csspfx + 'transform-style', 'preserve-3d');

        // Auto update z index of slides
        // @since 1.7
        this.autoUpdateZIndex = true;
    };

    MSWaveView.extend(MSBasicView);
    MSWaveView._3dreq = true;
    MSWaveView._fallback = MSBasicView;

    var p = MSWaveView.prototype;
    var _super = MSBasicView.prototype;

    /*-------------- METHODS --------------*/

    /*p.__setSlideTransDuration = function(value){
    	for(var i=0; i<this.slidesCount; ++i)
    		this.slides[i].$element.css(window._csspfx + 'transition-duration' , value + 'ms');
    };*/

    p._horizUpdate = function (controller, value) {

        _super._horizUpdate.call(this, controller, value);

        var cont_scroll = -value;
        var slide_pos, slide, distance;

        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            //slide_pos = parseInt(slide.$element.css('left'));
            distance = -cont_scroll - slide.position;
            this.__updateSlidesHoriz(slide, distance);
        }

    };

    p._vertiUpdate = function (controller, value) {

        _super._vertiUpdate.call(this, controller, value);

        var cont_scroll = -value;
        var slide_pos, slide, distance;

        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            //slide_pos = parseInt(slide.$element.css('left'));
            distance = -cont_scroll - slide.position;
            this.__updateSlidesVertic(slide, distance);
        }

    };


    p.__updateSlidesHoriz = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        //var value2 = Math.min(value , 100);
        //	var sp = Math.min(100 , )
        //slide.$bg_img.css('opacity' , (100 -  Math.abs(distance * 120 / this.__width / 3)) / 100);
        slide.$element[0].style[window._csspfx + 'transform'] = 'translateZ(' + -value * 3 + 'px) rotateY(0.01deg)' /* translateX('+(distance < 0 ? 1 : -1) * -value * 5+'px)'*/ ;
    };

    p.__updateSlidesVertic = function (slide, distance) {
        this.__updateSlidesHoriz(slide, distance);
    };

    /*
    p.swipeMove = function(status){

    	if(status.phase == 'start'){
    		this.__setSlideTransDuration(0);
    	}else if(status.phase == 'end'){
    		this.__setSlideTransDuration(this.__slideDuration);
    	}

    	_super.swipeMove.call(this , status);
    };

    p.create = function(index){
    	_super.create.call(this , index);

    	for(var i = 0; i<this.slidesCount ; ++i){
    		this.slides[i].$element.css(window._csspfx + 'transition-property' , window._csspfx 		+ 'transform');
    		this.slides[i].$element.css(window._csspfx + 'transition-duration' , this.slideDuration + 'ms');
    	}
    };
    */
    MSSlideController.registerView('wave', MSWaveView);
})(jQuery);

/* ================== bin-debug/js/pro/views/FadeBasicView.js =================== */
/**
 * Master Slider Fade Basic view
 * @author averta
 * @version 1.1
 * @package MS
 */

;
(function () {

    window.MSFadeBasicView = function (options) {
        MSWaveView.call(this, options);
        this.$element.removeClass('ms-wave-view').addClass('ms-fade-basic-view');
    };

    MSFadeBasicView.extend(MSWaveView);

    var p = MSFadeBasicView.prototype;
    var _super = MSFadeBasicView.prototype;

    /*-------------- METHODS --------------*/

    p.__updateSlidesHoriz = function (slide, distance) {
        var value = Math.abs(distance * 0.6 / this.__width);
        value = 1 - Math.min(value, 0.6);
        slide.$element.css('opacity', value);
    };

    p.__updateSlidesVertic = function (slide, distance) {
        this.__updateSlidesHoriz(slide, distance);
    };

    MSSlideController.registerView('fadeBasic', MSFadeBasicView);
    MSWaveView._fallback = MSFadeBasicView;
})();

/* ================== bin-debug/js/pro/views/FadeWaveView.js =================== */
/**
 * Master Slider Fade Wave View
 * @author averta
 * @version 1.0
 * @extends {MSWaveView}
 */
;
(function () {

    window.MSFadeWaveView = function (options) {
        MSWaveView.call(this, options);
        this.$element.removeClass('ms-wave-view').addClass('ms-fade-wave-view');
    };

    MSFadeWaveView.extend(MSWaveView);
    MSFadeWaveView._3dreq = true;
    MSFadeWaveView._fallback = MSFadeBasicView;

    var p = MSFadeWaveView.prototype;
    var _super = MSWaveView.prototype;

    /*-------------- METHODS --------------*/

    p.__updateSlidesHoriz = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        value = Math.min(value, 100);
        slide.$element.css('opacity', 1 - value / 300);
        slide.$element[0].style[window._jcsspfx + 'Transform'] = 'scale(' + (1 - value / 800) + ') rotateY(0.01deg) ';
    };

    p.__updateSlidesVertic = function (slide, distance) {
        this.__updateSlidesHoriz(slide, distance);
    };

    MSSlideController.registerView('fadeWave', MSFadeWaveView);

})();

/* ================== bin-debug/js/pro/views/FlowView.js =================== */
;
(function ($) {

    "use strict";

    window.MSFlowView = function (options) {
        MSWaveView.call(this, options);
        this.$element.removeClass('ms-wave-view').addClass('ms-flow-view');
        //this.$slideCont.css(window._csspfx + 'transform-style' , 'preserve-3d');
    };

    MSFlowView.extend(MSWaveView);
    MSFlowView._3dreq = true;
    MSFlowView._fallback = MSFadeBasicView;

    var p = MSFlowView.prototype;
    var _super = MSWaveView.prototype;

    /*-------------- METHODS --------------*/


    p.__updateSlidesHoriz = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        var rvalue = Math.min(value * 0.3, 30) * (distance < 0 ? -1 : 1);
        var zvalue = value * 1.2;

        // Edit cybob: Anpassung Abstand nächstes Bild
        // slide.$element[0].style[window._jcsspfx + 'Transform'] = 'translateZ('+ -zvalue*5 +'px) rotateY(' + rvalue + 'deg) ';
        slide.$element[0].style[window._jcsspfx + 'Transform'] = 'translateZ(' + -zvalue * 11 + 'px) rotateY(' + rvalue + 'deg) ';
    };

    p.__updateSlidesVertic = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        var rvalue = Math.min(value * 0.3, 30) * (distance < 0 ? -1 : 1);
        var zvalue = value * 1.2;

        // Edit cybob: Anpassung Abstand nächstes Bild
        // slide.$element[0].style[window._jcsspfx + 'Transform'] = 'translateZ('+ -zvalue*5 +'px) rotateX(' + -rvalue + 'deg) ';
        slide.$element[0].style[window._jcsspfx + 'Transform'] = 'translateZ(' + -zvalue * 11 + 'px) rotateX(' + -rvalue + 'deg) ';
    };


    MSSlideController.registerView('flow', MSFlowView);
})(jQuery);

/* ================== bin-debug/js/pro/views/FadeFlowView.js =================== */
/**
 * Master Slider Fade Flow View
 * @author averta
 * @extends {MSWaveView}
 * @version 1.0
 */
;
(function () {

    window.MSFadeFlowView = function (options) {
        MSWaveView.call(this, options);
        this.$element.removeClass('ms-wave-view').addClass('ms-fade-flow-view');
    };

    MSFadeFlowView.extend(MSWaveView);
    MSFadeFlowView._3dreq = true;

    var p = MSFadeFlowView.prototype;
    var _super = MSWaveView.prototype;

    /*-------------- METHODS --------------*/

    p.__calculate = function (distance) {
        var value = Math.min(Math.abs(distance * 100 / this.__width), 100);
        var rvalue = Math.min(value * 0.5, 50) * (distance < 0 ? -1 : 1);
        return {
            value: value,
            rvalue: rvalue
        };
    };

    p.__updateSlidesHoriz = function (slide, distance) {
        var clc = this.__calculate(distance);
        slide.$element.css('opacity', 1 - clc.value / 300);
        console.log(window._jcsspfx + 'transform', 'translateZ(' + -clc.value + 'px) rotateY(' + clc.rvalue + 'deg) ')
        slide.$element[0].style[window._jcsspfx + 'Transform'] = 'translateZ(' + -clc.value + 'px) rotateY(' + clc.rvalue + 'deg) ';
    };

    p.__updateSlidesVertic = function (slide, distance) {
        var clc = this.__calculate(distance);
        slide.$element.css('opacity', 1 - clc.value / 300);
        slide.$element[0].style[window._jcsspfx + 'Transform'] = 'translateZ(' + -clc.value + 'px) rotateX(' + -clc.rvalue + 'deg) ';
    };

    MSSlideController.registerView('fadeFlow', MSFadeFlowView);

})();

/* ================== bin-debug/js/pro/views/MaskView.js =================== */
;
(function ($) {

    "use strict";

    window.MSMaskView = function (options) {
        MSBasicView.call(this, options);
        this.$element.removeClass('ms-basic-view').addClass('ms-mask-view');

    };

    MSMaskView.extend(MSBasicView);

    var p = MSMaskView.prototype;
    var _super = MSBasicView.prototype;

    /*-------------- METHODS --------------*/

    p.addSlide = function (slide) { // OK
        slide.view = this;

        slide.$frame = $('<div></div>').addClass('ms-mask-frame').append(slide.$element);
        slide.$element[0].style.position = 'relative';
        //this.$slideCont.append(slide.$frame);
        slide.autoAppend = false;

        this.slides.push(slide);
        this.slideList.push(slide);

        this.slidesCount++;
    };

    p.setSize = function (width, height) {
        var slider = this.slides[0].slider;

        for (var i = 0; i < this.slidesCount; ++i) {
            this.slides[i].$frame[0].style.width = width + 'px';
            if (!slider.options.autoHeight)
                this.slides[i].$frame[0].style.height = height + 'px';
        }

        _super.setSize.call(this, width, height);
    };

    // p.__snapUpdate = function(controller , snap , change){

    // 	if(this.loop){
    // 		var target_index = this.index + change;
    // 		this.updateLoop(target_index);

    // 		if(target_index >= this.slidesCount)	target_index = target_index - this.slidesCount;
    // 		if(target_index <  0)					target_index = this.slidesCount + target_index;

    // 		this.index = target_index;
    // 	}else{
    // 		if(snap < 0 ||  snap >= this.slidesCount) return
    // 		this.index = snap;
    // 	}


    // 	this._checkCritMargins();

    // 	if($.browser.mozilla){

    // 		this.slideList[this.index].$frame[0].style.marginTop 	= '0.1px';
    // 		this.slideList[this.index].$element[0].style.marginTop 	= '0.1px';

    // 		if(this.currentSlide){
    // 			this.currentSlide.$frame[0].style.marginTop 	= '';
    // 			this.currentSlide.$element[0].style.marginTop 	= '';
    // 		}
    // 	}

    // 		var new_slide = this.slideList[this.index];
    // 	if(new_slide === this.currentSlide)return;

    // 	this.currentSlide = new_slide;
    // 	this.dispatchEvent(new MSViewEvents(MSViewEvents.CHANGE_START));		
    // };

    p._horizUpdate = function (controller, value) {

        _super._horizUpdate.call(this, controller, value);

        var i = 0;

        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + 'Transform'] = 'translateX(' + (value - this.slideList[i].position) + 'px)' + this.__translate_end;
            }
            return;
        }

        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.left = (value - this.slideList[i].position) + 'px';
        }

    };

    p._vertiUpdate = function (controller, value) {

        _super._vertiUpdate.call(this, controller, value);

        var i = 0;

        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + 'Transform'] = 'translateY(' + (value - this.slideList[i].position) + 'px)' + this.__translate_end;
            }
            return;
        }

        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.top = (value - this.slideList[i].position) + 'px';
        }

    };

    p.__pushEnd = function () { // OK
        var first_slide = this.slides.shift();
        var last_slide = this.slides[this.slidesCount - 2];

        this.slides.push(first_slide);
        if (!this.normalMode) return;

        var pos = last_slide.$frame[0][this.__offset] + this.spacing + this[this.__dimension];
        first_slide.$frame[0].style[this.__cssProb] = pos + 'px';
        first_slide.position = pos;
    };

    p.__pushStart = function () { // OK

        var last_slide = this.slides.pop();
        var first_slide = this.slides[0];

        this.slides.unshift(last_slide);

        if (!this.normalMode) return;

        var pos = first_slide.$frame[0][this.__offset] - this.spacing - this[this.__dimension];
        last_slide.$frame[0].style[this.__cssProb] = pos + 'px';
        last_slide.position = pos;
    };

    p.__updateViewList = function () {

        if (this.normalMode) {
            this.viewSlidesList = this.slides;
            return;
        }

        var temp = this.viewSlidesList.slice();

        // update view list 
        this.viewSlidesList = [];
        var i = 0,
            hlf = Math.floor(this.options.viewNum / 2),
            l;

        if (this.loop) {
            for (; i !== this.options.viewNum; i++)
                this.viewSlidesList.push(this.slides[this.currentSlideLoc - hlf + i]);
        } else {
            // before
            for (i = 0; i !== hlf && this.index - i !== -1; i++)
                this.viewSlidesList.unshift(this.slideList[this.index - i]);
            // after
            for (i = 1; i !== hlf && this.index + i !== this.slidesCount; i++)
                this.viewSlidesList.push(this.slideList[this.index + i]);
        }

        for (i = 0, l = temp.length; i !== l; i++) {
            if (this.viewSlidesList.indexOf(temp[i]) === -1) {
                temp[i].sleep();
                temp[i].$frame.detach();
            }
        }

        temp = null;
    };


    p.__locateSlides = function (move, start) { // OK

        this.__updateViewList();

        start = !this.loop ? this.slides.indexOf(this.viewSlidesList[0]) * (this[this.__dimension] + this.spacing) : start || 0;

        // Old method
        // for(var i = 0; i < this.slidesCount ; ++i){
        // 	var pos =  i * (this[this.__dimension] + this.spacing);

        // 	this.slides[i].position = pos;
        // 	this.slides[i].$frame[0].style[this.__cssProb] =  pos + 'px';
        // }

        var l = this.viewSlidesList.length,
            slide;

        for (var i = 0; i !== l; i++) {
            var pos = start + i * (this[this.__dimension] + this.spacing);
            slide = this.viewSlidesList[i];

            this.$slideCont.append(slide.$frame);
            slide.wakeup(false);
            slide.position = pos;

            if (slide.selected && slide.bgvideo) {
                try {
                    slide.bgvideo.play();
                } catch (e) {}
            }

            slide.$frame[0].style[this.__cssProb] = pos + 'px';
        }

        if (move !== false) this.controller.changeTo(this.slideList[this.index].position, false, null, null, false);

    };

    MSSlideController.registerView('mask', MSMaskView);
})(jQuery);

/* ================== bin-debug/js/pro/views/ParallaxMaskView.js =================== */
;
(function ($) {

    "use strict";

    window.MSParallaxMaskView = function (options) {
        MSMaskView.call(this, options);
        this.$element.removeClass('ms-basic-view').addClass('ms-parallax-mask-view');

    };

    MSParallaxMaskView.extend(MSMaskView);
    MSParallaxMaskView.parallaxAmount = 0.5;

    var p = MSParallaxMaskView.prototype;
    var _super = MSBasicView.prototype;

    /*-------------- METHODS --------------*/

    p._horizUpdate = function (controller, value) {
        _super._horizUpdate.call(this, controller, value);

        var i = 0;

        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + 'Transform'] = 'translateX(' + (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + 'px)' + this.__translate_end;
            }
            return;
        }

        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.left = (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + 'px';
        }

    };

    p._vertiUpdate = function (controller, value) {

        _super._vertiUpdate.call(this, controller, value);

        var i = 0;

        if (this.css3) {
            for (i = 0; i < this.slidesCount; ++i) {
                this.slideList[i].$element[0].style[window._jcsspfx + 'Transform'] = 'translateY(' + (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + 'px)' + this.__translate_end;
            }
            return;
        }

        for (i = 0; i < this.slidesCount; ++i) {
            this.slideList[i].$element[0].style.top = (value - this.slideList[i].position) * MSParallaxMaskView.parallaxAmount + 'px';
        }

    };


    MSSlideController.registerView('parallaxMask', MSParallaxMaskView);
})(jQuery);

/* ================== bin-debug/js/pro/views/FadeView.js =================== */
;
(function ($) {

    "use strict";

    window.MSFadeView = function (options) {
        MSBasicView.call(this, options);
        this.$element.removeClass('ms-basic-view').addClass('ms-fade-view');
        this.controller.renderCallback(this.__update, this);
    };

    MSFadeView.extend(MSBasicView);

    var p = MSFadeView.prototype;
    var _super = MSBasicView.prototype;

    /*-------------- METHODS --------------*/

    p.__update = function (controller, value) {
        var cont_scroll = -value;
        var slide_pos, slide, distance;

        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            distance = -cont_scroll - slide.position;
            this.__updateSlides(slide, distance);
        }
    };

    p.__updateSlides = function (slide, distance) {
        var value = Math.abs(distance / this[this.__dimension]);
        if (1 - value <= 0) {
            slide.$element.fadeTo(0, 0).css('visibility', 'hidden');
        } else {
            slide.$element.fadeTo(0, 1 - value).css('visibility', '');
        }
    };

    p.__locateSlides = function (move, start) {

        this.__updateViewList();

        // Old method
        // for(var i = 0; i < this.slidesCount ; ++i){
        // 	this.slides[i].position = i * this[this.__dimension];
        // }

        start = !this.loop ? this.slides.indexOf(this.viewSlidesList[0]) * (this[this.__dimension] + this.spacing) : start || 0;

        var l = this.viewSlidesList.length,
            slide;

        for (var i = 0; i !== l; i++) {
            var pos = start + i * this[this.__dimension];
            slide = this.viewSlidesList[i];
            slide.wakeup();
            slide.position = pos;
        }

        if (move !== false) this.controller.changeTo(this.slideList[this.index].position, false, null, null, false);

    };

    p.__pushEnd = function () {
        var first_slide = this.slides.shift();
        var last_slide = this.slides[this.slidesCount - 2];
        this.slides.push(first_slide);
        first_slide.position = last_slide.position + this[this.__dimension];
    };

    p.__pushStart = function () {
        var last_slide = this.slides.pop();
        var first_slide = this.slides[0];
        this.slides.unshift(last_slide);
        last_slide.position = first_slide.position - this[this.__dimension];
    };

    p.create = function (index) {
        _super.create.call(this, index);
        this.spacing = 0;
        this.controller.options.minValidDist = 10;
    };

    MSSlideController.registerView('fade', MSFadeView);
})(jQuery);

/* ================== bin-debug/js/pro/views/ScaleView.js =================== */
;
(function ($) {

    "use strict";

    window.MSScaleView = function (options) {
        MSBasicView.call(this, options);
        this.$element.removeClass('ms-basic-view').addClass('ms-scale-view');
        this.controller.renderCallback(this.__update, this);
    };

    MSScaleView.extend(MSFadeView);

    var p = MSScaleView.prototype;
    var _super = MSFadeView.prototype;

    /*-------------- METHODS --------------*/

    p.__updateSlides = function (slide, distance) {
        var value = Math.abs(distance / this[this.__dimension]),
            element = slide.$element[0];

        if (1 - value <= 0) {
            element.style.opacity = 0;
            element.style.visibility = 'hidden';
            element.style[window._jcsspfx + 'Transform'] = '';
        } else {
            element.style.opacity = 1 - value;
            element.style.visibility = '';
            element.style[window._jcsspfx + 'Transform'] = 'perspective(2000px) translateZ(' + (value * (distance < 0 ? -0.5 : 0.5)) * 300 + 'px)';
        }

    };

    p.create = function (index) {
        _super.create.call(this, index);
        this.controller.options.minValidDist = 0.03;
    };

    MSSlideController.registerView('scale', MSScaleView);
})(jQuery);

/* ================== bin-debug/js/pro/views/StackView.js =================== */
/**
 * Master Slider Stack View 
 * @package Master Slider jQuery
 * @author Averta
 */

;
(function ($) {

    "use strict";

    window.MSStackView = function (options) {
        MSBasicView.call(this, options);
        this.$element.removeClass('ms-basic-view').addClass('ms-stack-view');
        this.controller.renderCallback(this.__update, this);
        this.autoUpdateZIndex = true;
    };

    MSStackView.extend(MSFadeView);
    MSStackView._3dreq = true;
    MSStackView._fallback = MSFadeView;

    var p = MSStackView.prototype;
    var _super = MSFadeView.prototype;

    /*-------------- METHODS --------------*/

    /**
     * Updates slides z index
     */
    p.__updateSlidesZindex = function () {
        var slide,
            l = this.viewSlidesList.length;

        for (var i = 0; i !== l; i++) {
            slide = this.viewSlidesList[i];
            this.viewSlidesList[i].$element.css('z-index', l - i);
        }

    };


    p.__updateSlides = function (slide, distance) {
        var value = Math.abs(distance / this[this.__dimension]),
            element = slide.$element[0];

        if (1 - value <= 0) {
            element.style.opacity = 1;
            element.style.visibility = 'hidden';
            element.style[window._jcsspfx + 'Transform'] = '';
        } else {
            element.style.visibility = '';

            if (distance < 0) {
                element.style[window._jcsspfx + 'Transform'] = 'perspective(2000px) translateZ(' + (value * -300) + 'px)';
            } else {
                element.style[window._jcsspfx + 'Transform'] = this.__translate + '(' + (-value * this[this.__dimension]) + 'px)';
            }

        }

    };


    p.create = function (index) {
        _super.create.call(this, index);
        this.controller.options.minValidDist = 0.03;
        this.__translate = this.dir === 'h' ? 'translateX' : 'translateY';
    };


    MSSlideController.registerView('stack', MSStackView);
})(jQuery);

/* ================== bin-debug/js/pro/views/FocusView.js =================== */
/**
 * Master Slider Focus View
 * @version 1.1
 * @author averta
 * @package MS
 * @extends {MSFadeBasicView}
 */

;
(function () {

    'use strict';

    var perspective = 2000;

    window.MSFocusView = function (options) {
        MSWaveView.call(this, options);
        this.$element.removeClass('ms-wave-view').addClass('ms-focus-view');
        this.options.centerSpace = this.options.centerSpace || 1;
    };

    MSFocusView.extend(MSWaveView);
    MSFocusView._3dreq = true;
    MSFocusView._fallback = MSFadeBasicView;

    var p = MSFocusView.prototype;
    var _super = MSWaveView.prototype;

    /*-------------- METHODS --------------*/

    p.__calcview = function (z, w) {
        var a = w / 2 * z / (z + perspective);
        return a * (z + perspective) / perspective;
    };

    p.__updateSlidesHoriz = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        value = -Math.min(value, 100) * 15;
        slide.$element.css(window._csspfx + 'transform', 'translateZ(' + (value + 1) + 'px) rotateY(0.01deg) translateX(' + (distance < 0 ? 1 : -1) * (-this.__calcview(value, this.__width) * this.options.centerSpace) + 'px)');
    };

    p.__updateSlidesVertic = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        value = -Math.min(value, 100) * 15;
        slide.$element.css(window._csspfx + 'transform', 'translateZ(' + (value + 1) + 'px) rotateY(0.01deg) translateY(' + (distance < 0 ? 1 : -1) * (-this.__calcview(value, this.__width) * this.options.centerSpace) + 'px)');
    };

    MSSlideController.registerView('focus', MSFocusView);

})();

/* ================== bin-debug/js/pro/views/PartialWaveView.js =================== */
/**
 * Master Slider Partial Wave View
 * @version 1.0
 * @author averta
 * @extends {MSWaveView}
 */

;
(function () {

    window.MSPartialWaveView = function (options) {
        MSWaveView.call(this, options);
        this.$element.removeClass('ms-wave-view').addClass('ms-partial-wave-view');
    };

    MSPartialWaveView.extend(MSWaveView);
    MSPartialWaveView._3dreq = true;
    MSPartialWaveView._fallback = MSFadeBasicView;

    var p = MSPartialWaveView.prototype;
    var _super = MSWaveView.prototype;

    /*-------------- METHODS --------------*/

    p.__updateSlidesHoriz = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        if (slide.hasBG) {
            slide.$bg_img.css('opacity', (100 - Math.abs(distance * 120 / this.__width / 3)) / 100);
        }
        slide.$element.css(window._csspfx + 'transform', 'translateZ(' + -value * 3 + 'px) rotateY(0.01deg) translateX(' + distance * 0.75 + 'px)');
    };

    p.__updateSlidesVertic = function (slide, distance) {
        var value = Math.abs(distance * 100 / this.__width);
        if (slide.hasBG) {
            slide.$bg_img.css('opacity', (100 - Math.abs(distance * 120 / this.__width / 3)) / 100);
        }
        slide.$element.css(window._csspfx + 'transform', 'translateZ(' + -value * 3 + 'px) rotateY(0.01deg) translateY(' + distance * 0.75 + 'px)');
    };

    MSSlideController.registerView('partialWave', MSPartialWaveView);

})();

/* ================== bin-debug/js/pro/views/BoxView.js =================== */
;
(function ($) {

    "use strict";

    window.MSBoxView = function (options) {
        MSBasicView.call(this, options);
        this.$element.removeClass('ms-basic-view').addClass('ms-box-view');
        this.controller.renderCallback(this.__update, this);
    };

    MSBoxView.extend(MSFadeView);
    MSBoxView._3dreq = true;

    var p = MSBoxView.prototype;
    var _super = MSFadeView.prototype;

    /*-------------- METHODS --------------*/

    p.__updateSlides = function (slide, distance) {
        var value = Math.abs(distance / this[this.__dimension]),
            element = slide.$element[0];

        if (1 - value <= 0) {
            //element.style.opacity = 0.5;
            element.style.visibility = 'hidden';
            element.style[window._jcsspfx + 'Transform'] = '';
        } else {
            //element.style.opacity = 0.5 + (1 - value) * 0.5;
            element.style.visibility = '';
            element.style[window._jcsspfx + 'Transform'] = 'rotate' + this._rotateDir + '(' + (value * (distance < 0 ? 1 : -1)) * 90 * this._calcFactor + 'deg)';
            element.style[window._jcsspfx + 'TransformOrigin'] = '50% 50% -' + (slide[this.__dimension] / 2) + 'px';
            element.style.zIndex = Math.ceil((1 - value) * 2);
        }
    };

    p.create = function (index) {
        _super.create.call(this, index);
        this.controller.options.minValidDist = 0.03;
        this._rotateDir = this.options.dir === 'h' ? 'Y' : 'X';
        this._calcFactor = this.options.dir === 'h' ? 1 : -1;

    };

    MSSlideController.registerView('box', MSBoxView);
})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/BaseControl.js =================== */
;
(function ($) {

    "use strict";

    var BaseControl = function () {
        this.options = {
            prefix: 'ms-',
            autohide: true,
            overVideo: true,
            customClass: null
        };
    };

    var p = BaseControl.prototype;

    /* -------------------------------- */

    p.slideAction = function (slide) {

    };

    p.setup = function () {
        this.cont = this.options.insertTo ? $(this.options.insertTo) : this.slider.$controlsCont;
        if (!this.options.overVideo) this._hideOnvideoStarts();

    };

    p.checkHideUnder = function () {
        if (this.options.hideUnder) {
            //this.slider.api.addEventListener(MSSliderEvent.RESIZE, this.onSliderResize, this);
            this.needsRealign = !this.options.insetTo && (this.options.align === 'left' || this.options.align === 'right') && this.options.inset === false;
            $(window).bind('resize', {
                that: this
            }, this.onResize);
            this.onResize();

        }
    };

    /**
     * hide control if width of slider changes to lower that specified value [hideUnder]
     * @since 1.5.7
     * @protected
     */
    p.onResize = function (event) {
        var that = (event && event.data.that) || this;
        var w = window.innerWidth;
        if (w <= that.options.hideUnder && !that.detached) {
            that.hide(true);
            that.detached = true;
            that.onDetach();
        } else if (w >= that.options.hideUnder && that.detached) {
            that.detached = false;
            that.visible();
            that.onAppend();
        }
    };

    p.create = function () {
        var that = this;
        if (this.options.autohide) {

            this.hide(true);

            this.slider.$controlsCont.mouseenter($.proxy(this._onMouseEnter, this))
                .mouseleave($.proxy(this._onMouseLeave, this))
                .mousedown($.proxy(this._onMouseDown, this));

            if (this.$element) {
                this.$element.mouseenter($.proxy(this._onMouseEnter, this))
                    .mouseleave($.proxy(this._onMouseLeave, this))
                    .mousedown($.proxy(this._onMouseDown, this));
            }

            $(document).mouseup($.proxy(this._onMouseUp, this));
        }

        if (this.options.align) {
            this.$element.addClass('ms-align-' + this.options.align);
        }

        // add custom class to control 
        if (this.options.customClass && this.$element) {
            this.$element.addClass(this.options.customClass);
        }
    };

    /**
     * Mouse Enter Listener 
     * @since 2.2
     */
    p._onMouseEnter = function () {
        if (!this._disableAH && !this.mdown) {
            this.visible();
        }

        this.mleave = false;
    };

    /**
     * Mouse Leave Listener 
     * @since 2.2
     */
    p._onMouseLeave = function () {
        if (!this.mdown) {
            this.hide();
        }

        this.mleave = true;
    };

    /**
     * Mouse Down Listener 
     * @since 2.2
     */
    p._onMouseDown = function () {
        this.mdown = true;
    };

    /**
     * Mouse Up Listener 
     * @since 2.2
     */
    p._onMouseUp = function () {
        if (this.mdown && this.mleave) {
            this.hide();
        }

        this.mdown = false;
    };

    /**
     * calls by the parent class [MSBaseControl] when the control element visibles [hideUnder option]
     * @since 1.5.7
     */
    p.onAppend = function () {
        if (this.needsRealign) {
            this.slider._realignControls();
        }
    };

    /**
     * calls by the parent class [MSBaseControl] when the control element visibles [hideUnder option]
     * @since 1.5.7
     */
    p.onDetach = function () {
        if (this.needsRealign) {
            this.slider._realignControls();
        }
    };

    p._hideOnvideoStarts = function () {
        var that = this;
        this.slider.api.addEventListener(MSSliderEvent.VIDEO_PLAY, function () {
            that._disableAH = true;
            that.hide();
        });

        this.slider.api.addEventListener(MSSliderEvent.VIDEO_CLOSE, function () {
            that._disableAH = false;
            that.visible();
        });
    };

    p.hide = function (fast) {
        if (fast) {
            this.$element.css('opacity', 0);
            this.$element.css('display', 'none');
        } else {
            clearTimeout(this.hideTo);
            var $element = this.$element;
            this.hideTo = setTimeout(function () {
                CTween.fadeOut($element, 400, false);
            }, 20);
        }

        this.$element.addClass('ms-ctrl-hide');
    };

    p.visible = function () {
        if (this.detached) return;
        clearTimeout(this.hideTo);
        this.$element.css('display', '');
        CTween.fadeIn(this.$element, 400, false);
        this.$element.removeClass('ms-ctrl-hide');
    };

    p.destroy = function () {

        if (this.options && this.options.hideUnder) {
            //this.slider.api.removeEventListener(MSSliderEvent.RESIZE, this.onResize, this);
            $(window).unbind('resize', this.onResize);
        }
    };

    window.BaseControl = BaseControl;

})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/Arrows.js =================== */
;
(function ($) {

    "use strict";

    var MSArrows = function (options) {
        BaseControl.call(this);
        $.extend(this.options, options);
    };

    MSArrows.extend(BaseControl);

    var p = MSArrows.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */

    p.setup = function () {
        var that = this;

        this.$next = $('<div></div>')
            .addClass(this.options.prefix + 'nav-next')
            //.appendTo(this.cont)
            .bind('click', function () {
                that.slider.api.next(true);
            });


        this.$prev = $('<div></div>')
            .addClass(this.options.prefix + 'nav-prev')
            //.appendTo(this.cont)
            .bind('click', function () {
                that.slider.api.previous(true);
            });

        _super.setup.call(this);

        this.cont.append(this.$next);
        this.cont.append(this.$prev);

        this.checkHideUnder(); // super method
    };

    p.hide = function (fast) {
        if (fast) {
            this.$prev.css('opacity', 0).css('display', 'none');
            this.$next.css('opacity', 0).css('display', 'none');
            return;
        }

        CTween.fadeOut(this.$prev, 400, false);
        CTween.fadeOut(this.$next, 400, false);

        this.$prev.addClass('ms-ctrl-hide');
        this.$next.addClass('ms-ctrl-hide');
    };

    p.visible = function () {
        if (this.detached) return;
        CTween.fadeIn(this.$prev, 400);
        CTween.fadeIn(this.$next, 400);
        this.$prev.removeClass('ms-ctrl-hide').css('display', '');
        this.$next.removeClass('ms-ctrl-hide').css('display', '');
    };

    p.destroy = function () {
        _super.destroy();
        this.$next.remove();
        this.$prev.remove();
    };

    window.MSArrows = MSArrows;
    MSSlideController.registerControl('arrows', MSArrows);
})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/Thumblist.js =================== */
;
(function ($) {

    "use strict";

    var MSThumblist = function (options) {
        BaseControl.call(this);

        // default options
        this.options.dir = 'h';
        this.options.wheel = options.dir === 'v';
        this.options.arrows = false;
        this.options.speed = 17;
        this.options.align = null;
        this.options.inset = false;
        this.options.margin = 10;
        this.options.space = 10;
        this.options.width = 100;
        this.options.height = 100;
        this.options.type = 'thumbs'; // tabs
        this.options.hover = false;


        $.extend(this.options, options);

        this.thumbs = [];
        this.index_count = 0;

        this.__dimen = this.options.dir === 'h' ? 'width' : 'height';
        this.__alignsize = this.options.dir === 'h' ? 'height' : 'width';
        this.__jdimen = this.options.dir === 'h' ? 'outerWidth' : 'outerHeight';
        this.__pos = this.options.dir === 'h' ? 'left' : 'top';

        this.click_enable = true;

    };

    MSThumblist.extend(BaseControl);

    var p = MSThumblist.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */

    p.setup = function () {
        this.$element = $('<div></div>')
            .addClass(this.options.prefix + 'thumb-list');

        if (this.options.type === 'tabs') {
            this.$element.addClass(this.options.prefix + 'tabs');
        }

        this.$element.addClass('ms-dir-' + this.options.dir);

        _super.setup.call(this);


        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element);
        } else {
            this.$element.appendTo(this.cont);
        }

        this.$thumbscont = $('<div></div>')
            .addClass('ms-thumbs-cont')
            .appendTo(this.$element);

        if (this.options.arrows) {
            var that = this;
            this.$fwd = $('<div></div>').addClass('ms-thumblist-fwd').appendTo(this.$element).click(function () {
                that.controller.push(-15);
            });
            this.$bwd = $('<div></div>').addClass('ms-thumblist-bwd').appendTo(this.$element).click(function () {
                that.controller.push(15);
            });
        }

        // align control
        if (!this.options.insetTo && this.options.align) {
            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === 'top') {
                this.$element.detach().prependTo(this.slider.$element).css({
                    'margin-bottom': this.options.margin,
                    'position': 'relative'
                });
            } else if (align === 'bottom') {
                this.$element.css({
                    'margin-top': this.options.margin,
                    'position': 'relative'
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }

            if (this.options.dir === 'v') {
                this.$element.width(this.options.width);
            } else {
                this.$element.height(this.options.height);
            }
        }

        this.checkHideUnder(); // super method

    };

    /**
     * calls by "RESERVED_SPACE_CHANGE" realigns the control in slider
     * @since 1.5.7
     */
    p.align = function (event) {
        if (this.detached) {
            return;
        }
        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options[this.__alignsize] + this.options.margin * 2);
        this.$element.css(align, -pos - this.options[this.__alignsize] - this.options.margin);
    };

    p.slideAction = function (slide) {
        var thumb_ele = slide.$element.find('.ms-thumb');
        var that = this;
        var thumb_frame = $('<div></div>')
            .addClass('ms-thumb-frame')
            .append(thumb_ele)
            .append($('<div class="ms-thumb-ol"></div>'))
            .bind(this.options.hover ? 'hover' : 'click', function () {
                that.changeSlide(thumb_frame);
            });

        if (this.options.align) {
            thumb_frame.width(this.options.width - (this.options.dir === 'v' && this.options.type === 'tabs' ? 12 : 0)) // less arrow size 12px
                .height(this.options.height)
                .css('margin-' + (this.options.dir === 'v' ? 'bottom' : 'right'), this.options.space);
        }

        thumb_frame[0].index = this.index_count++;

        this.$thumbscont.append(thumb_frame);

        // Added Fillmode support to thumblist
        // @since 1.6.0
        if (this.options.fillMode && thumb_ele.is('img')) {
            var aligner = new window.MSAligner(this.options.fillMode, thumb_frame, thumb_ele);
            thumb_ele[0].aligner = aligner;
            thumb_ele.one('load', function (e) {
                var $this = $(this);
                $this[0].aligner.init($this.width(), $this.height());
                $this[0].aligner.align();
            }).each($.jqLoadFix);
        }

        if ($.browser.msie)
            thumb_ele.on('dragstart', function (event) {
                event.preventDefault();
            }); // disable native dragging

        this.thumbs.push(thumb_frame);
    };

    p.create = function () {
        _super.create.call(this);

        this.__translate_end = window._css3d ? ' translateZ(0px)' : '';
        this.controller = new Controller(0, 0, {
            //snapping	     : true,
            snappingMinSpeed: 2,
            friction: (100 - this.options.speed * 0.5) / 100
        });

        this.controller.renderCallback(this.options.dir === 'h' ? this._hMove : this._vMove, this);
        //this.controller.snappingCallback(this.__snapUpdate , this);
        //this.controller.snapCompleteCallback(this.__snapCompelet , this);

        var that = this;
        this.resize_listener = function () {
            that.__resize();
        };
        $(window).bind('resize', this.resize_listener);

        this.thumbSize = this.thumbs[0][this.__jdimen](true);

        this.setupSwipe();
        this.__resize();

        var that = this;
        if (this.options.wheel) {

            this.wheellistener = function (event) {
                var e = window.event || event.orginalEvent || event;
                var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
                that.controller.push(-delta * 10);
                return false;
            };

            if ($.browser.mozilla) this.$element[0].addEventListener('DOMMouseScroll', this.wheellistener);
            else this.$element.bind('mousewheel', this.wheellistener);
        }

        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.slider.api.addEventListener(MSSliderEvent.HARD_UPDATE, this.realignThumbs, this);
        this.cindex = this.slider.api.index();
        this.select(this.thumbs[this.cindex]);


    };

    p._hMove = function (controller, value) {
        this.__contPos = value;
        if (window._cssanim) {
            this.$thumbscont[0].style[window._jcsspfx + 'Transform'] = 'translateX(' + -value + 'px)' + this.__translate_end;
            return;
        }
        this.$thumbscont[0].style.left = -value + 'px';
    };

    p._vMove = function (controller, value) {
        this.__contPos = value;
        if (window._cssanim) {
            this.$thumbscont[0].style[window._jcsspfx + 'Transform'] = 'translateY(' + -value + 'px)' + this.__translate_end;
            return;
        }
        this.$thumbscont[0].style.top = -value + 'px';
    };

    p.setupSwipe = function () {
        this.swipeControl = new averta.TouchSwipe(this.$element);
        this.swipeControl.swipeType = this.options.dir === 'h' ? 'horizontal' : 'vertical';

        var that = this;
        if (this.options.dir === 'h')
            this.swipeControl.onSwipe = function (status) {
                that.horizSwipeMove(status);
            };
        else
            this.swipeControl.onSwipe = function (status) {
                that.vertSwipeMove(status);
            };
    };

    p.vertSwipeMove = function (status) {
        if (this.dTouch) return;
        var phase = status.phase;
        if (phase === 'start')
            this.controller.stop();
        else if (phase === 'move')
            this.controller.drag(status.moveY);
        else if (phase === 'end' || phase === 'cancel') {
            var speed = Math.abs(status.distanceY / status.duration * 50 / 3);
            if (speed > 0.1) {
                this.controller.push(-status.distanceY / status.duration * 50 / 3);
            } else {
                this.click_enable = true;
                this.controller.cancel();
            }
        }
    };

    p.horizSwipeMove = function (status) {
        if (this.dTouch) return;
        var phase = status.phase;
        if (phase === 'start') {
            this.controller.stop();
            this.click_enable = false;
        } else if (phase === 'move')
            this.controller.drag(status.moveX);
        else if (phase === 'end' || phase === 'cancel') {
            var speed = Math.abs(status.distanceX / status.duration * 50 / 3);
            if (speed > 0.1) {
                this.controller.push(-status.distanceX / status.duration * 50 / 3);
            } else {
                this.click_enable = true;
                this.controller.cancel();
            }
        }
    };

    p.update = function () {
        var nindex = this.slider.api.index();
        if (this.cindex === nindex) return;

        if (this.cindex != null) this.unselect(this.thumbs[this.cindex]);
        this.cindex = nindex;
        this.select(this.thumbs[this.cindex]);

        if (!this.dTouch) this.updateThumbscroll();
    };

    p.realignThumbs = function () {
        this.$element.find('.ms-thumb').each(function (index, thumb) {
            if (thumb.aligner) {
                thumb.aligner.align();
            }
        });
    };

    p.updateThumbscroll = function () {
        var thumb_size;

        var pos = this.thumbSize * this.cindex;

        if (this.controller.value == NaN) this.controller.value = 0;

        if (pos - this.controller.value < 0) {
            this.controller.gotoSnap(this.cindex, true);
            return;
        }

        if (pos + this.thumbSize - this.controller.value > this.$element[this.__dimen]()) {
            var first_snap = this.cindex - Math.floor(this.$element[this.__dimen]() / this.thumbSize) + 1;
            this.controller.gotoSnap(first_snap, true);
            return;
        }
    };

    p.changeSlide = function (thumb) {
        if (!this.click_enable || this.cindex === thumb[0].index) return;
        this.slider.api.gotoSlide(thumb[0].index);
    };

    p.unselect = function (ele) {
        ele.removeClass('ms-thumb-frame-selected');
    };

    p.select = function (ele) {
        ele.addClass('ms-thumb-frame-selected');
    };

    p.__resize = function () {
        var size = this.$element[this.__dimen]();

        if (this.ls === size) return;

        this.ls = size;

        this.thumbSize = this.thumbs[0][this.__jdimen](true);
        var len = this.slider.api.count() * this.thumbSize;
        this.$thumbscont[0].style[this.__dimen] = len + 'px';

        if (len <= size) {
            this.dTouch = true;
            this.controller.stop();
            this.$thumbscont[0].style[this.__pos] = (size - len) * .5 + 'px';
            this.$thumbscont[0].style[window._jcsspfx + 'Transform'] = '';
        } else {
            this.dTouch = false;
            this.click_enable = true;
            this.$thumbscont[0].style[this.__pos] = '';
            this.controller._max_value = len - size;
            this.controller.options.snapsize = this.thumbSize;
            this.updateThumbscroll();
        }

    };

    p.destroy = function () {
        _super.destroy();

        if (this.options.wheel) {
            if ($.browser.mozilla) this.$element[0].removeEventListener('DOMMouseScroll', this.wheellistener);
            else this.$element.unbind('mousewheel', this.wheellistener);
            this.wheellistener = null;
        }

        $(window).unbind('resize', this.resize_listener);

        this.$element.remove();

        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
        this.slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.update, this);
    };

    window.MSThumblist = MSThumblist;
    MSSlideController.registerControl('thumblist', MSThumblist);

})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/Bullets.js =================== */
;
(function ($) {

    "use strict";

    var MSBulltes = function (options) {
        BaseControl.call(this);

        this.options.dir = 'h';
        this.options.inset = true;
        this.options.margin = 10;
        this.options.space = 10;


        $.extend(this.options, options);

        this.bullets = [];

    };

    MSBulltes.extend(BaseControl);

    var p = MSBulltes.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */

    p.setup = function () {
        _super.setup.call(this);

        this.$element = $('<div></div>')
            .addClass(this.options.prefix + 'bullets')
            .addClass('ms-dir-' + this.options.dir)
            .appendTo(this.cont);

        this.$bullet_cont = $('<div></div>')
            .addClass('ms-bullets-count')
            .appendTo(this.$element);

        if (!this.options.insetTo && this.options.align) {

            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            }

        }

        this.checkHideUnder(); // super method
    };

    p.create = function () {
        _super.create.call(this);
        var that = this;

        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.cindex = this.slider.api.index();
        for (var i = 0; i < this.slider.api.count(); ++i) {
            var bullet = $('<div></div>').addClass('ms-bullet');
            bullet[0].index = i;
            bullet.on('click', function () {
                that.changeSlide(this.index);
            });
            this.$bullet_cont.append(bullet);
            this.bullets.push(bullet);
            if (this.options.dir === 'h') {
                bullet.css('margin', this.options.space / 2);
            } else {
                bullet.css('margin', this.options.space);
            }
        }

        if (this.options.dir === 'h') {
            this.$element.width(bullet.outerWidth(true) * this.slider.api.count());
        } else {
            this.$element.css('margin-top', -this.$element.outerHeight(true) / 2);
        }

        this.select(this.bullets[this.cindex]);
    };

    p.update = function () {
        var nindex = this.slider.api.index();
        if (this.cindex === nindex) return;

        if (this.cindex != null) this.unselect(this.bullets[this.cindex]);
        this.cindex = nindex;
        this.select(this.bullets[this.cindex]);
    };

    p.changeSlide = function (index) {
        if (this.cindex === index) return;
        this.slider.api.gotoSlide(index);
    };

    p.unselect = function (ele) {
        ele.removeClass('ms-bullet-selected');
    };

    p.select = function (ele) {
        ele.addClass('ms-bullet-selected');
    };

    p.destroy = function () {
        _super.destroy();
        this.slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.$element.remove();
    };

    window.MSBulltes = MSBulltes;

    MSSlideController.registerControl('bullets', MSBulltes);

})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/Scrollbar.js =================== */
;
(function ($) {

    "use strict";

    var MSScrollbar = function (options) {
        BaseControl.call(this);

        this.options.dir = 'h';
        this.options.autohide = true;
        this.options.width = 4;
        this.options.color = '#3D3D3D';
        this.options.margin = 10;

        $.extend(this.options, options);
        this.__dimen = this.options.dir === 'h' ? 'width' : 'height';
        this.__jdimen = this.options.dir === 'h' ? 'outerWidth' : 'outerHeight';
        this.__pos = this.options.dir === 'h' ? 'left' : 'top';
        this.__translate_end = window._css3d ? ' translateZ(0px)' : '';
        this.__translate_start = this.options.dir === 'h' ? ' translateX(' : 'translateY(';
    };

    MSScrollbar.extend(BaseControl);

    var p = MSScrollbar.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */

    p.setup = function () {

        this.$element = $('<div></div>')
            .addClass(this.options.prefix + 'sbar')
            .addClass('ms-dir-' + this.options.dir);

        _super.setup.call(this);

        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element);
        } else {
            this.$element.appendTo(this.cont);
        }

        this.$bar = $('<div></div>')
            .addClass(this.options.prefix + 'bar')
            .appendTo(this.$element);

        if (this.slider.options.loop) {
            console.log('WARNING, MSScrollbar cannot work with looped slider.');
            this.disable = true;
            this.$element.remove();
        }

        /**
         * align control
         * @since 1.5.7
         */
        // change width 
        if (this.options.dir === 'v') {
            this.$bar.width(this.options.width);
        } else {
            this.$bar.height(this.options.width);
        }

        // change color
        this.$bar.css('background-color', this.options.color);

        if (!this.options.insetTo && this.options.align) {

            // reset old versions styles
            if (this.options.dir === 'v') {
                this.$element.css({
                    right: 'auto',
                    left: 'auto'
                });
            } else {
                this.$element.css({
                    top: 'auto',
                    bottom: 'auto'
                });
            }

            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === 'top') {
                this.$element.prependTo(this.slider.$element).css({
                    'margin-bottom': this.options.margin,
                    'position': 'relative'
                });
            } else if (align === 'bottom') {
                this.$element.css({
                    'margin-top': this.options.margin,
                    'position': 'relative'
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }
        }

        this.checkHideUnder(); // super method
    };

    /**
     * calls by "RESERVED_SPACE_CHGANE" realigns the control in slider
     * @since 1.5.7
     */
    p.align = function (event) {
        if (this.detached) {
            return;
        }

        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options.margin * 2 + this.options.width);
        this.$element.css(align, -pos - this.options.margin - this.options.width);
    };

    p.create = function () {

        if (this.disable) return;

        //_super.create.call(this);
        var that = this;

        this.scroller = this.slider.api.scroller;

        this.slider.api.view.addEventListener(MSViewEvents.SCROLL, this._update, this);
        this.slider.api.addEventListener(MSSliderEvent.RESIZE, this._resize, this);

        this._resize();

        if (this.options.autohide) {
            this.$bar.css('opacity', '0');
        }
    };

    p._resize = function () {
        this.vdimen = this.$element[this.__dimen]();
        this.bar_dimen = this.slider.api.view['__' + this.__dimen] * this.vdimen / this.scroller._max_value;
        this.$bar[this.__dimen](this.bar_dimen);
    };

    p._update = function () {
        var value = this.scroller.value * (this.vdimen - this.bar_dimen) / this.scroller._max_value;
        if (this.lvalue === value) return;
        this.lvalue = value;

        if (this.options.autohide) {
            clearTimeout(this.hto);
            this.$bar.css('opacity', '1');

            var that = this;
            this.hto = setTimeout(function () {
                //if(!that.slider.api.view.swipeControl.touchStarted)
                that.$bar.css('opacity', '0');
            }, 150);
        }

        if (value < 0) {
            this.$bar[0].style[this.__dimen] = this.bar_dimen + value + 'px';
            return;
        }

        if (value > this.vdimen - this.bar_dimen)
            this.$bar[0].style[this.__dimen] = this.vdimen - value + 'px';

        if (window._cssanim) {
            this.$bar[0].style[window._jcsspfx + 'Transform'] = this.__translate_start + value + 'px)' + this.__translate_end;
            return;
        }

        this.$bar[0].style[this.__pos] = value + 'px';

    };

    p.destroy = function () {
        _super.destroy();
        this.slider.api.view.removeEventListener(MSViewEvents.SCROLL, this._update, this);
        this.slider.api.removeEventListener(MSSliderEvent.RESIZE, this._resize, this);
        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);

        this.$element.remove();
    };

    window.MSScrollbar = MSScrollbar;
    MSSlideController.registerControl('scrollbar', MSScrollbar);
})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/Timebar.js =================== */
;
(function ($) {

    "use strict";

    var MSTimerbar = function (options) {
        BaseControl.call(this);

        this.options.autohide = false;
        this.options.width = 4;
        this.options.color = '#FFFFFF';
        this.options.inset = true;
        this.options.margin = 0;

        $.extend(this.options, options);
    };

    MSTimerbar.extend(BaseControl);

    var p = MSTimerbar.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */

    p.setup = function () {
        var that = this;
        _super.setup.call(this);

        this.$element = $('<div></div>')
            .addClass(this.options.prefix + 'timerbar');

        _super.setup.call(this);

        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element);
        } else {
            this.$element.appendTo(this.cont);
        }

        this.$bar = $('<div></div>')
            .addClass('ms-time-bar')
            .appendTo(this.$element);

        // change width 
        if (this.options.dir === 'v') {
            this.$bar.width(this.options.width);
            this.$element.width(this.options.width);
        } else {
            this.$bar.height(this.options.width);
            this.$element.height(this.options.width);
        }

        // change color
        this.$bar.css('background-color', this.options.color);

        if (!this.options.insetTo && this.options.align) {

            this.$element.css({
                top: 'auto',
                bottom: 'auto'
            });

            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === 'top') {
                this.$element.prependTo(this.slider.$element).css({
                    'margin-bottom': this.options.margin,
                    'position': 'relative'
                });
            } else if (align === 'bottom') {
                this.$element.css({
                    'margin-top': this.options.margin,
                    'position': 'relative'
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }
        }

        this.checkHideUnder(); // super method

    };

    /**
     * calls by "RESERVED_SPACE_CHGANE" realigns the control in slider
     * @since 1.5.7
     */
    p.align = function (event) {
        if (this.detached) {
            return;
        }

        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options.margin * 2 + this.options.width);
        this.$element.css(align, -pos - this.options.margin - this.options.width);
    };

    p.create = function () {
        _super.create.call(this);
        this.slider.api.addEventListener(MSSliderEvent.WAITING, this._update, this);
        this._update();
    };

    p._update = function () {
        this.$bar[0].style.width = this.slider.api._delayProgress + '%';
    };

    p.destroy = function () {
        _super.destroy();
        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
        this.slider.api.removeEventListener(MSSliderEvent.WAITING, this._update, this);
        this.$element.remove();
    };

    window.MSTimerbar = MSTimerbar;
    MSSlideController.registerControl('timebar', MSTimerbar);
})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/CircleTimer.js =================== */
;
(function ($) {

    "use strict";

    var MSCircleTimer = function (options) {
        BaseControl.call(this);

        this.options.color = '#A2A2A2';
        this.options.stroke = 10;
        this.options.radius = 4;

        this.options.autohide = false;
        $.extend(this.options, options);
    };

    MSCircleTimer.extend(BaseControl);

    var p = MSCircleTimer.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */

    p.setup = function () {
        var that = this;
        _super.setup.call(this);

        this.$element = $('<div></div>')
            .addClass(this.options.prefix + 'ctimer')
            .appendTo(this.cont);

        this.$canvas = $('<canvas></canvas>')
            .addClass('ms-ctimer-canvas')
            .appendTo(this.$element);

        this.$bar = $('<div></div>')
            .addClass('ms-ctimer-bullet')
            .appendTo(this.$element);

        if (!this.$canvas[0].getContext) {
            this.destroy();
            this.disable = true;
            return;
        }


        this.ctx = this.$canvas[0].getContext('2d');
        this.prog = 0;

        this.__w = (this.options.radius + this.options.stroke / 2) * 2;
        this.$canvas[0].width = this.__w;
        this.$canvas[0].height = this.__w;

        this.checkHideUnder(); // super method
    };

    p.create = function () {
        if (this.disable) return;
        _super.create.call(this);
        this.slider.api.addEventListener(MSSliderEvent.WAITING, this._update, this);

        var that = this;
        this.$element.click(function () {
            if (that.slider.api.paused)
                that.slider.api.resume();
            else
                that.slider.api.pause();
        });

        this._update();
    };

    p._update = function () {
        var that = this;
        $(this).stop(true).animate({
            prog: this.slider.api._delayProgress * 0.01
        }, {
            duration: 200,
            step: function () {
                that._draw();
            }
        });
        //this.$bar[0].style.width = this.slider.api._delayProgress/100 * this.$element.width() + 'px';
    };

    p._draw = function () {
        this.ctx.clearRect(0, 0, this.__w, this.__w);
        this.ctx.beginPath();
        this.ctx.arc(this.__w * .5, this.__w * .5, this.options.radius, Math.PI * 1.5, Math.PI * 1.5 + 2 * Math.PI * this.prog, false);
        this.ctx.strokeStyle = this.options.color;
        this.ctx.lineWidth = this.options.stroke;
        this.ctx.stroke();
    };

    p.destroy = function () {
        _super.destroy();
        if (this.disable) return;
        $(this).stop(true);
        this.slider.api.removeEventListener(MSSliderEvent.WAITING, this._update, this);
        this.$element.remove();
    };

    window.MSCircleTimer = MSCircleTimer;
    MSSlideController.registerControl('circletimer', MSCircleTimer);
})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/Lightbox.js =================== */
;
(function ($) {

    "use strict";

    window.MSLightbox = function (options) {
        BaseControl.call(this, options);

        this.options.autohide = false;
        $.extend(this.options, options);

        this.data_list = [];
    };
    MSLightbox.fadeDuratation = 400;
    MSLightbox.extend(BaseControl);

    var p = MSLightbox.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */
    p.setup = function () {
        _super.setup.call(this);

        this.$element = $('<div></div>')
            .addClass(this.options.prefix + 'lightbox-btn')
            .appendTo(this.cont);

        this.checkHideUnder(); // super method
    };

    p.slideAction = function (slide) {
        $('<div></div>')
            .addClass(this.options.prefix + 'lightbox-btn')
            .appendTo(slide.$element)
            .append($(slide.$element.find('.ms-lightbox')));

    };

    p.create = function () {
        _super.create.call(this);

    };


    MSSlideController.registerControl('lightbox', MSLightbox);
})(jQuery);

/* ================== bin-debug/js/pro/uicontrols/SlideInfo.js =================== */
;
(function ($) {

    "use strict";

    window.MSSlideInfo = function (options) {
        BaseControl.call(this, options);

        this.options.autohide = false;
        this.options.align = null;
        this.options.inset = false;
        this.options.margin = 10;
        this.options.size = 100;
        this.options.dir = 'h';

        $.extend(this.options, options);

        this.data_list = [];
    };
    MSSlideInfo.fadeDuratation = 400;
    MSSlideInfo.extend(BaseControl);

    var p = MSSlideInfo.prototype;
    var _super = BaseControl.prototype;

    /* -------------------------------- */
    p.setup = function () {
        this.$element = $('<div></div>')
            .addClass(this.options.prefix + 'slide-info')
            .addClass('ms-dir-' + this.options.dir);

        _super.setup.call(this);

        if (this.slider.$controlsCont === this.cont) {
            this.$element.appendTo(this.slider.$element); // insert in outer container out of overflow hidden
        } else {
            this.$element.appendTo(this.cont);
        }

        // align control
        if (!this.options.insetTo && this.options.align) {
            var align = this.options.align;
            if (this.options.inset) {
                this.$element.css(align, this.options.margin);
            } else if (align === 'top') {
                this.$element.prependTo(this.slider.$element).css({
                    'margin-bottom': this.options.margin,
                    'position': 'relative'
                });
            } else if (align === 'bottom') {
                this.$element.css({
                    'margin-top': this.options.margin,
                    'position': 'relative'
                });
            } else {
                this.slider.api.addEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
                this.align();
            }

            if (this.options.dir === 'v') {
                this.$element.width(this.options.size);
            } else {
                this.$element.css('min-height', this.options.size);
            }
        }

        this.checkHideUnder(); // super method
    };

    /**
     * calls by "RESERVED_SPACE_CHGANE" realigns the control in slider
     * @since 1.5.7
     */
    p.align = function (event) {
        if (this.detached) {
            return;
        }
        var align = this.options.align;
        var pos = this.slider.reserveSpace(align, this.options.size + this.options.margin * 2);
        this.$element.css(align, -pos - this.options.size - this.options.margin);
    };

    p.slideAction = function (slide) {
        var info_ele = $(slide.$element.find('.ms-info'));
        var that = this;
        info_ele.detach();

        this.data_list[slide.index] = info_ele;
    };

    p.create = function () {
        _super.create.call(this);
        this.slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.update, this);
        this.cindex = this.slider.api.index();
        this.switchEle(this.data_list[this.cindex]);
    };

    p.update = function () {
        var nindex = this.slider.api.index();
        this.switchEle(this.data_list[nindex]);
        this.cindex = nindex;
    };

    p.switchEle = function (ele) {
        if (this.current_ele) {
            var that = this;

            if (this.current_ele[0].tween) this.current_ele[0].tween.stop(true);
            this.current_ele[0].tween = CTween.animate(this.current_ele, MSSlideInfo.fadeDuratation, {
                opacity: 0
            }, {
                complete: function () {
                    this.detach();
                    this[0].tween = null;
                    ele.css('position', 'relative');
                },
                target: this.current_ele
            });

            //this.current_ele.css('position', 'absolute');			
            ele.css('position', 'absolute');
        }

        this.__show(ele);
    };

    p.__show = function (ele) {
        ele.appendTo(this.$element).css('opacity', '0'); ///.css('position', 'relative');

        // calculate max height
        if (this.current_ele) {
            ele.height(Math.max(ele.height(), this.current_ele.height()));
        }

        clearTimeout(this.tou);
        this.tou = setTimeout(function () {
            CTween.fadeIn(ele, MSSlideInfo.fadeDuratation);
            ele.css('height', '');
        }, MSSlideInfo.fadeDuratation);


        if (ele[0].tween) ele[0].tween.stop(true);
        this.current_ele = ele;
    };

    p.destroy = function () {
        _super.destroy();
        clearTimeout(this.tou);
        if (this.current_ele && this.current_ele[0].tween) {
            this.current_ele[0].tween.stop('true');
        }
        this.$element.remove();
        this.slider.api.removeEventListener(MSSliderEvent.RESERVED_SPACE_CHANGE, this.align, this);
        this.slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.update, this);
    };

    MSSlideController.registerControl('slideinfo', MSSlideInfo);
})(jQuery);

/* ================== bin-debug/js/pro/plugins/MSGallery.js =================== */
/**
 *	Master Slider, Gallery Template v1.0
 * 	@author: Averta Ltd.
 */

;
(function ($) {

    window.MSGallery = function (id, slider) {
        this.id = id;
        this.slider = slider;

        this.telement = $('#' + id);

        this.botcont = $('<div></div>').addClass('ms-gallery-botcont').appendTo(this.telement);
        this.thumbcont = $('<div></div>').addClass('ms-gal-thumbcont hide-thumbs').appendTo(this.botcont);
        this.playbtn = $('<div></div>').addClass('ms-gal-playbtn').appendTo(this.botcont);
        this.thumbtoggle = $('<div></div>').addClass('ms-gal-thumbtoggle').appendTo(this.botcont);

        // adds required controls to slider
        slider.control('thumblist', {
            insertTo: this.thumbcont,
            autohide: false,
            dir: 'h'
        });
        slider.control('slidenum', {
            insertTo: this.botcont,
            autohide: false
        });
        slider.control('slideinfo', {
            insertTo: this.botcont,
            autohide: false
        });
        slider.control('timebar', {
            insertTo: this.botcont,
            autohide: false
        });
        slider.control('bullets', {
            insertTo: this.botcont,
            autohide: false
        });
    };

    var p = MSGallery.prototype;

    p._init = function () {
        var that = this;

        if (!this.slider.api.paused)
            this.playbtn.addClass('btn-pause');

        this.playbtn.click(function () {
            if (that.slider.api.paused) {
                that.slider.api.resume();
                that.playbtn.addClass('btn-pause');
            } else {
                that.slider.api.pause();
                that.playbtn.removeClass('btn-pause');
            }
        });


        this.thumbtoggle.click(function () {

            if (that.vthumbs) {
                //that.hideThumbs();
                that.thumbtoggle.removeClass('btn-hide');
                that.vthumbs = false;
                that.thumbcont.addClass('hide-thumbs');
            } else {
                //that.showThumbs();
                that.thumbtoggle.addClass('btn-hide');
                that.thumbcont.removeClass('hide-thumbs');
                that.vthumbs = true;
            }
        });

    };

    p.setup = function () {
        var that = this;
        $(document).ready(function () {
            that._init();
        });
    };


})(jQuery);

/* ================== bin-debug/js/pro/plugins/MSFlickrV2.js =================== */
/**
 * Master Slider Flickr Plugin Version 2
 * @version 2.0.0
 * @author Averta Ltd.
 */
;
(function ($) {

    /**
     * Generate Flickr photoset url
     * @param  {String} key   api key
     * @param  {String} id    photoset id
     * @param  {Number} count number of images
     * @return {String}
     */
    var getPhotosetURL = function (key, id, count) {
        return 'https://api.flickr.com/services/rest/?method=flickr.photosets.getPhotos&api_key=' + key + '&photoset_id=' + id + '&per_page=' + count + '&extras=url_o,description,date_taken,owner_name,views&format=json&jsoncallback=?';
    };

    /**
     * Generate Flickr user public images url
     * @param  {String} key   api key
     * @param  {String} id    user id
     * @param  {Number} count number of images
     * @return {String}
     */
    var getUserPublicURL = function (key, id, count) {
        return 'https://api.flickr.com/services/rest/?&method=flickr.people.getPublicPhotos&api_key=' + key + '&user_id=' + id + '&per_page=' + count + '&extras=url_o,description,date_taken,owner_name,views&format=json&jsoncallback=?';
    };

    /**
     * Generates image path
     * @param  {String} fid    
     * @param  {String} server 
     * @param  {String} id     
     * @param  {String} secret 
     * @param  {String} size   
     * @return {String}        
     */
    var getImageSource = function (fid, server, id, secret, size, data) {
        if (size === '_o' && data) {
            return data.url_o;
        }

        return 'https://farm' + fid + '.staticflickr.com/' + server + '/' + id + '_' + secret + size + '.jpg';
    };

    window.MSFlickrV2 = function (slider, options) {
        var _options = {
            count: 10,
            type: 'photoset',
            /*
             * s small square 75x75 
             * q large square 150x150 
             * t thumbnail, 100 on longest side
             */
            thumbSize: 'q',

            /*
             * -	medium, 500 on longest side
             * z	medium 640, 640 on longest side
             * c	medium 800, 800 on longest side
             * b	large, 1024 on longest side
             * o	original image, either a jpg, gif or png, depending on source format
             */
            imgSize: 'c'
        };

        this.slider = slider;
        this.slider.holdOn();

        if (!options.key) {
            this.errMsg('Flickr API Key required. Please add it in settings.');
            return;
        }

        $.extend(_options, options);
        this.options = _options;

        var that = this;

        if (this.options.type === 'photoset') {
            $.getJSON(getPhotosetURL(this.options.key, this.options.id, this.options.count), function (data) {
                that._photosData(data);
            });
        } else {
            $.getJSON(getUserPublicURL(this.options.key, this.options.id, this.options.count), function (data) {
                that.options.type = 'photos';
                that._photosData(data);
            });
        }

        if (this.options.imgSize !== '' && this.options.imgSize !== '-')
            this.options.imgSize = '_' + this.options.imgSize;

        this.options.thumbSize = '_' + this.options.thumbSize;

        // grab slide template from slider markup
        this.slideTemplate = this.slider.$element.find('.ms-slide')[0].outerHTML;
        this.slider.$element.find('.ms-slide').remove(); // remove all slides from slider markup
    };

    var p = MSFlickrV2.prototype;

    p._photosData = function (data) {

        if (data.stat === 'fail') {
            this.errMsg('Flickr API ERROR#' + data.code + ': ' + data.message);
            return;
        }

        var that = this;
        var getInfo = this.options.author || this.options.desc;
        $.each(data[this.options.type].photo, function (i, item) {

            var slide_cont = that.slideTemplate.replace(/{{[\w-]+}}/g, function (match) {
                match = match.replace(/{{|}}/g, '');
                if (shortCodes[match]) {
                    return shortCodes[match](item, that);
                } else {
                    return '{{' + match + '}}';
                }

            });

            $(slide_cont).appendTo(that.slider.$element);

        });

        that._initSlider();
    };

    p.errMsg = function (msg) {
        this.slider.$element.css('display', 'block');
        if (!this.errEle)
            this.errEle = $('<div style="font-family:Arial; color:red; font-size:12px; position:absolute; top:10px; left:10px"></div>').appendTo(this.slider.$loading);

        this.errEle.html(msg);
    };

    p._initSlider = function () {
        this.slider.release();
    };

    // a list of functions that generates data from short codes
    var shortCodes = {
        'image': function (data, that) {
            return getImageSource(data.farm, data.server, data.id, data.secret, that.options.imgSize, data);
        },

        'thumb': function (data, that) {
            return getImageSource(data.farm, data.server, data.id, data.secret, that.options.thumbSize);
        },

        'title': function (data, that) {
            return data.title;
        },

        'owner-name': function (data, that) {
            return data.ownername;
        },

        'date-taken': function (data, that) {
            return data.datetaken;
        },

        'views': function (data, that) {
            return data.views;
        },

        'description': function (data, that) {
            return data.description._content;
        }
    };

})(jQuery);

/* ================== bin-debug/js/pro/plugins/MSFacebookGallery.js =================== */
/**
 * Master Slider Facebook Gallery plugin
 * @author Averta Ltd.
 * @version 1.0.0
 */
;
(function ($) {


    window.MSFacebookGallery = function (slider, options) {
        var _options = {
            count: 10,
            type: 'photostream', // album
            /*
            orginal/960/720/600/480/320/130
             */
            thumbSize: '320',

            /*
 			orginal/960/720/600/480/320/130
 			 */
            imgSize: 'orginal',

            https: false,
            token: ''
        };

        this.slider = slider;
        this.slider.holdOn();

        $.extend(_options, options);
        this.options = _options;

        //this.graph = this.options.https ? 'https://graph.facebook.com' : 'http://graph.facebook.com';
        this.graph = 'https://graph.facebook.com';

        var that = this;

        if (this.options.type === 'photostream') {
            $.getJSON(this.graph + '/' + this.options.username + '/photos/uploaded/?fields=source,name,link,images,from&limit=' + this.options.count + '&access_token=' + this.options.token, function (data) {
                that._photosData(data);
            });
        } else {
            $.getJSON(this.graph + '/' + this.options.albumId + '/photos?fields=source,name,link,images,from&limit=' + this.options.count + '&access_token=' + this.options.token, function (data) {
                that._photosData(data);
            });
        }

        // grab slide template from slider markup
        this.slideTemplate = this.slider.$element.find('.ms-slide')[0].outerHTML;
        this.slider.$element.find('.ms-slide').remove(); // remove all slides from slider markup
    };

    var p = MSFacebookGallery.prototype;

    p._photosData = function (content) {

        if (content.error) {
            this.errMsg('Facebook API ERROR#' + content.error.code + '(' + content.error.type + ')' + ': ' + content.error.message);
            return;
        }

        var that = this;
        var getInfo = this.options.author || this.options.desc;

        for (var i = 0, l = content.data.length; i !== l; i++) {

            var slide_cont = that.slideTemplate.replace(/{{[\w-]+}}/g, function (match) {
                match = match.replace(/{{|}}/g, '');
                if (shortCodes[match]) {
                    return shortCodes[match](content.data[i], that);
                } else {
                    return '{{' + match + '}}';
                }

            });

            $(slide_cont).appendTo(that.slider.$element);
        }

        that._initSlider();
    };

    p.errMsg = function (msg) {
        this.slider.$element.css('display', 'block');
        if (!this.errEle)
            this.errEle = $('<div style="font-family:Arial; color:red; font-size:12px; position:absolute; top:10px; left:10px"></div>').appendTo(this.slider.$loading);

        this.errEle.html(msg);
    };

    p._initSlider = function () {
        this.slider.release();
    };

    var getImageSource = function (images, size) {

        if (size === 'orginal') {
            return images[0].source;
        }

        for (var i = 0, l = images.length; i !== l; i++) {
            if (images[i].source.indexOf(size + 'x' + size) !== -1)
                return images[i].source;
        }
        //  console.log(images)
        return images[0].source;
    };

    // a list of functions that generates data from short codes
    var shortCodes = {
        'image': function (data, that) {

            return getImageSource(data.images, that.options.imgSize);
        },

        'thumb': function (data, that) {
            return getImageSource(data.images, that.options.thumbSize);
        },

        'name': function (data, that) {
            return data.name;
        },

        'owner-name': function (data, that) {
            return data.from.name;
        },

        'link': function (data, that) {
            return data.link;
        }
    };

})(jQuery);

/* ================== bin-debug/js/pro/plugins/MSScrollParallax.js =================== */
/**
 * Master Slider Parallax Layers Fade
 * @description Moves and fades layers of current slide while scrolling window.
 * @package MasterSlider
 * @author Averta
 * @since v1.8.0
 */

(function ($) {

    'use strict';

    window.MSScrollParallax = function (slider, parallax, bgparallax, fade) {
        this.fade = fade;
        this.slider = slider;
        this.parallax = parallax / 100;
        this.bgparallax = bgparallax / 100;

        slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
        slider.api.addEventListener(MSSliderEvent.DESTROY, this.destory, this);
        slider.api.addEventListener(MSSliderEvent.CHANGE_END, this.resetLayers, this);
        slider.api.addEventListener(MSSliderEvent.CHANGE_START, this.updateCurrentSlide, this);
    };

    window.MSScrollParallax.setup = function (slider, parallax, bgparallax, fade) {
        // disable in mobile devices
        if (window._mobile) {
            return;
        }

        if (parallax == null) {
            parallax = 50;
        }

        if (bgparallax == null) {
            bgparallax = 40;
        }

        return new MSScrollParallax(slider, parallax, bgparallax, fade);
    };

    var p = window.MSScrollParallax.prototype;

    p.init = function (e) {
        this.slider.$element.addClass('ms-scroll-parallax');
        this.sliderOffset = this.slider.$element.offset().top;
        this.updateCurrentSlide();
        // wrap layers element
        var slides = this.slider.api.view.slideList,
            slide;
        for (var i = 0, l = slides.length; i !== l; i++) {
            slide = slides[i];
            if (slide.hasLayers) {
                slide.layerController.$layers.wrap('<div class="ms-scroll-parallax-cont"></div>');
                slide.$scrollParallaxCont = slide.layerController.$layers.parent();
            }
        }

        $(window).on('scroll', {
            that: this
        }, this.moveParallax).trigger('scroll');
    };

    p.resetLayers = function (e) {
        if (!this.lastSlide) {
            return;
        }

        var layers = this.lastSlide.$scrollParallaxCont;

        if (window._css2d) {
            if (layers) {
                layers[0].style[window._jcsspfx + 'Transform'] = '';
            }

            if (this.lastSlide.hasBG) {
                this.lastSlide.$imgcont[0].style[window._jcsspfx + 'Transform'] = '';
            }

        } else {
            if (layers) {
                layers[0].style.top = '';
            }

            if (this.lastSlide.hasBG) {
                this.lastSlide.$imgcont[0].style.top = '0px';
            }
        }
    };

    p.updateCurrentSlide = function (e) {
        this.lastSlide = this.currentSlide;

        this.currentSlide = this.slider.api.currentSlide;
        this.moveParallax({
            data: {
                that: this
            }
        });
    };

    p.moveParallax = function (e) {
        var that = e.data.that,
            slider = that.slider,
            offset = that.sliderOffset,
            scrollTop = $(window).scrollTop(),
            layers = that.currentSlide.$scrollParallaxCont,
            out = offset - scrollTop;

        if (out <= 0) {

            if (layers) {
                if (window._css3d) {
                    layers[0].style[window._jcsspfx + 'Transform'] = 'translateY(' + -out * that.parallax + 'px) translateZ(0.4px)';
                } else if (window._css2d) {
                    layers[0].style[window._jcsspfx + 'Transform'] = 'translateY(' + -out * that.parallax + 'px)';
                } else {
                    layers[0].style.top = -out * that.parallax + 'px';
                }
            }

            that.updateSlidesBG(-out * that.bgparallax + 'px', true);

            if (layers && that.fade) {
                layers.css('opacity', (1 - Math.min(1, -out / slider.api.height)));
            }

        } else {
            if (layers) {
                if (window._css2d) {
                    layers[0].style[window._jcsspfx + 'Transform'] = '';
                } else {
                    layers[0].style.top = '';
                }
            }

            that.updateSlidesBG('0px', false);

            if (layers && that.fade) {
                layers.css('opacity', 1);
            }

        }

    };

    p.updateSlidesBG = function (pos, fixed) {
        var slides = this.slider.api.view.slideList,
            position = (fixed && !$.browser.msie && !$.browser.opera ? 'fixed' : '');

        for (var i = 0, l = slides.length; i !== l; i++) {
            if (slides[i].hasBG) {
                slides[i].$imgcont[0].style.position = position;
                slides[i].$imgcont[0].style.top = pos;
            }

            if (slides[i].$bgvideocont) {
                slides[i].$bgvideocont[0].style.position = position;
                slides[i].$bgvideocont[0].style.top = pos;
            }
        }

    };

    p.destory = function () {
        slider.api.removeEventListener(MSSliderEvent.INIT, this.init, this);
        slider.api.removeEventListener(MSSliderEvent.DESTROY, this.destory, this);
        slider.api.removeEventListener(MSSliderEvent.CHANGE_END, this.resetLayers, this);
        slider.api.removeEventListener(MSSliderEvent.CHANGE_START, this.updateCurrentSlide, this);
        $(window).off('scroll', this.moveParallax);
    };

})(jQuery);

/* ================== bin-debug/js/pro/plugins/MSKeyboardNav.js =================== */
/**
 * Keyboard navigation plugin for Master Slider.
 * @version  1.0.0
 * @author Averta
 * @package MasterSlider jQuery
 */
;
(function ($, document, window) {
    var PId = 0;

    // check if master slider is available
    if (!window.MasterSlider) {
        return;
    }

    var KeyboardNav = function (slider) {
        this.slider = slider;
        this.PId = PId++;

        if (this.slider.options.keyboard) {
            slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
        }
    };

    KeyboardNav.name = 'MSKeyboardNav';
    var p = KeyboardNav.prototype;

    /**
     * initiate the plugin
     */
    p.init = function () {
        var api = this.slider.api;

        $(document).on('keydown.kbnav' + this.PId, function (event) {
            var which = event.which;

            if (which === 37 || which === 40) {
                api.previous(true);
            } else if (which === 38 || which === 39) {
                api.next(true);
            }

        });

    };

    /**
     * destroy the plugin
     */
    p.destroy = function () {
        $(document).off('keydown.kbnav' + this.PId);
        this.slider.api.removeEventListener(MSSliderEvent.INIT, this.init, this);
    };

    // install plugin to master slider
    MasterSlider.registerPlugin(KeyboardNav);

})(jQuery, document, window);

/* ================== bin-debug/js/pro/plugins/MSStartOnAppear.js =================== */
/**
 * Start on appear plugin for Master Slider.
 * 
 * @description This plugin prevents slider automatically initialization and inits slider when it appears inside of the browser window.
 * @version  1.0.0
 * @author Averta
 * @package MasterSlider jQuery
 */

;
(function ($, document, window) {
    var PId = 0,
        $window = $(window),
        $doc = $(document);

    // check if master slider is available
    if (!window.MasterSlider) {
        return;
    }

    var StartOnAppear = function (slider) {
        this.PId = PId++;
        this.slider = slider;
        this.$slider = slider.$element;

        if (this.slider.options.startOnAppear) {
            // hold on slider
            slider.holdOn();
            $doc.ready($.proxy(this.init, this));
        }
    };

    StartOnAppear.name = 'MSStartOnAppear';
    var p = StartOnAppear.prototype;

    /**
     * initiate the plugin
     */
    p.init = function () {
        var api = this.slider.api;
        $window.on('scroll.soa' + this.PId, $.proxy(this._onScroll, this)).trigger('scroll');
    };

    p._onScroll = function () {
        // check slider position
        var vpBottom = $window.scrollTop() + $window.height(),
            top = this.$slider.offset().top;

        if (top < vpBottom) {
            $window.off('scroll.soa' + this.PId);
            this.slider.release();
        }
    };

    /**
     * destroy the plugin
     */
    p.destroy = function () {};

    // install plugin to master slider
    MasterSlider.registerPlugin(StartOnAppear);

})(jQuery, document, window);

/* ================== bin-debug/js/pro/plugins/MSFilters.js =================== */
/**
 * Master Slider Filters Plugin
 * This plugin adds CSS3 filters to the slides, like brightness, grayscale, sepia, ... It works in major browser and devices but in IE `opacity` only supported.
 * 
 * @package Master Slider jQuery
 * @author Averta
 * @version  1.0.0a
 */

;
(function (document, window, jQuery) {

    var filterUnits = {
            'hue-rotate': 'deg',
            'blur': 'px'
        },
        initialValues = {
            'opacity': 1,
            'contrast': 1,
            'brightness': 1,
            'saturate': 1,
            'hue-rotate': 0,
            'invert': 0,
            'sepia': 0,
            'blur': 0,
            'grayscale': 0
        }

    // check if master slider is available
    if (!window.MasterSlider) {
        return;
    }

    var Filters = function (slider) {
        this.slider = slider;

        if (this.slider.options.filters) {
            slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
        }
    };

    Filters.name = 'MSFilters';
    var p = Filters.prototype;

    /**
     * initiate the plugin
     */
    p.init = function () {
        var api = this.slider.api,
            view = api.view;

        this.filters = this.slider.options.filters;
        this.slideList = view.slideList;
        this.slidesCount = view.slidesCount;
        this.dimension = view[view.__dimension];
        this.target = this.slider.options.filterTarget === 'slide' ? '$element' : '$bg_img';
        this.filterName = $.browser.webkit ? 'WebkitFilter' : 'filter';

        // override controller update callback
        var superFun = view.controller.__renderHook.fun,
            superRef = view.controller.__renderHook.ref;
        view.controller.renderCallback(function (controller, value) {
            superFun.call(superRef, controller, value);
            this.applyEffect(value);
        }, this);
        this.applyEffect(view.controller.value);

    };

    /**
     * Apply css effect to slides based on slide position.
     * @param  {Number} value Current position of slider controller
     */
    p.applyEffect = function (value) {
        var factor, slide;

        for (var i = 0; i < this.slidesCount; ++i) {
            slide = this.slideList[i];
            factor = Math.min(1, Math.abs(value - slide.position) / this.dimension);

            if (slide[this.target]) {
                if (!$.browser.msie) {
                    slide[this.target][0].style[this.filterName] = this.generateStyle(factor);
                } else if (this.filters.opacity != null && slide[this.target].opacity != null) {
                    slide[this.target].opacity(1 - this.filters.opacity * factor);
                }
            }
        }
    };

    /**
     * Generate filter style based on slide distance factor
     * @param  {Number} factor 
     * @return {String} CSS style
     */
    p.generateStyle = function (factor) {
        var style = '',
            unit;

        for (var filter in this.filters) {
            unit = filterUnits[filter] || '';
            style += filter + '(' + (initialValues[filter] + (this.filters[filter] - initialValues[filter]) * factor) + ') ';
        }

        return style;
    };

    /**
     * destroy the plugin
     */
    p.destroy = function () {
        this.slider.api.removeEventListener(MSSliderEvent.INIT, this.init, this);
    };

    // install plugin to master slider
    MasterSlider.registerPlugin(Filters);


})(document, window, jQuery);

/* ================== bin-debug/js/pro/plugins/MSScrollToAction.js =================== */
/**
 * Master Slider Scroll To Action Plugin.
 * 
 * @description This plugins adds page scrolling actions to the layer actions list.
 * @version  1.0.0
 * @author Averta
 * @package MasterSlider jQuery
 */

;
(function ($, document, window) {

    // check if master slider is available
    if (!window.MasterSlider) {
        return;
    }

    var ScrollToAction = function (slider) {
        this.slider = slider;
        slider.api.addEventListener(MSSliderEvent.INIT, this.init, this);
    };

    ScrollToAction.name = 'MSScrollToAction';
    var p = ScrollToAction.prototype;

    /**
     * initiate the plugin
     */
    p.init = function () {
        var api = this.slider.api;

        // define actions
        api.scrollToEnd = _scrollToEnd;
        api.scrollTo = _scrollTo;
    };

    /**
     * destroy the plugin
     */
    p.destroy = function () {};

    /**
     * Scroll window to the target element in page
     * @param {Number} duration animation duration (seconds)
     */
    var _scrollTo = function (target, duration) {
        var sliderEle = this.slider.$element,
            target = $(target).eq(0);

        if (target.length === 0) {
            return;
        }
        console.log(target.offset().top, duration)

        if (duration == null) {
            duration = 1.4;
        }

        $('html, body').animate({
            scrollTop: target.offset().top
        }, duration * 1000, 'easeInOutQuad');
    };

    /**
     * Scroll window to the bottom of slider
     * @param {Number} duration animation duration (seconds)
     */
    var _scrollToEnd = function (duration) {
        var sliderEle = this.slider.$element;

        if (duration == null) {
            duration = 1.4;
        }

        $('html, body').animate({
            scrollTop: sliderEle.offset().top + sliderEle.outerHeight(false)
        }, duration * 1000, 'easeInOutQuad');
    }

    // install plugin to master slider
    MasterSlider.registerPlugin(ScrollToAction);

})(jQuery, document, window);

/* ================== bin-debug/js/pro/plugins/MSReadyCheck.js =================== */
;
(function ($, window, document, undefined) {
    "use strict";

    // sample of using MSReady
    // ( window.MSReady = MSReady || [] ).push( function( jQuery ) {

    // });

    if (window.MSReady) {
        for (var i = 0, l = MSReady.length; i !== l; i++) {
            MSReady[i].call(null, $);
        }
    }
})(jQuery, window, document);
$(document).ready(function () {
    if ($('#navbar li').length == 0) {
        $('.navbar-header .navbar-toggle').hide();
        $('.navbar-right').css("right", "0");
    }
});
// DOM.event.move
//
// 2.0.0
//
// Stephen Band
//
// Triggers 'movestart', 'move' and 'moveend' events after
// mousemoves following a mousedown cross a distance threshold,
// similar to the native 'dragstart', 'drag' and 'dragend' events.
// Move events are throttled to animation frames. Move event objects
// have the properties:
//
// pageX:
// pageY:     Page coordinates of pointer.
// startX:
// startY:    Page coordinates of pointer at movestart.
// distX:
// distY:     Distance the pointer has moved since movestart.
// deltaX:
// deltaY:    Distance the finger has moved since last event.
// velocityX:
// velocityY: Average velocity over last few events.


(function (fn) {
    if (typeof define === 'function' && define.amd) {
        define([], fn);
    } else if ((typeof module !== "undefined" && module !== null) && module.exports) {
        module.exports = fn;
    } else {
        fn();
    }
})(function () {
    var assign = Object.assign || window.jQuery && jQuery.extend;

    // Number of pixels a pressed pointer travels before movestart
    // event is fired.
    var threshold = 8;

    // Shim for requestAnimationFrame, falling back to timer. See:
    // see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    var requestFrame = (function () {
        return (
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (fn, element) {
                return window.setTimeout(function () {
                    fn();
                }, 25);
            }
        );
    })();

    // Shim for customEvent
    // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill
    (function () {
        if (typeof window.CustomEvent === "function") return false;

        function CustomEvent(event, params) {
            params = params || {
                bubbles: false,
                cancelable: false,
                detail: undefined
            };
            var evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            return evt;
        }

        CustomEvent.prototype = window.Event.prototype;
        window.CustomEvent = CustomEvent;
    })();

    var ignoreTags = {
        textarea: true,
        input: true,
        select: true,
        button: true
    };

    var mouseevents = {
        move: 'mousemove',
        cancel: 'mouseup dragstart',
        end: 'mouseup'
    };

    var touchevents = {
        move: 'touchmove',
        cancel: 'touchend',
        end: 'touchend'
    };

    var rspaces = /\s+/;


    // DOM Events

    var eventOptions = {
        bubbles: true,
        cancelable: true
    };

    var eventsSymbol = typeof Symbol === "function" ? Symbol('events') : {};

    function createEvent(type) {
        return new CustomEvent(type, eventOptions);
    }

    function getEvents(node) {
        return node[eventsSymbol] || (node[eventsSymbol] = {});
    }

    function on(node, types, fn, data, selector) {
        types = types.split(rspaces);

        var events = getEvents(node);
        var i = types.length;
        var handlers, type;

        function handler(e) {
            fn(e, data);
        }

        while (i--) {
            type = types[i];
            handlers = events[type] || (events[type] = []);
            handlers.push([fn, handler]);
            node.addEventListener(type, handler);
        }
    }

    function off(node, types, fn, selector) {
        types = types.split(rspaces);

        var events = getEvents(node);
        var i = types.length;
        var type, handlers, k;

        if (!events) {
            return;
        }

        while (i--) {
            type = types[i];
            handlers = events[type];
            if (!handlers) {
                continue;
            }
            k = handlers.length;
            while (k--) {
                if (handlers[k][0] === fn) {
                    node.removeEventListener(type, handlers[k][1]);
                    handlers.splice(k, 1);
                }
            }
        }
    }

    function trigger(node, type, properties) {
        // Don't cache events. It prevents you from triggering an event of a
        // given type from inside the handler of another event of that type.
        var event = createEvent(type);
        if (properties) {
            assign(event, properties);
        }
        node.dispatchEvent(event);
    }


    // Constructors

    function Timer(fn) {
        var callback = fn,
            active = false,
            running = false;

        function trigger(time) {
            if (active) {
                callback();
                requestFrame(trigger);
                running = true;
                active = false;
            } else {
                running = false;
            }
        }

        this.kick = function (fn) {
            active = true;
            if (!running) {
                trigger();
            }
        };

        this.end = function (fn) {
            var cb = callback;

            if (!fn) {
                return;
            }

            // If the timer is not running, simply call the end callback.
            if (!running) {
                fn();
            }
            // If the timer is running, and has been kicked lately, then
            // queue up the current callback and the end callback, otherwise
            // just the end callback.
            else {
                callback = active ?
                    function () {
                        cb();
                        fn();
                    } :
                    fn;

                active = true;
            }
        };
    }


    // Functions

    function noop() {}

    function preventDefault(e) {
        e.preventDefault();
    }

    function isIgnoreTag(e) {
        return !!ignoreTags[e.target.tagName.toLowerCase()];
    }

    function isPrimaryButton(e) {
        // Ignore mousedowns on any button other than the left (or primary)
        // mouse button, or when a modifier key is pressed.
        return (e.which === 1 && !e.ctrlKey && !e.altKey);
    }

    function identifiedTouch(touchList, id) {
        var i, l;

        if (touchList.identifiedTouch) {
            return touchList.identifiedTouch(id);
        }

        // touchList.identifiedTouch() does not exist in
        // webkit yet… we must do the search ourselves...

        i = -1;
        l = touchList.length;

        while (++i < l) {
            if (touchList[i].identifier === id) {
                return touchList[i];
            }
        }
    }

    function changedTouch(e, data) {
        var touch = identifiedTouch(e.changedTouches, data.identifier);

        // This isn't the touch you're looking for.
        if (!touch) {
            return;
        }

        // Chrome Android (at least) includes touches that have not
        // changed in e.changedTouches. That's a bit annoying. Check
        // that this touch has changed.
        if (touch.pageX === data.pageX && touch.pageY === data.pageY) {
            return;
        }

        return touch;
    }


    // Handlers that decide when the first movestart is triggered

    function mousedown(e) {
        // Ignore non-primary buttons
        if (!isPrimaryButton(e)) {
            return;
        }

        // Ignore form and interactive elements
        if (isIgnoreTag(e)) {
            return;
        }

        on(document, mouseevents.move, mousemove, e);
        on(document, mouseevents.cancel, mouseend, e);
    }

    function mousemove(e, data) {
        checkThreshold(e, data, e, removeMouse);
    }

    function mouseend(e, data) {
        removeMouse();
    }

    function removeMouse() {
        off(document, mouseevents.move, mousemove);
        off(document, mouseevents.cancel, mouseend);
    }

    function touchstart(e) {
        // Don't get in the way of interaction with form elements
        if (ignoreTags[e.target.tagName.toLowerCase()]) {
            return;
        }

        var touch = e.changedTouches[0];

        // iOS live updates the touch objects whereas Android gives us copies.
        // That means we can't trust the touchstart object to stay the same,
        // so we must copy the data. This object acts as a template for
        // movestart, move and moveend event objects.
        var data = {
            target: touch.target,
            pageX: touch.pageX,
            pageY: touch.pageY,
            identifier: touch.identifier,

            // The only way to make handlers individually unbindable is by
            // making them unique.
            touchmove: function (e, data) {
                touchmove(e, data);
            },
            touchend: function (e, data) {
                touchend(e, data);
            }
        };

        on(document, touchevents.move, data.touchmove, data);
        on(document, touchevents.cancel, data.touchend, data);
    }

    function touchmove(e, data) {
        var touch = changedTouch(e, data);
        if (!touch) {
            return;
        }
        checkThreshold(e, data, touch, removeTouch);
    }

    function touchend(e, data) {
        var touch = identifiedTouch(e.changedTouches, data.identifier);
        if (!touch) {
            return;
        }
        removeTouch(data);
    }

    function removeTouch(data) {
        off(document, touchevents.move, data.touchmove);
        off(document, touchevents.cancel, data.touchend);
    }

    function checkThreshold(e, data, touch, fn) {
        var distX = touch.pageX - data.pageX;
        var distY = touch.pageY - data.pageY;

        // Do nothing if the threshold has not been crossed.
        if ((distX * distX) + (distY * distY) < (threshold * threshold)) {
            return;
        }

        triggerStart(e, data, touch, distX, distY, fn);
    }

    function triggerStart(e, data, touch, distX, distY, fn) {
        var touches = e.targetTouches;
        var time = e.timeStamp - data.timeStamp;

        // Create a movestart object with some special properties that
        // are passed only to the movestart handlers.
        var template = {
            altKey: e.altKey,
            ctrlKey: e.ctrlKey,
            shiftKey: e.shiftKey,
            startX: data.pageX,
            startY: data.pageY,
            distX: distX,
            distY: distY,
            deltaX: distX,
            deltaY: distY,
            pageX: touch.pageX,
            pageY: touch.pageY,
            velocityX: distX / time,
            velocityY: distY / time,
            identifier: data.identifier,
            targetTouches: touches,
            finger: touches ? touches.length : 1,
            enableMove: function () {
                this.moveEnabled = true;
                this.enableMove = noop;
                e.preventDefault();
            }
        };

        // Trigger the movestart event.
        trigger(data.target, 'movestart', template);

        // Unbind handlers that tracked the touch or mouse up till now.
        fn(data);
    }


    // Handlers that control what happens following a movestart

    function activeMousemove(e, data) {
        var timer = data.timer;

        data.touch = e;
        data.timeStamp = e.timeStamp;
        timer.kick();
    }

    function activeMouseend(e, data) {
        var target = data.target;
        var event = data.event;
        var timer = data.timer;

        removeActiveMouse();

        endEvent(target, event, timer, function () {
            // Unbind the click suppressor, waiting until after mouseup
            // has been handled.
            setTimeout(function () {
                off(target, 'click', preventDefault);
            }, 0);
        });
    }

    function removeActiveMouse() {
        off(document, mouseevents.move, activeMousemove);
        off(document, mouseevents.end, activeMouseend);
    }

    function activeTouchmove(e, data) {
        var event = data.event;
        var timer = data.timer;
        var touch = changedTouch(e, event);

        if (!touch) {
            return;
        }

        // Stop the interface from gesturing
        e.preventDefault();

        event.targetTouches = e.targetTouches;
        data.touch = touch;
        data.timeStamp = e.timeStamp;

        timer.kick();
    }

    function activeTouchend(e, data) {
        var target = data.target;
        var event = data.event;
        var timer = data.timer;
        var touch = identifiedTouch(e.changedTouches, event.identifier);

        // This isn't the touch you're looking for.
        if (!touch) {
            return;
        }

        removeActiveTouch(data);
        endEvent(target, event, timer);
    }

    function removeActiveTouch(data) {
        off(document, touchevents.move, data.activeTouchmove);
        off(document, touchevents.end, data.activeTouchend);
    }


    // Logic for triggering move and moveend events

    function updateEvent(event, touch, timeStamp) {
        var time = timeStamp - event.timeStamp;

        event.distX = touch.pageX - event.startX;
        event.distY = touch.pageY - event.startY;
        event.deltaX = touch.pageX - event.pageX;
        event.deltaY = touch.pageY - event.pageY;

        // Average the velocity of the last few events using a decay
        // curve to even out spurious jumps in values.
        event.velocityX = 0.3 * event.velocityX + 0.7 * event.deltaX / time;
        event.velocityY = 0.3 * event.velocityY + 0.7 * event.deltaY / time;
        event.pageX = touch.pageX;
        event.pageY = touch.pageY;
    }

    function endEvent(target, event, timer, fn) {
        timer.end(function () {
            trigger(target, 'moveend', event);
            return fn && fn();
        });
    }


    // Set up the DOM

    function movestart(e) {
        if (e.defaultPrevented) {
            return;
        }
        if (!e.moveEnabled) {
            return;
        }

        var event = {
            startX: e.startX,
            startY: e.startY,
            pageX: e.pageX,
            pageY: e.pageY,
            distX: e.distX,
            distY: e.distY,
            deltaX: e.deltaX,
            deltaY: e.deltaY,
            velocityX: e.velocityX,
            velocityY: e.velocityY,
            identifier: e.identifier,
            targetTouches: e.targetTouches,
            finger: e.finger
        };

        var data = {
            target: e.target,
            event: event,
            timer: new Timer(update),
            touch: undefined,
            timeStamp: e.timeStamp
        };

        function update(time) {
            updateEvent(event, data.touch, data.timeStamp);
            trigger(data.target, 'move', event);
        }

        if (e.identifier === undefined) {
            // We're dealing with a mouse event.
            // Stop clicks from propagating during a move
            on(e.target, 'click', preventDefault);
            on(document, mouseevents.move, activeMousemove, data);
            on(document, mouseevents.end, activeMouseend, data);
        } else {
            // In order to unbind correct handlers they have to be unique
            data.activeTouchmove = function (e, data) {
                activeTouchmove(e, data);
            };
            data.activeTouchend = function (e, data) {
                activeTouchend(e, data);
            };

            // We're dealing with a touch.
            on(document, touchevents.move, data.activeTouchmove, data);
            on(document, touchevents.end, data.activeTouchend, data);
        }
    }

    on(document, 'mousedown', mousedown);
    on(document, 'touchstart', touchstart);
    on(document, 'movestart', movestart);


    // jQuery special events
    //
    // jQuery event objects are copies of DOM event objects. They need
    // a little help copying the move properties across.

    if (!window.jQuery) {
        return;
    }

    var properties = ("startX startY pageX pageY distX distY deltaX deltaY velocityX velocityY").split(' ');

    function enableMove1(e) {
        e.enableMove();
    }

    function enableMove2(e) {
        e.enableMove();
    }

    function enableMove3(e) {
        e.enableMove();
    }

    function add(handleObj) {
        var handler = handleObj.handler;

        handleObj.handler = function (e) {
            // Copy move properties across from originalEvent
            var i = properties.length;
            var property;

            while (i--) {
                property = properties[i];
                e[property] = e.originalEvent[property];
            }

            handler.apply(this, arguments);
        };
    }

    jQuery.event.special.movestart = {
        setup: function () {
            // Movestart must be enabled to allow other move events
            on(this, 'movestart', enableMove1);

            // Do listen to DOM events
            return false;
        },

        teardown: function () {
            off(this, 'movestart', enableMove1);
            return false;
        },

        add: add
    };

    jQuery.event.special.move = {
        setup: function () {
            on(this, 'movestart', enableMove2);
            return false;
        },

        teardown: function () {
            off(this, 'movestart', enableMove2);
            return false;
        },

        add: add
    };

    jQuery.event.special.moveend = {
        setup: function () {
            on(this, 'movestart', enableMove3);
            return false;
        },

        teardown: function () {
            off(this, 'movestart', enableMove3);
            return false;
        },

        add: add
    };
});


(function ($) {

    $.fn.twentytwenty = function (options) {
        var options = $.extend({
            default_offset_pct: 0.5,
            orientation: 'horizontal',
            before_label: 'Before',
            after_label: 'After',
            no_overlay: false,
            move_slider_on_hover: false,
            move_with_handle_only: true,
            click_to_move: false
        }, options);

        return this.each(function () {

            var sliderPct = options.default_offset_pct;
            var container = $(this);
            var sliderOrientation = options.orientation;
            var beforeDirection = (sliderOrientation === 'vertical') ? 'down' : 'left';
            var afterDirection = (sliderOrientation === 'vertical') ? 'up' : 'right';


            container.wrap("<div class='twentytwenty-wrapper twentytwenty-" + sliderOrientation + "'></div>");
            if (!options.no_overlay) {
                container.append("<div class='twentytwenty-overlay'></div>");
            }
            var beforeImg = container.find("img:first");
            var afterImg = container.find("img:last");
            container.append("<div class='twentytwenty-handle'></div>");
            var slider = container.find(".twentytwenty-handle");
            slider.append("<span class='twentytwenty-" + beforeDirection + "-arrow'></span>");
            slider.append("<span class='twentytwenty-" + afterDirection + "-arrow'></span>");
            container.addClass("twentytwenty-container");
            beforeImg.addClass("twentytwenty-before");
            afterImg.addClass("twentytwenty-after");

            var overlay = container.find(".twentytwenty-overlay");
            overlay.append("<div class='twentytwenty-before-label' data-content='" + options.before_label + "'></div>");
            overlay.append("<div class='twentytwenty-after-label' data-content='" + options.after_label + "'></div>");

            var calcOffset = function (dimensionPct) {
                var w = beforeImg.width();
                var h = beforeImg.height();
                return {
                    w: w + "px",
                    h: h + "px",
                    cw: (dimensionPct * w) + "px",
                    ch: (dimensionPct * h) + "px"
                };
            };

            var adjustContainer = function (offset) {
                if (sliderOrientation === 'vertical') {
                    beforeImg.css("clip", "rect(0," + offset.w + "," + offset.ch + ",0)");
                    afterImg.css("clip", "rect(" + offset.ch + "," + offset.w + "," + offset.h + ",0)");
                } else {
                    beforeImg.css("clip", "rect(0," + offset.cw + "," + offset.h + ",0)");
                    afterImg.css("clip", "rect(0," + offset.w + "," + offset.h + "," + offset.cw + ")");
                }
                container.css("height", offset.h);
            };

            var adjustSlider = function (pct) {
                var offset = calcOffset(pct);
                slider.css((sliderOrientation === "vertical") ? "top" : "left", (sliderOrientation === "vertical") ? offset.ch : offset.cw);
                adjustContainer(offset);
            };

            // Return the number specified or the min/max number if it outside the range given.
            var minMaxNumber = function (num, min, max) {
                return Math.max(min, Math.min(max, num));
            };

            // Calculate the slider percentage based on the position.
            var getSliderPercentage = function (positionX, positionY) {
                var sliderPercentage = (sliderOrientation === 'vertical') ?
                    (positionY - offsetY) / imgHeight :
                    (positionX - offsetX) / imgWidth;

                return minMaxNumber(sliderPercentage, 0, 1);
            };


            $(window).on("resize.twentytwenty", function (e) {
                adjustSlider(sliderPct);
            });

            var offsetX = 0;
            var offsetY = 0;
            var imgWidth = 0;
            var imgHeight = 0;
            var onMoveStart = function (e) {
                if (((e.distX > e.distY && e.distX < -e.distY) || (e.distX < e.distY && e.distX > -e.distY)) && sliderOrientation !== 'vertical') {
                    e.preventDefault();
                } else if (((e.distX < e.distY && e.distX < -e.distY) || (e.distX > e.distY && e.distX > -e.distY)) && sliderOrientation === 'vertical') {
                    e.preventDefault();
                }
                container.addClass("active");
                offsetX = container.offset().left;
                offsetY = container.offset().top;
                imgWidth = beforeImg.width();
                imgHeight = beforeImg.height();
            };
            var onMove = function (e) {
                if (container.hasClass("active")) {
                    sliderPct = getSliderPercentage(e.pageX, e.pageY);
                    adjustSlider(sliderPct);
                }
            };
            var onMoveEnd = function () {
                container.removeClass("active");
            };

            var moveTarget = options.move_with_handle_only ? slider : container;
            moveTarget.on("movestart", onMoveStart);
            moveTarget.on("move", onMove);
            moveTarget.on("moveend", onMoveEnd);

            if (options.move_slider_on_hover) {
                container.on("mouseenter", onMoveStart);
                container.on("mousemove", onMove);
                container.on("mouseleave", onMoveEnd);
            }

            slider.on("touchmove", function (e) {
                e.preventDefault();
            });

            container.find("img").on("mousedown", function (event) {
                event.preventDefault();
            });

            if (options.click_to_move) {
                container.on('click', function (e) {
                    offsetX = container.offset().left;
                    offsetY = container.offset().top;
                    imgWidth = beforeImg.width();
                    imgHeight = beforeImg.height();

                    sliderPct = getSliderPercentage(e.pageX, e.pageY);
                    adjustSlider(sliderPct);
                });
            }

            $(window).trigger("resize.twentytwenty");
        });
    };

})(jQuery);

"function" != typeof Object.create && (Object.create = function (t) {
        function o() {}
        return o.prototype = t, new o
    }),
    function (t, o, i, s) {
        "use strict";
        var n = {
            _positionClasses: ["bottom-left", "bottom-right", "top-right", "top-left", "bottom-center", "top-center", "mid-center"],
            _defaultIcons: ["success", "error", "info", "warning"],
            init: function (o, i) {
                this.prepareOptions(o, t.toast.options), this.process()
            },
            prepareOptions: function (o, i) {
                var s = {};
                "string" == typeof o || o instanceof Array ? s.text = o : s = o, this.options = t.extend({}, i, s)
            },
            process: function () {
                this.setup(), this.addToDom(), this.position(), this.bindToast(), this.animate()
            },
            setup: function () {
                var o = "";
                if (this._toastEl = this._toastEl || t("<div></div>", {
                        class: "jq-toast-single"
                    }), o += '<span class="jq-toast-loader"></span>', this.options.allowToastClose && (o += '<span class="close-jq-toast-single">&times;</span>'), this.options.text instanceof Array) {
                    this.options.heading && (o += '<h2 class="jq-toast-heading">' + this.options.heading + "</h2>"), o += '<ul class="jq-toast-ul">';
                    for (var i = 0; i < this.options.text.length; i++) o += '<li class="jq-toast-li" id="jq-toast-item-' + i + '">' + this.options.text[i] + "</li>";
                    o += "</ul>"
                } else this.options.heading && (o += '<h2 class="jq-toast-heading">' + this.options.heading + "</h2>"), o += this.options.text;
                this._toastEl.html(o), !1 !== this.options.bgColor && this._toastEl.css("background-color", this.options.bgColor), !1 !== this.options.textColor && this._toastEl.css("color", this.options.textColor), this.options.textAlign && this._toastEl.css("text-align", this.options.textAlign), !1 !== this.options.icon && (this._toastEl.addClass("jq-has-icon"), -1 !== t.inArray(this.options.icon, this._defaultIcons) && this._toastEl.addClass("jq-icon-" + this.options.icon)), !1 !== this.options.class && this._toastEl.addClass(this.options.class)
            },
            position: function () {
                "string" == typeof this.options.position && -1 !== t.inArray(this.options.position, this._positionClasses) ? "bottom-center" === this.options.position ? this._container.css({
                    left: t(o).outerWidth() / 2 - this._container.outerWidth() / 2,
                    bottom: 20
                }) : "top-center" === this.options.position ? this._container.css({
                    left: t(o).outerWidth() / 2 - this._container.outerWidth() / 2,
                    top: 20
                }) : "mid-center" === this.options.position ? this._container.css({
                    left: t(o).outerWidth() / 2 - this._container.outerWidth() / 2,
                    top: t(o).outerHeight() / 2 - this._container.outerHeight() / 2
                }) : this._container.addClass(this.options.position) : "object" == typeof this.options.position ? this._container.css({
                    top: this.options.position.top ? this.options.position.top : "auto",
                    bottom: this.options.position.bottom ? this.options.position.bottom : "auto",
                    left: this.options.position.left ? this.options.position.left : "auto",
                    right: this.options.position.right ? this.options.position.right : "auto"
                }) : this._container.addClass("bottom-left")
            },
            bindToast: function () {
                var t = this;
                this._toastEl.on("afterShown", function () {
                    t.processLoader()
                }), this._toastEl.find(".close-jq-toast-single").on("click", function (o) {
                    o.preventDefault(), "fade" === t.options.showHideTransition ? (t._toastEl.trigger("beforeHide"), t._toastEl.fadeOut(function () {
                        t._toastEl.trigger("afterHidden")
                    })) : "slide" === t.options.showHideTransition ? (t._toastEl.trigger("beforeHide"), t._toastEl.slideUp(function () {
                        t._toastEl.trigger("afterHidden")
                    })) : (t._toastEl.trigger("beforeHide"), t._toastEl.hide(function () {
                        t._toastEl.trigger("afterHidden")
                    }))
                }), "function" == typeof this.options.beforeShow && this._toastEl.on("beforeShow", function () {
                    t.options.beforeShow(t._toastEl)
                }), "function" == typeof this.options.afterShown && this._toastEl.on("afterShown", function () {
                    t.options.afterShown(t._toastEl)
                }), "function" == typeof this.options.beforeHide && this._toastEl.on("beforeHide", function () {
                    t.options.beforeHide(t._toastEl)
                }), "function" == typeof this.options.afterHidden && this._toastEl.on("afterHidden", function () {
                    t.options.afterHidden(t._toastEl)
                }), "function" == typeof this.options.onClick && this._toastEl.on("click", function () {
                    t.options.onClick(t._toastEl)
                })
            },
            addToDom: function () {
                var o = t(".jq-toast-wrap");
                if (0 === o.length ? (o = t("<div></div>", {
                        class: "jq-toast-wrap",
                        role: "alert",
                        "aria-live": "polite"
                    }), t("body").append(o)) : this.options.stack && !isNaN(parseInt(this.options.stack, 10)) || o.empty(), o.find(".jq-toast-single:hidden").remove(), o.append(this._toastEl), this.options.stack && !isNaN(parseInt(this.options.stack), 10)) {
                    var i = o.find(".jq-toast-single").length - this.options.stack;
                    i > 0 && t(".jq-toast-wrap").find(".jq-toast-single").slice(0, i).remove()
                }
                this._container = o
            },
            canAutoHide: function () {
                return !1 !== this.options.hideAfter && !isNaN(parseInt(this.options.hideAfter, 10))
            },
            processLoader: function () {
                if (!this.canAutoHide() || !1 === this.options.loader) return !1;
                var t = this._toastEl.find(".jq-toast-loader"),
                    o = (this.options.hideAfter - 400) / 1e3 + "s",
                    i = this.options.loaderBg,
                    s = t.attr("style") || "";
                s = s.substring(0, s.indexOf("-webkit-transition")), s += "-webkit-transition: width " + o + " ease-in;                       -o-transition: width " + o + " ease-in;                       transition: width " + o + " ease-in;                       background-color: " + i + ";", t.attr("style", s).addClass("jq-toast-loaded")
            },
            animate: function () {
                t = this;
                if (this._toastEl.hide(), this._toastEl.trigger("beforeShow"), "fade" === this.options.showHideTransition.toLowerCase() ? this._toastEl.fadeIn(function () {
                        t._toastEl.trigger("afterShown")
                    }) : "slide" === this.options.showHideTransition.toLowerCase() ? this._toastEl.slideDown(function () {
                        t._toastEl.trigger("afterShown")
                    }) : this._toastEl.show(function () {
                        t._toastEl.trigger("afterShown")
                    }), this.canAutoHide()) {
                    var t = this;
                    o.setTimeout(function () {
                        "fade" === t.options.showHideTransition.toLowerCase() ? (t._toastEl.trigger("beforeHide"), t._toastEl.fadeOut(function () {
                            t._toastEl.trigger("afterHidden")
                        })) : "slide" === t.options.showHideTransition.toLowerCase() ? (t._toastEl.trigger("beforeHide"), t._toastEl.slideUp(function () {
                            t._toastEl.trigger("afterHidden")
                        })) : (t._toastEl.trigger("beforeHide"), t._toastEl.hide(function () {
                            t._toastEl.trigger("afterHidden")
                        }))
                    }, this.options.hideAfter)
                }
            },
            reset: function (o) {
                "all" === o ? t(".jq-toast-wrap").remove() : this._toastEl.remove()
            },
            update: function (t) {
                this.prepareOptions(t, this.options), this.setup(), this.bindToast()
            },
            close: function () {
                this._toastEl.find(".close-jq-toast-single").click()
            }
        };
        t.toast = function (t) {
            var o = Object.create(n);
            return o.init(t, this), {
                reset: function (t) {
                    o.reset(t)
                },
                update: function (t) {
                    o.update(t)
                },
                close: function () {
                    o.close()
                }
            }
        }, t.toast.options = {
            text: "",
            heading: "",
            showHideTransition: "fade",
            allowToastClose: !0,
            hideAfter: 3e3,
            loader: !0,
            loaderBg: "#9EC600",
            stack: 5,
            position: "bottom-left",
            bgColor: !1,
            textColor: !1,
            textAlign: "left",
            icon: !1,
            beforeShow: function () {},
            afterShown: function () {},
            beforeHide: function () {},
            afterHidden: function () {},
            onClick: function () {}
        }
    }(jQuery, window, document);
/**
 * A lightweight youtube embed. Still should feel the same to the user, just MUCH faster to initialize and paint.
 *
 * Thx to these as the inspiration
 *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html
 *   https://autoplay-youtube-player.glitch.me/
 *
 * Once built it, I also found these:
 *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (👍👍)
 *   https://github.com/Daugilas/lazyYT
 *   https://github.com/vb/lazyframe
 */
class LiteYTEmbed extends HTMLElement {
    connectedCallback() {
        this.videoId = this.getAttribute('videoid');

        let playBtnEl = this.querySelector('.lty-playbtn');
        // A label for the button takes priority over a [playlabel] attribute on the custom-element
        this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play';

        /**
         * Lo, the youtube placeholder image!  (aka the thumbnail, poster image, etc)
         *
         * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md
         *
         * TODO: Do the sddefault->hqdefault fallback
         *       - When doing this, apply referrerpolicy (https://github.com/ampproject/amphtml/pull/3940)
         * TODO: Consider using webp if supported, falling back to jpg
         */
        if (!this.style.backgroundImage) {
            this.posterUrl = `https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg`;
            // Warm the connection for the poster image
            LiteYTEmbed.addPrefetch('preload', this.posterUrl, 'image');

            this.style.backgroundImage = `url("${this.posterUrl}")`;
        }

        // Set up play button, and its visually hidden label
        if (!playBtnEl) {
            playBtnEl = document.createElement('button');
            playBtnEl.type = 'button';
            playBtnEl.classList.add('lty-playbtn');
            this.append(playBtnEl);
        }
        if (!playBtnEl.textContent) {
            const playBtnLabelEl = document.createElement('span');
            playBtnLabelEl.className = 'lyt-visually-hidden';
            playBtnLabelEl.textContent = this.playLabel;
            playBtnEl.append(playBtnLabelEl);
        }

        // On hover (or tap), warm up the TCP connections we're (likely) about to use.
        this.addEventListener('pointerover', LiteYTEmbed.warmConnections, {
            once: true
        });

        // Once the user clicks, add the real iframe and drop our play button
        // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
        //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
        this.addEventListener('click', e => this.addIframe());

    }

    // // TODO: Support the the user changing the [videoid] attribute
    // attributeChangedCallback() {
    // }

    /**
     * Add a <link rel={preload | preconnect} ...> to the head
     */
    static addPrefetch(kind, url, as) {
        const linkEl = document.createElement('link');
        linkEl.rel = kind;
        linkEl.href = url;
        if (as) {
            linkEl.as = as;
        }
        document.head.append(linkEl);
    }

    /**
     * Begin pre-connecting to warm up the iframe load
     * Since the embed's network requests load within its iframe,
     *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
     * So, the best we can do is warm up a few connections to origins that are in the critical path.
     *
     * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
     * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
     */
    static warmConnections() {
        if (LiteYTEmbed.preconnected) return;

        // The iframe document and most of its subresources come right off youtube.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.youtube-nocookie.com');
        // The botguard script is fetched off from google.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.google.com');

        // Not certain if these ad related domains are in the critical path. Could verify with domain-specific throttling.
        LiteYTEmbed.addPrefetch('preconnect', 'https://googleads.g.doubleclick.net');
        LiteYTEmbed.addPrefetch('preconnect', 'https://static.doubleclick.net');

        LiteYTEmbed.preconnected = true;
    }

    addIframe() {
        if (!this.classList.contains('lyt-activated')) {
            const params = new URLSearchParams(this.getAttribute('params') || []);
            params.append('autoplay', '1');
            //added by sb4910
            params.append('rel', '0');
            const iframeEl = document.createElement('iframe');
            iframeEl.width = 560;
            iframeEl.height = 315;
            // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
            iframeEl.title = this.playLabel;
            iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
            iframeEl.allowFullscreen = true;
            // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
            // https://stackoverflow.com/q/64959723/89484
            iframeEl.src = `https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${params.toString()}`;
            this.append(iframeEl);

            this.classList.add('lyt-activated');

            // Set focus for a11y
            this.querySelector('iframe').focus();
        }
    }
}
// Register custom element
customElements.define('lite-youtube', LiteYTEmbed);
/*!
 * @see {@link https://github.com/englishextra/iframe-lightbox}
 * modified Simple lightbox effect in pure JS
 * @see {@link https://github.com/squeral/lightbox}
 * @see {@link https://github.com/squeral/lightbox/blob/master/lightbox.js}
 * @params {Object} elem Node element
 * @params {Object} settings object
 * el.lightbox = new IframeLightbox(elem, settings)
 * passes jshint
 */

/*jslint browser: true */

/*jslint node: true */

/*jshint -W014 */
(function (root, document) {
    "use strict";

    var docElem = document.documentElement || "";
    var docBody = document.body || "";
    var containerClass = "iframe-lightbox";
    var iframeLightboxWindowIsBindedClass = "iframe-lightbox-window--is-binded";
    var iframeLightboxOpenClass = "iframe-lightbox--open";
    var iframeLightboxLinkIsBindedClass = "iframe-lightbox-link--is-binded";
    var isLoadedClass = "is-loaded";
    var isOpenedClass = "is-opened";
    var isShowingClass = "is-showing";
    var isMobile = navigator.userAgent.match(
        /(iPad)|(iPhone)|(iPod)|(Android)|(PlayBook)|(BB10)|(BlackBerry)|(Opera Mini)|(IEMobile)|(webOS)|(MeeGo)/i
    );
    var isTouch =
        isMobile !== null ||
        document.createTouch !== undefined ||
        "ontouchstart" in root ||
        "onmsgesturechange" in root ||
        navigator.msMaxTouchPoints;

    var IframeLightbox = function IframeLightbox(elem, settings) {
        var options = settings || {};
        this.trigger = elem;
        this.el = document.getElementsByClassName(containerClass)[0] || "";
        this.body = this.el ? this.el.getElementsByClassName("body")[0] : "";
        this.content = this.el ?
            this.el.getElementsByClassName("content")[0] :
            "";
        this.src = elem.dataset.src || "";
        this.href = elem.getAttribute("href") || "";
        this.dataPaddingBottom = elem.dataset.paddingBottom || "";
        this.dataScrolling = elem.dataset.scrolling || "";
        this.dataTouch = elem.dataset.touch || "";
        this.rate = options.rate || 500;
        this.scrolling = options.scrolling;
        this.touch = options.touch;
        this.onOpened = options.onOpened;
        this.onIframeLoaded = options.onIframeLoaded;
        this.onLoaded = options.onLoaded;
        this.onCreated = options.onCreated;
        this.onClosed = options.onClosed;
        this.init();
    };

    IframeLightbox.prototype.init = function () {
        var _this = this;

        if (!this.el) {
            this.create();
        }

        var debounce = function debounce(func, wait) {
            var timeout, args, context, timestamp;
            return function () {
                context = this;
                args = [].slice.call(arguments, 0);
                timestamp = new Date();

                var later = function later() {
                    var last = new Date() - timestamp;

                    if (last < wait) {
                        timeout = setTimeout(later, wait - last);
                    } else {
                        timeout = null;
                        func.apply(context, args);
                    }
                };

                if (!timeout) {
                    timeout = setTimeout(later, wait);
                }
            };
        };

        var logic = function logic() {
            _this.open();
        };

        var handleIframeLightboxLink = function handleIframeLightboxLink(e) {
            e.stopPropagation();
            e.preventDefault();
            debounce(logic, this.rate).call();
        };

        if (!this.trigger.classList.contains(iframeLightboxLinkIsBindedClass)) {
            this.trigger.classList.add(iframeLightboxLinkIsBindedClass);
            this.trigger.addEventListener("click", handleIframeLightboxLink);

            if (isTouch && (_this.touch || _this.dataTouch)) {
                this.trigger.addEventListener(
                    "touchstart",
                    handleIframeLightboxLink
                );
            }
        }
    };

    IframeLightbox.prototype.create = function () {
        var _this = this,
            backdrop = document.createElement("div");

        backdrop.classList.add("backdrop");
        this.el = document.createElement("div");
        this.el.classList.add(containerClass);
        this.el.appendChild(backdrop);
        this.content = document.createElement("div");
        this.content.classList.add("content");
        this.body = document.createElement("div");
        this.body.classList.add("body");
        this.content.appendChild(this.body);
        this.contentHolder = document.createElement("div");
        this.contentHolder.classList.add("content-holder");
        this.contentHolder.appendChild(this.content);
        this.el.appendChild(this.contentHolder);
        this.btnClose = document.createElement("button");
        this.btnClose.classList.add("btn-close");

        this.el.appendChild(this.btnClose);
        docBody.appendChild(this.el);
        backdrop.addEventListener("click", function () {
            _this.close();
        });
        this.btnClose.addEventListener("click", function () {
            _this.close();
        });

        if (!docElem.classList.contains(iframeLightboxWindowIsBindedClass)) {
            docElem.classList.add(iframeLightboxWindowIsBindedClass);
            root.addEventListener("keyup", function (ev) {
                if (27 === (ev.which || ev.keyCode)) {
                    _this.close();
                }
            });
        }

        var clearBody = function clearBody() {
            if (_this.isOpen()) {
                return;
            }

            _this.el.classList.remove(isShowingClass);

            _this.body.innerHTML = "";
        };

        this.el.addEventListener("transitionend", clearBody, false);
        this.el.addEventListener("webkitTransitionEnd", clearBody, false);
        this.el.addEventListener("mozTransitionEnd", clearBody, false);
        this.el.addEventListener("msTransitionEnd", clearBody, false);
        this.callCallback(this.onCreated, this);
    };

    IframeLightbox.prototype.loadIframe = function () {
        var _this = this;

        this.iframeId = containerClass + Date.now();
        this.iframeSrc = this.src || this.href || "";
        var html = [];
        html.push(
            '<iframe src="' +
            this.iframeSrc +
            '" name="' +
            this.iframeId +
            '" id="' +
            this.iframeId +
            '" onload="this.style.opacity=1;" style="opacity:0;border:none;" webkitallowfullscreen="true" mozallowfullscreen="true" allowfullscreen="true" height="166" frameborder="no"></iframe>'
        );
        html.push(
            '<div class="half-circle-spinner"><div class="circle circle-1"></div><div class="circle circle-2"></div></div>'
        );
        this.body.innerHTML = html.join("");

        (function (iframeId, body) {
            var iframe = document.getElementById(iframeId);

            iframe.onload = function () {
                this.style.opacity = 1;
                body.classList.add(isLoadedClass);

                if (_this.scrolling || _this.dataScrolling) {
                    iframe.removeAttribute("scrolling");
                    iframe.style.overflow = "scroll";
                } else {
                    iframe.setAttribute("scrolling", "no");
                    iframe.style.overflow = "hidden";
                }

                _this.callCallback(_this.onIframeLoaded, _this);

                _this.callCallback(_this.onLoaded, _this);
            };
        })(this.iframeId, this.body);
    };

    IframeLightbox.prototype.open = function () {
        this.loadIframe();

        if (this.dataPaddingBottom) {
            this.content.style.paddingBottom = this.dataPaddingBottom;
        } else {
            this.content.removeAttribute("style");
        }

        this.el.classList.add(isShowingClass);
        this.el.classList.add(isOpenedClass);
        docElem.classList.add(iframeLightboxOpenClass);
        docBody.classList.add(iframeLightboxOpenClass);
        this.callCallback(this.onOpened, this);
    };

    IframeLightbox.prototype.close = function () {
        this.el.classList.remove(isOpenedClass);
        this.body.classList.remove(isLoadedClass);
        docElem.classList.remove(iframeLightboxOpenClass);
        docBody.classList.remove(iframeLightboxOpenClass);
        this.callCallback(this.onClosed, this);
    };

    IframeLightbox.prototype.isOpen = function () {
        return this.el.classList.contains(isOpenedClass);
    };

    IframeLightbox.prototype.callCallback = function (func, data) {
        if (typeof func !== "function") {
            return;
        }

        var caller = func.bind(this);
        caller(data);
    };

    root.IframeLightbox = IframeLightbox;
})("undefined" !== typeof window ? window : this, document);
/*
JqTree 1.6.0

Copyright 2021 Marco Braak

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
@license

*/
var jqtree = function (e, t) {
    "use strict";

    function o(e) {
        return e && "object" == typeof e && "default" in e ? e : {
            default: e
        }
    }

    function n(e) {
        if (e && e.__esModule) return e;
        var t = Object.create(null);
        return e && Object.keys(e).forEach((function (o) {
            if ("default" !== o) {
                var n = Object.getOwnPropertyDescriptor(e, o);
                Object.defineProperty(t, o, n.get ? n : {
                    enumerable: !0,
                    get: function () {
                        return e[o]
                    }
                })
            }
        })), t.default = e, Object.freeze(t)
    }
    var r = o(t),
        i = n(t),
        s = function (e, t) {
            return (s = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function (e, t) {
                    e.__proto__ = t
                } || function (e, t) {
                    for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o])
                })(e, t)
        };

    function a(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

        function o() {
            this.constructor = e
        }
        s(e, t), e.prototype = null === t ? Object.create(t) : (o.prototype = t.prototype, new o)
    }
    var l, d = function () {
        return (d = Object.assign || function (e) {
            for (var t, o = 1, n = arguments.length; o < n; o++)
                for (var r in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return e
        }).apply(this, arguments)
    };
    ! function (e) {
        e[e.Before = 1] = "Before", e[e.After = 2] = "After", e[e.Inside = 3] = "Inside", e[e.None = 4] = "None"
    }(l || (l = {}));
    var h = {
            before: l.Before,
            after: l.After,
            inside: l.Inside,
            none: l.None
        },
        u = function (e) {
            for (var t in h)
                if (Object.prototype.hasOwnProperty.call(h, t) && h[t] === e) return t;
            return ""
        },
        p = function () {
            function e(t, o, n) {
                void 0 === t && (t = null), void 0 === o && (o = !1), void 0 === n && (n = e), this.name = "", this.isEmptyFolder = !1, this.load_on_demand = !1, this.setData(t), this.children = [], this.parent = null, o && (this.idMapping = new Map, this.tree = this, this.nodeClass = n)
            }
            return e.prototype.setData = function (e) {
                if (e)
                    if ("string" == typeof e) this.name = e;
                    else if ("object" == typeof e)
                    for (var t in e)
                        if (Object.prototype.hasOwnProperty.call(e, t)) {
                            var o = e[t];
                            "label" === t || "name" === t ? "string" == typeof o && (this.name = o) : "children" !== t && "parent" !== t && (this[t] = o)
                        }
            }, e.prototype.loadFromData = function (e) {
                this.removeChildren();
                for (var t = 0, o = e; t < o.length; t++) {
                    var n = o[t],
                        r = this.createNode(n);
                    this.addChild(r), "object" == typeof n && n.children && n.children instanceof Array && (0 === n.children.length ? r.isEmptyFolder = !0 : r.loadFromData(n.children))
                }
                return this
            }, e.prototype.addChild = function (e) {
                this.children.push(e), e.setParent(this)
            }, e.prototype.addChildAtPosition = function (e, t) {
                this.children.splice(t, 0, e), e.setParent(this)
            }, e.prototype.removeChild = function (e) {
                e.removeChildren(), this.doRemoveChild(e)
            }, e.prototype.getChildIndex = function (e) {
                return this.children.indexOf(e)
            }, e.prototype.hasChildren = function () {
                return 0 !== this.children.length
            }, e.prototype.isFolder = function () {
                return this.hasChildren() || this.load_on_demand
            }, e.prototype.iterate = function (e) {
                var t = function (o, n) {
                    if (o.children)
                        for (var r = 0, i = o.children; r < i.length; r++) {
                            var s = i[r];
                            e(s, n) && s.hasChildren() && t(s, n + 1)
                        }
                };
                t(this, 0)
            }, e.prototype.moveNode = function (e, t, o) {
                if (!e.parent || e.isParentOf(t)) return !1;
                switch (e.parent.doRemoveChild(e), o) {
                    case l.After:
                        return !!t.parent && (t.parent.addChildAtPosition(e, t.parent.getChildIndex(t) + 1), !0);
                    case l.Before:
                        return !!t.parent && (t.parent.addChildAtPosition(e, t.parent.getChildIndex(t)), !0);
                    case l.Inside:
                        return t.addChildAtPosition(e, 0), !0;
                    default:
                        return !1
                }
            }, e.prototype.getData = function (e) {
                void 0 === e && (e = !1);
                var t = function (e) {
                    return e.map((function (e) {
                        var o = {};
                        for (var n in e)
                            if (-1 === ["parent", "children", "element", "idMapping", "load_on_demand", "nodeClass", "tree", "isEmptyFolder"].indexOf(n) && Object.prototype.hasOwnProperty.call(e, n)) {
                                var r = e[n];
                                o[n] = r
                            } return e.hasChildren() && (o.children = t(e.children)), o
                    }))
                };
                return t(e ? [this] : this.children)
            }, e.prototype.getNodeByName = function (e) {
                return this.getNodeByCallback((function (t) {
                    return t.name === e
                }))
            }, e.prototype.getNodeByNameMustExist = function (e) {
                var t = this.getNodeByCallback((function (t) {
                    return t.name === e
                }));
                if (!t) throw "Node with name " + e + " not found";
                return t
            }, e.prototype.getNodeByCallback = function (e) {
                var t = null;
                return this.iterate((function (o) {
                    return !t && (!e(o) || (t = o, !1))
                })), t
            }, e.prototype.addAfter = function (e) {
                if (this.parent) {
                    var t = this.createNode(e),
                        o = this.parent.getChildIndex(this);
                    return this.parent.addChildAtPosition(t, o + 1), "object" == typeof e && e.children && e.children instanceof Array && e.children.length && t.loadFromData(e.children), t
                }
                return null
            }, e.prototype.addBefore = function (e) {
                if (this.parent) {
                    var t = this.createNode(e),
                        o = this.parent.getChildIndex(this);
                    return this.parent.addChildAtPosition(t, o), "object" == typeof e && e.children && e.children instanceof Array && e.children.length && t.loadFromData(e.children), t
                }
                return null
            }, e.prototype.addParent = function (e) {
                if (this.parent) {
                    var t = this.createNode(e);
                    this.tree && t.setParent(this.tree);
                    for (var o = this.parent, n = 0, r = o.children; n < r.length; n++) {
                        var i = r[n];
                        t.addChild(i)
                    }
                    return o.children = [], o.addChild(t), t
                }
                return null
            }, e.prototype.remove = function () {
                this.parent && (this.parent.removeChild(this), this.parent = null)
            }, e.prototype.append = function (e) {
                var t = this.createNode(e);
                return this.addChild(t), "object" == typeof e && e.children && e.children instanceof Array && e.children.length && t.loadFromData(e.children), t
            }, e.prototype.prepend = function (e) {
                var t = this.createNode(e);
                return this.addChildAtPosition(t, 0), "object" == typeof e && e.children && e.children instanceof Array && e.children.length && t.loadFromData(e.children), t
            }, e.prototype.isParentOf = function (e) {
                for (var t = e.parent; t;) {
                    if (t === this) return !0;
                    t = t.parent
                }
                return !1
            }, e.prototype.getLevel = function () {
                for (var e = 0, t = this; t.parent;) e += 1, t = t.parent;
                return e
            }, e.prototype.getNodeById = function (e) {
                return this.idMapping.get(e) || null
            }, e.prototype.addNodeToIndex = function (e) {
                null != e.id && this.idMapping.set(e.id, e)
            }, e.prototype.removeNodeFromIndex = function (e) {
                null != e.id && this.idMapping.delete(e.id)
            }, e.prototype.removeChildren = function () {
                var e = this;
                this.iterate((function (t) {
                    var o;
                    return null === (o = e.tree) || void 0 === o || o.removeNodeFromIndex(t), !0
                })), this.children = []
            }, e.prototype.getPreviousSibling = function () {
                if (this.parent) {
                    var e = this.parent.getChildIndex(this) - 1;
                    return e >= 0 ? this.parent.children[e] : null
                }
                return null
            }, e.prototype.getNextSibling = function () {
                if (this.parent) {
                    var e = this.parent.getChildIndex(this) + 1;
                    return e < this.parent.children.length ? this.parent.children[e] : null
                }
                return null
            }, e.prototype.getNodesByProperty = function (e, t) {
                return this.filter((function (o) {
                    return o[e] === t
                }))
            }, e.prototype.filter = function (e) {
                var t = [];
                return this.iterate((function (o) {
                    return e(o) && t.push(o), !0
                })), t
            }, e.prototype.getNextNode = function (e) {
                if (void 0 === e && (e = !0), e && this.hasChildren() && this.is_open) return this.children[0];
                if (this.parent) {
                    var t = this.getNextSibling();
                    return t || this.parent.getNextNode(!1)
                }
                return null
            }, e.prototype.getPreviousNode = function () {
                if (this.parent) {
                    var e = this.getPreviousSibling();
                    return e ? e.hasChildren() && e.is_open ? e.getLastChild() : e : this.getParent()
                }
                return null
            }, e.prototype.getParent = function () {
                return this.parent && this.parent.parent ? this.parent : null
            }, e.prototype.getLastChild = function () {
                if (this.hasChildren()) {
                    var e = this.children[this.children.length - 1];
                    return e.hasChildren() && e.is_open ? e.getLastChild() : e
                }
                return null
            }, e.prototype.initFromData = function (e) {
                var t, o = this,
                    n = function (e) {
                        for (var t = 0, n = e; t < n.length; t++) {
                            var r = n[t],
                                i = o.createNode();
                            i.initFromData(r), o.addChild(i)
                        }
                    };
                t = e, o.setData(t), "object" == typeof t && t.children && t.children instanceof Array && t.children.length && n(t.children)
            }, e.prototype.setParent = function (e) {
                var t;
                this.parent = e, this.tree = e.tree, null === (t = this.tree) || void 0 === t || t.addNodeToIndex(this)
            }, e.prototype.doRemoveChild = function (e) {
                var t;
                this.children.splice(this.getChildIndex(e), 1), null === (t = this.tree) || void 0 === t || t.removeNodeFromIndex(e)
            }, e.prototype.getNodeClass = function () {
                var t;
                return this.nodeClass || (null === (t = null == this ? void 0 : this.tree) || void 0 === t ? void 0 : t.nodeClass) || e
            }, e.prototype.createNode = function (e) {
                return new(this.getNodeClass())(e)
            }, e
        }(),
        c = r.default || i,
        f = function () {
            function e(e) {
                this.treeWidget = e, this.hoveredArea = null, this.hitAreas = [], this.isDragging = !1, this.currentItem = null, this.positionInfo = null
            }
            return e.prototype.mouseCapture = function (e) {
                var t = c(e.target);
                if (!this.mustCaptureElement(t)) return null;
                if (this.treeWidget.options.onIsMoveHandle && !this.treeWidget.options.onIsMoveHandle(t)) return null;
                var o = this.treeWidget._getNodeElement(t);
                return o && this.treeWidget.options.onCanMove && (this.treeWidget.options.onCanMove(o.node) || (o = null)), this.currentItem = o, null != this.currentItem
            }, e.prototype.mouseStart = function (e) {
                var t;
                if (!this.currentItem || void 0 === e.pageX || void 0 === e.pageY) return !1;
                this.refresh();
                var o = c(e.target).offset(),
                    n = o ? o.left : 0,
                    r = o ? o.top : 0,
                    i = this.currentItem.node;
                return this.dragElement = new v(i.name, e.pageX - n, e.pageY - r, this.treeWidget.element, null === (t = this.treeWidget.options.autoEscape) || void 0 === t || t), this.isDragging = !0, this.positionInfo = e, this.currentItem.$element.addClass("jqtree-moving"), !0
            }, e.prototype.mouseDrag = function (e) {
                if (!this.currentItem || !this.dragElement || void 0 === e.pageX || void 0 === e.pageY) return !1;
                this.dragElement.move(e.pageX, e.pageY), this.positionInfo = e;
                var t = this.findHoveredArea(e.pageX, e.pageY);
                return t && this.canMoveToArea(t) ? (t.node.isFolder() || this.stopOpenFolderTimer(), this.hoveredArea !== t && (this.hoveredArea = t, this.mustOpenFolderTimer(t) ? this.startOpenFolderTimer(t.node) : this.stopOpenFolderTimer(), this.updateDropHint())) : (this.removeDropHint(), this.stopOpenFolderTimer(), this.hoveredArea = t), t || this.treeWidget.options.onDragMove && this.treeWidget.options.onDragMove(this.currentItem.node, e.originalEvent), !0
            }, e.prototype.mouseStop = function (e) {
                this.moveItem(e), this.clear(), this.removeHover(), this.removeDropHint(), this.removeHitAreas();
                var t = this.currentItem;
                return this.currentItem && (this.currentItem.$element.removeClass("jqtree-moving"), this.currentItem = null), this.isDragging = !1, this.positionInfo = null, !this.hoveredArea && t && this.treeWidget.options.onDragStop && this.treeWidget.options.onDragStop(t.node, e.originalEvent), !1
            }, e.prototype.refresh = function () {
                this.removeHitAreas(), this.currentItem && (this.generateHitAreas(), this.currentItem = this.treeWidget._getNodeElementForNode(this.currentItem.node), this.isDragging && this.currentItem.$element.addClass("jqtree-moving"))
            }, e.prototype.generateHitAreas = function () {
                if (this.currentItem) {
                    var e = new g(this.treeWidget.tree, this.currentItem.node, this.getTreeDimensions().bottom);
                    this.hitAreas = e.generate()
                } else this.hitAreas = []
            }, e.prototype.mustCaptureElement = function (e) {
                return !e.is("input,select,textarea")
            }, e.prototype.canMoveToArea = function (e) {
                if (!this.treeWidget.options.onCanMoveTo) return !0;
                if (!this.currentItem) return !1;
                var t = u(e.position);
                return this.treeWidget.options.onCanMoveTo(this.currentItem.node, e.node, t)
            }, e.prototype.removeHitAreas = function () {
                this.hitAreas = []
            }, e.prototype.clear = function () {
                this.dragElement && (this.dragElement.remove(), this.dragElement = null)
            }, e.prototype.removeDropHint = function () {
                this.previousGhost && this.previousGhost.remove()
            }, e.prototype.removeHover = function () {
                this.hoveredArea = null
            }, e.prototype.findHoveredArea = function (e, t) {
                var o = this.getTreeDimensions();
                if (e < o.left || t < o.top || e > o.right || t > o.bottom) return null;
                for (var n = 0, r = this.hitAreas.length; n < r;) {
                    var i = n + r >> 1,
                        s = this.hitAreas[i];
                    if (t < s.top) r = i;
                    else {
                        if (!(t > s.bottom)) return s;
                        n = i + 1
                    }
                }
                return null
            }, e.prototype.mustOpenFolderTimer = function (e) {
                var t = e.node;
                return t.isFolder() && !t.is_open && e.position === l.Inside
            }, e.prototype.updateDropHint = function () {
                if (this.hoveredArea) {
                    this.removeDropHint();
                    var e = this.treeWidget._getNodeElementForNode(this.hoveredArea.node);
                    this.previousGhost = e.addDropHint(this.hoveredArea.position)
                }
            }, e.prototype.startOpenFolderTimer = function (e) {
                var t = this;
                this.stopOpenFolderTimer(), this.openFolderTimer = window.setTimeout((function () {
                    t.treeWidget._openNode(e, t.treeWidget.options.slide, (function () {
                        t.refresh(), t.updateDropHint()
                    }))
                }), this.treeWidget.options.openFolderDelay)
            }, e.prototype.stopOpenFolderTimer = function () {
                this.openFolderTimer && (clearTimeout(this.openFolderTimer), this.openFolderTimer = null)
            }, e.prototype.moveItem = function (e) {
                var t = this;
                if (this.currentItem && this.hoveredArea && this.hoveredArea.position !== l.None && this.canMoveToArea(this.hoveredArea)) {
                    var o = this.currentItem.node,
                        n = this.hoveredArea.node,
                        r = this.hoveredArea.position,
                        i = o.parent;
                    r === l.Inside && (this.hoveredArea.node.is_open = !0);
                    var s = function () {
                        t.treeWidget.tree.moveNode(o, n, r), t.treeWidget.element.empty(), t.treeWidget._refreshElements(null)
                    };
                    this.treeWidget._triggerEvent("tree.move", {
                        move_info: {
                            moved_node: o,
                            target_node: n,
                            position: u(r),
                            previous_parent: i,
                            do_move: s,
                            original_event: e.originalEvent
                        }
                    }).isDefaultPrevented() || s()
                }
            }, e.prototype.getTreeDimensions = function () {
                var e = this.treeWidget.element.offset();
                if (e) {
                    var t = this.treeWidget.element,
                        o = t.width() || 0,
                        n = t.height() || 0,
                        r = e.left + this.treeWidget._getScrollLeft();
                    return {
                        left: r,
                        top: e.top,
                        right: r + o,
                        bottom: e.top + n + 16
                    }
                }
                return {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                }
            }, e
        }(),
        g = function (e) {
            function t(t, o, n) {
                var r = e.call(this, t) || this;
                return r.currentNode = o, r.treeBottom = n, r
            }
            return a(t, e), t.prototype.generate = function () {
                return this.positions = [], this.lastTop = 0, this.iterate(), this.generateHitAreas(this.positions)
            }, t.prototype.generateHitAreas = function (e) {
                for (var t = -1, o = [], n = [], r = 0, i = e; r < i.length; r++) {
                    var s = i[r];
                    s.top !== t && o.length && (o.length && this.generateHitAreasForGroup(n, o, t, s.top), t = s.top, o = []), o.push(s)
                }
                return this.generateHitAreasForGroup(n, o, t, this.treeBottom), n
            }, t.prototype.handleOpenFolder = function (e, t) {
                return e !== this.currentNode && (e.children[0] !== this.currentNode && this.addPosition(e, l.Inside, this.getTop(t)), !0)
            }, t.prototype.handleClosedFolder = function (e, t, o) {
                var n = this.getTop(o);
                e === this.currentNode ? this.addPosition(e, l.None, n) : (this.addPosition(e, l.Inside, n), t !== this.currentNode && this.addPosition(e, l.After, n))
            }, t.prototype.handleFirstNode = function (e) {
                e !== this.currentNode && this.addPosition(e, l.Before, this.getTop(c(e.element)))
            }, t.prototype.handleAfterOpenFolder = function (e, t) {
                e === this.currentNode || t === this.currentNode ? this.addPosition(e, l.None, this.lastTop) : this.addPosition(e, l.After, this.lastTop)
            }, t.prototype.handleNode = function (e, t, o) {
                var n = this.getTop(o);
                e === this.currentNode ? this.addPosition(e, l.None, n) : this.addPosition(e, l.Inside, n), t === this.currentNode || e === this.currentNode ? this.addPosition(e, l.None, n) : this.addPosition(e, l.After, n)
            }, t.prototype.getTop = function (e) {
                var t = e.offset();
                return t ? t.top : 0
            }, t.prototype.addPosition = function (e, t, o) {
                var n = {
                    top: o,
                    bottom: 0,
                    node: e,
                    position: t
                };
                this.positions.push(n), this.lastTop = o
            }, t.prototype.generateHitAreasForGroup = function (e, t, o, n) {
                for (var r = Math.min(t.length, 4), i = Math.round((n - o) / r), s = o, a = 0; a < r;) {
                    var l = t[a];
                    e.push({
                        top: s,
                        bottom: s + i,
                        node: l.node,
                        position: l.position
                    }), s += i, a += 1
                }
            }, t
        }(function () {
            function e(e) {
                this.tree = e
            }
            return e.prototype.iterate = function () {
                var e = this,
                    t = !0,
                    o = function (n, r) {
                        var i = (n.is_open || !n.element) && n.hasChildren(),
                            s = null;
                        if (n.element) {
                            if (!(s = c(n.element)).is(":visible")) return;
                            t && (e.handleFirstNode(n), t = !1), n.hasChildren() ? n.is_open ? e.handleOpenFolder(n, s) || (i = !1) : e.handleClosedFolder(n, r, s) : e.handleNode(n, r, s)
                        }
                        if (i) {
                            var a = n.children.length;
                            n.children.forEach((function (e, t) {
                                o(n.children[t], t === a - 1 ? null : n.children[t + 1])
                            })), n.is_open && s && e.handleAfterOpenFolder(n, r)
                        }
                    };
                o(this.tree, null)
            }, e
        }()),
        v = function () {
            function e(e, t, o, n, r) {
                this.offsetX = t, this.offsetY = o, this.$element = c("<span>").addClass("jqtree-title jqtree-dragging"), r ? this.$element.text(e) : this.$element.html(e), this.$element.css("position", "absolute"), n.append(this.$element)
            }
            return e.prototype.move = function (e, t) {
                this.$element.offset({
                    left: e - this.offsetX,
                    top: t - this.offsetY
                })
            }, e.prototype.remove = function () {
                this.$element.remove()
            }, e
        }(),
        m = function (e) {
            return e ? "true" : "false"
        },
        y = function () {
            function e(e) {
                this.treeWidget = e, this.openedIconElement = this.createButtonElement(e.options.openedIcon || "+"), this.closedIconElement = this.createButtonElement(e.options.closedIcon || "-")
            }
            return e.prototype.render = function (e) {
                e && e.parent ? this.renderFromNode(e) : this.renderFromRoot()
            }, e.prototype.renderFromRoot = function () {
                var e = this.treeWidget.element;
                e.empty(), this.createDomElements(e[0], this.treeWidget.tree.children, !0, 1)
            }, e.prototype.renderFromNode = function (e) {
                var t = jQuery(e.element),
                    o = this.createLi(e, e.getLevel());
                this.attachNodeData(e, o), t.after(o), t.remove(), e.children && this.createDomElements(o, e.children, !1, e.getLevel() + 1)
            }, e.prototype.createDomElements = function (e, t, o, n) {
                var r = this.createUl(o);
                e.appendChild(r);
                for (var i = 0, s = t; i < s.length; i++) {
                    var a = s[i],
                        l = this.createLi(a, n);
                    r.appendChild(l), this.attachNodeData(a, l), a.hasChildren() && this.createDomElements(l, a.children, !1, n + 1)
                }
            }, e.prototype.attachNodeData = function (e, t) {
                e.element = t, jQuery(t).data("node", e)
            }, e.prototype.createUl = function (e) {
                var t, o;
                e ? (t = "jqtree-tree", o = "tree", this.treeWidget.options.rtl && (t += " jqtree-rtl")) : (t = "", o = "group"), this.treeWidget.options.dragAndDrop && (t += " jqtree-dnd");
                var n = document.createElement("ul");
                return n.className = "jqtree_common " + t, n.setAttribute("role", o), n
            }, e.prototype.createLi = function (e, t) {
                var o = Boolean(this.treeWidget.selectNodeHandler.isNodeSelected(e)),
                    n = e.isFolder() || e.isEmptyFolder && this.treeWidget.options.showEmptyFolder ? this.createFolderLi(e, t, o) : this.createNodeLi(e, t, o);
                return this.treeWidget.options.onCreateLi && this.treeWidget.options.onCreateLi(e, jQuery(n), o), n
            }, e.prototype.createFolderLi = function (e, t, o) {
                var n = this.getButtonClasses(e),
                    r = this.getFolderClasses(e, o),
                    i = e.is_open ? this.openedIconElement : this.closedIconElement,
                    s = document.createElement("li");
                s.className = "jqtree_common " + r, s.setAttribute("role", "presentation");
                var a = document.createElement("div");
                a.className = "jqtree-element jqtree_common", a.setAttribute("role", "presentation"), s.appendChild(a);
                var l = document.createElement("a");
                return l.className = n, l.appendChild(i.cloneNode(!0)), l.setAttribute("role", "presentation"), l.setAttribute("aria-hidden", "true"), this.treeWidget.options.buttonLeft && a.appendChild(l), a.appendChild(this.createTitleSpan(e.name, t, o, e.is_open, !0)), this.treeWidget.options.buttonLeft || a.appendChild(l), s
            }, e.prototype.createNodeLi = function (e, t, o) {
                var n = ["jqtree_common"];
                o && n.push("jqtree-selected");
                var r = n.join(" "),
                    i = document.createElement("li");
                i.className = r, i.setAttribute("role", "presentation");
                var s = document.createElement("div");
                return s.className = "jqtree-element jqtree_common", s.setAttribute("role", "presentation"), i.appendChild(s), s.appendChild(this.createTitleSpan(e.name, t, o, e.is_open, !1)), i
            }, e.prototype.createTitleSpan = function (e, t, o, n, r) {
                var i = document.createElement("span"),
                    s = "jqtree-title jqtree_common";
                if (r && (s += " jqtree-title-folder"), i.className = s, i.setAttribute("role", "treeitem"), i.setAttribute("aria-level", "" + t), i.setAttribute("aria-selected", m(o)), i.setAttribute("aria-expanded", m(n)), o) {
                    var a = this.treeWidget.options.tabIndex;
                    void 0 !== a && i.setAttribute("tabindex", "" + a)
                }
                return this.treeWidget.options.autoEscape ? i.textContent = e : i.innerHTML = e, i
            }, e.prototype.getButtonClasses = function (e) {
                var t = ["jqtree-toggler", "jqtree_common"];
                return e.is_open || t.push("jqtree-closed"), this.treeWidget.options.buttonLeft ? t.push("jqtree-toggler-left") : t.push("jqtree-toggler-right"), t.join(" ")
            }, e.prototype.getFolderClasses = function (e, t) {
                var o = ["jqtree-folder"];
                return e.is_open || o.push("jqtree-closed"), t && o.push("jqtree-selected"), e.is_loading && o.push("jqtree-loading"), o.join(" ")
            }, e.prototype.createButtonElement = function (e) {
                if ("string" == typeof e) {
                    var t = document.createElement("div");
                    return t.innerHTML = e, document.createTextNode(t.innerHTML)
                }
                return jQuery(e)[0]
            }, e
        }(),
        N = function () {
            function e(e) {
                this.treeWidget = e
            }
            return e.prototype.loadFromUrl = function (e, t, o) {
                var n = this;
                if (e) {
                    var r = this.getDomElement(t);
                    this.addLoadingClass(r), this.notifyLoading(!0, t, r);
                    var i = function () {
                        n.removeLoadingClass(r), n.notifyLoading(!1, t, r)
                    };
                    this.submitRequest(e, (function (e) {
                        i(), n.treeWidget.loadData(n.parseData(e), t), o && "function" == typeof o && o()
                    }), (function (e) {
                        i(), n.treeWidget.options.onLoadFailed && n.treeWidget.options.onLoadFailed(e)
                    }))
                }
            }, e.prototype.addLoadingClass = function (e) {
                e && e.addClass("jqtree-loading")
            }, e.prototype.removeLoadingClass = function (e) {
                e && e.removeClass("jqtree-loading")
            }, e.prototype.getDomElement = function (e) {
                return e ? jQuery(e.element) : this.treeWidget.element
            }, e.prototype.notifyLoading = function (e, t, o) {
                this.treeWidget.options.onLoading && this.treeWidget.options.onLoading(e, t, o), this.treeWidget._triggerEvent("tree.loading_data", {
                    isLoading: e,
                    node: t,
                    $el: o
                })
            }, e.prototype.submitRequest = function (e, t, o) {
                var n, r = d({
                    method: "GET",
                    cache: !1,
                    dataType: "json",
                    success: t,
                    error: o
                }, "string" == typeof e ? {
                    url: e
                } : e);
                r.method = (null === (n = r.method) || void 0 === n ? void 0 : n.toUpperCase()) || "GET", jQuery.ajax(r)
            }, e.prototype.parseData = function (e) {
                var t = this.treeWidget.options.dataFilter,
                    o = "string" == typeof e ? JSON.parse(e) : e;
                return t ? t(o) : o
            }, e
        }(),
        S = function () {
            function e(t) {
                var o = this;
                this.handleKeyDown = function (t) {
                    if (!o.canHandleKeyboard()) return !0;
                    var n = o.treeWidget.getSelectedNode();
                    if (!n) return !0;
                    switch (t.which) {
                        case e.DOWN:
                            return o.moveDown(n);
                        case e.UP:
                            return o.moveUp(n);
                        case e.RIGHT:
                            return o.moveRight(n);
                        case e.LEFT:
                            return o.moveLeft(n);
                        default:
                            return !0
                    }
                }, this.treeWidget = t, t.options.keyboardSupport && jQuery(document).on("keydown.jqtree", this.handleKeyDown)
            }
            return e.prototype.deinit = function () {
                jQuery(document).off("keydown.jqtree")
            }, e.prototype.moveDown = function (e) {
                return this.selectNode(e.getNextNode())
            }, e.prototype.moveUp = function (e) {
                return this.selectNode(e.getPreviousNode())
            }, e.prototype.moveRight = function (e) {
                return !e.isFolder() || (e.is_open ? this.selectNode(e.getNextNode()) : (this.treeWidget.openNode(e), !1))
            }, e.prototype.moveLeft = function (e) {
                return e.isFolder() && e.is_open ? (this.treeWidget.closeNode(e), !1) : this.selectNode(e.getParent())
            }, e.prototype.selectNode = function (e) {
                return !e || (this.treeWidget.selectNode(e), this.treeWidget.scrollHandler.isScrolledIntoView(jQuery(e.element).find(".jqtree-element")) || this.treeWidget.scrollToNode(e), !1)
            }, e.prototype.canHandleKeyboard = function () {
                return !!this.treeWidget.options.keyboardSupport && this.treeWidget.selectNodeHandler.isFocusOnTree()
            }, e.LEFT = 37, e.UP = 38, e.RIGHT = 39, e.DOWN = 40, e
        }(),
        _ = function (e, t) {
            var o = function () {
                    return "simple_widget_" + t
                },
                n = function (e, t) {
                    var o = jQuery.data(e, t);
                    return o && o instanceof D ? o : null
                },
                r = function (t, r) {
                    for (var i = o(), s = 0, a = t.get(); s < a.length; s++) {
                        var l = a[s];
                        if (!n(l, i)) {
                            var d = new e(l, r);
                            jQuery.data(l, i) || jQuery.data(l, i, d), d.init()
                        }
                    }
                    return t
                },
                i = function (e) {
                    for (var t = o(), r = 0, i = e.get(); r < i.length; r++) {
                        var s = i[r],
                            a = n(s, t);
                        a && a.destroy(), jQuery.removeData(s, t)
                    }
                },
                s = function (e, t, n) {
                    for (var r = null, i = 0, s = e.get(); i < s.length; i++) {
                        var a = s[i],
                            l = jQuery.data(a, o());
                        if (l && l instanceof D) {
                            var d = l[t];
                            d && "function" == typeof d && (r = d.apply(l, n))
                        }
                    }
                    return r
                };
            jQuery.fn[t] = function (t) {
                for (var o = [], n = 1; n < arguments.length; n++) o[n - 1] = arguments[n];
                if (!t) return r(this, null);
                if ("object" == typeof t) {
                    var a = t;
                    return r(this, a)
                }
                if ("string" == typeof t && "_" !== t[0]) {
                    var l = t;
                    return "destroy" === l ? i(this) : "get_widget_class" === l ? e : s(this, l, o)
                }
            }
        },
        D = function () {
            function e(e, t) {
                this.$el = jQuery(e);
                var o = this.constructor.defaults;
                this.options = d(d({}, o), t)
            }
            return e.register = function (e, t) {
                _(e, t)
            }, e.prototype.destroy = function () {
                this.deinit()
            }, e.prototype.init = function () {}, e.prototype.deinit = function () {}, e.defaults = {}, e
        }(),
        I = function (e) {
            return {
                pageX: e.pageX,
                pageY: e.pageY,
                target: e.target,
                originalEvent: e
            }
        },
        C = function (e, t) {
            return {
                pageX: e.pageX,
                pageY: e.pageY,
                target: e.target,
                originalEvent: t
            }
        },
        E = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.mouseDown = function (e) {
                    0 === e.button && (t.handleMouseDown(I(e)) && e.cancelable && e.preventDefault())
                }, t.mouseMove = function (e) {
                    t.handleMouseMove(e, I(e))
                }, t.mouseUp = function (e) {
                    t.handleMouseUp(I(e))
                }, t.touchStart = function (e) {
                    if (e && !(e.touches.length > 1)) {
                        var o = e.changedTouches[0];
                        t.handleMouseDown(C(o, e))
                    }
                }, t.touchMove = function (e) {
                    if (e && !(e.touches.length > 1)) {
                        var o = e.changedTouches[0];
                        t.handleMouseMove(e, C(o, e))
                    }
                }, t.touchEnd = function (e) {
                    if (e && !(e.touches.length > 1)) {
                        var o = e.changedTouches[0];
                        t.handleMouseUp(C(o, e))
                    }
                }, t
            }
            return a(t, e), t.prototype.init = function () {
                var e = this.$el.get(0);
                e.addEventListener("mousedown", this.mouseDown, {
                    passive: !1
                }), e.addEventListener("touchstart", this.touchStart, {
                    passive: !1
                }), this.isMouseStarted = !1, this.mouseDelayTimer = null, this.isMouseDelayMet = !1, this.mouseDownInfo = null
            }, t.prototype.deinit = function () {
                var e = this.$el.get(0);
                e.removeEventListener("mousedown", this.mouseDown, {
                    passive: !1
                }), e.removeEventListener("touchstart", this.touchStart, {
                    passive: !1
                }), this.removeMouseMoveEventListeners()
            }, t.prototype.handleMouseDown = function (e) {
                return this.isMouseStarted && this.handleMouseUp(e), this.mouseDownInfo = e, !!this.mouseCapture(e) && (this.handleStartMouse(), !0)
            }, t.prototype.handleStartMouse = function () {
                document.addEventListener("mousemove", this.mouseMove, {
                    passive: !1
                }), document.addEventListener("touchmove", this.touchMove, {
                    passive: !1
                }), document.addEventListener("mouseup", this.mouseUp, {
                    passive: !1
                }), document.addEventListener("touchend", this.touchEnd, {
                    passive: !1
                });
                var e = this.getMouseDelay();
                e ? this.startMouseDelayTimer(e) : this.isMouseDelayMet = !0
            }, t.prototype.startMouseDelayTimer = function (e) {
                var t = this;
                this.mouseDelayTimer && clearTimeout(this.mouseDelayTimer), this.mouseDelayTimer = window.setTimeout((function () {
                    t.mouseDownInfo && (t.isMouseDelayMet = !0)
                }), e), this.isMouseDelayMet = !1
            }, t.prototype.handleMouseMove = function (e, t) {
                if (this.isMouseStarted) return this.mouseDrag(t), void(e.cancelable && e.preventDefault());
                this.isMouseDelayMet && (this.mouseDownInfo && (this.isMouseStarted = !1 !== this.mouseStart(this.mouseDownInfo)), this.isMouseStarted ? (this.mouseDrag(t), e.cancelable && e.preventDefault()) : this.handleMouseUp(t))
            }, t.prototype.handleMouseUp = function (e) {
                this.removeMouseMoveEventListeners(), this.isMouseDelayMet = !1, this.mouseDownInfo = null, this.isMouseStarted && (this.isMouseStarted = !1, this.mouseStop(e))
            }, t.prototype.removeMouseMoveEventListeners = function () {
                document.removeEventListener("mousemove", this.mouseMove, {
                    passive: !1
                }), document.removeEventListener("touchmove", this.touchMove, {
                    passive: !1
                }), document.removeEventListener("mouseup", this.mouseUp, {
                    passive: !1
                }), document.removeEventListener("touchend", this.touchEnd, {
                    passive: !1
                })
            }, t
        }(D),
        j = function () {
            function e(e) {
                this.treeWidget = e
            }
            return e.prototype.saveState = function () {
                var e = JSON.stringify(this.getState());
                this.treeWidget.options.onSetStateFromStorage ? this.treeWidget.options.onSetStateFromStorage(e) : this.supportsLocalStorage() && localStorage.setItem(this.getKeyName(), e)
            }, e.prototype.getStateFromStorage = function () {
                var e = this.loadFromStorage();
                return e ? this.parseState(e) : null
            }, e.prototype.getState = function () {
                var e, t, o = this;
                return {
                    open_nodes: (t = [], o.treeWidget.tree.iterate((function (e) {
                        return e.is_open && e.id && e.hasChildren() && t.push(e.id), !0
                    })), t),
                    selected_node: (e = [], o.treeWidget.getSelectedNodes().forEach((function (t) {
                        null != t.id && e.push(t.id)
                    })), e)
                }
            }, e.prototype.setInitialState = function (e) {
                if (e) {
                    var t = !1;
                    return e.open_nodes && (t = this.openInitialNodes(e.open_nodes)), e.selected_node && (this.resetSelection(), this.selectInitialNodes(e.selected_node)), t
                }
                return !1
            }, e.prototype.setInitialStateOnDemand = function (e, t) {
                e ? this.doSetInitialStateOnDemand(e.open_nodes, e.selected_node, t) : t()
            }, e.prototype.getNodeIdToBeSelected = function () {
                var e = this.getStateFromStorage();
                return e && e.selected_node ? e.selected_node[0] : null
            }, e.prototype.parseState = function (e) {
                var t, o = JSON.parse(e);
                return o && o.selected_node && ("number" == typeof (t = o.selected_node) && t % 1 == 0) && (o.selected_node = [o.selected_node]), o
            }, e.prototype.loadFromStorage = function () {
                return this.treeWidget.options.onGetStateFromStorage ? this.treeWidget.options.onGetStateFromStorage() : this.supportsLocalStorage() ? localStorage.getItem(this.getKeyName()) : null
            }, e.prototype.openInitialNodes = function (e) {
                for (var t = !1, o = 0, n = e; o < n.length; o++) {
                    var r = n[o],
                        i = this.treeWidget.getNodeById(r);
                    i && (i.load_on_demand ? t = !0 : i.is_open = !0)
                }
                return t
            }, e.prototype.selectInitialNodes = function (e) {
                for (var t = 0, o = 0, n = e; o < n.length; o++) {
                    var r = n[o],
                        i = this.treeWidget.getNodeById(r);
                    i && (t += 1, this.treeWidget.selectNodeHandler.addToSelection(i))
                }
                return 0 !== t
            }, e.prototype.resetSelection = function () {
                var e = this.treeWidget.selectNodeHandler;
                e.getSelectedNodes().forEach((function (t) {
                    e.removeFromSelection(t)
                }))
            }, e.prototype.doSetInitialStateOnDemand = function (e, t, o) {
                var n = this,
                    r = 0,
                    i = e,
                    s = function () {
                        for (var e = [], s = 0, l = i; s < l.length; s++) {
                            var d = l[s],
                                h = n.treeWidget.getNodeById(d);
                            h ? h.is_loading || (h.load_on_demand ? a(h) : n.treeWidget._openNode(h, !1, null)) : e.push(d)
                        }
                        i = e, n.selectInitialNodes(t) && n.treeWidget._refreshElements(null), 0 === r && o()
                    },
                    a = function (e) {
                        r += 1, n.treeWidget._openNode(e, !1, (function () {
                            r -= 1, s()
                        }))
                    };
                s()
            }, e.prototype.getKeyName = function () {
                return "string" == typeof this.treeWidget.options.saveState ? this.treeWidget.options.saveState : "tree"
            }, e.prototype.supportsLocalStorage = function () {
                return null == this._supportsLocalStorage && (this._supportsLocalStorage = function () {
                    if (null == localStorage) return !1;
                    try {
                        var e = "_storage_test";
                        sessionStorage.setItem(e, "value"), sessionStorage.removeItem(e)
                    } catch (e) {
                        return !1
                    }
                    return !0
                }()), this._supportsLocalStorage
            }, e
        }(),
        F = function () {
            function e(e) {
                this.treeWidget = e, this.previousTop = -1, this.isInitialized = !1
            }
            return e.prototype.checkScrolling = function () {
                this.ensureInit(), this.checkVerticalScrolling(), this.checkHorizontalScrolling()
            }, e.prototype.scrollToY = function (e) {
                if (this.ensureInit(), this.$scrollParent) this.$scrollParent[0].scrollTop = e;
                else {
                    var t = this.treeWidget.$el.offset(),
                        o = t ? t.top : 0;
                    jQuery(document).scrollTop(e + o)
                }
            }, e.prototype.isScrolledIntoView = function (e) {
                var t, o, n, r;
                this.ensureInit();
                var i, s = e.height() || 0;
                this.$scrollParent ? (r = 0, o = this.$scrollParent.height() || 0, t = (n = ((i = e.offset()) ? i.top : 0) - this.scrollParentTop) + s) : (o = (r = jQuery(window).scrollTop() || 0) + (jQuery(window).height() || 0), t = (n = (i = e.offset()) ? i.top : 0) + s);
                return t <= o && n >= r
            }, e.prototype.getScrollLeft = function () {
                return this.$scrollParent && this.$scrollParent.scrollLeft() || 0
            }, e.prototype.initScrollParent = function () {
                var e = this,
                    t = function () {
                        e.scrollParentTop = 0, e.$scrollParent = null
                    };
                "fixed" === this.treeWidget.$el.css("position") && t();
                var o = function () {
                    var t = ["overflow", "overflow-y"],
                        o = function (e) {
                            for (var o = 0, n = t; o < n.length; o++) {
                                var r = n[o],
                                    i = e.css(r);
                                if ("auto" === i || "scroll" === i) return !0
                            }
                            return !1
                        };
                    if (o(e.treeWidget.$el)) return e.treeWidget.$el;
                    for (var n = 0, r = e.treeWidget.$el.parents().get(); n < r.length; n++) {
                        var i = r[n],
                            s = jQuery(i);
                        if (o(s)) return s
                    }
                    return null
                }();
                if (o && o.length && "HTML" !== o[0].tagName) {
                    this.$scrollParent = o;
                    var n = this.$scrollParent.offset();
                    this.scrollParentTop = n ? n.top : 0
                } else t();
                this.isInitialized = !0
            }, e.prototype.ensureInit = function () {
                this.isInitialized || this.initScrollParent()
            }, e.prototype.handleVerticalScrollingWithScrollParent = function (e) {
                var t = this.$scrollParent && this.$scrollParent[0];
                t && (this.scrollParentTop + t.offsetHeight - e.bottom < 20 ? (t.scrollTop += 20, this.treeWidget.refreshHitAreas(), this.previousTop = -1) : e.top - this.scrollParentTop < 20 && (t.scrollTop -= 20, this.treeWidget.refreshHitAreas(), this.previousTop = -1))
            }, e.prototype.handleVerticalScrollingWithDocument = function (e) {
                var t = jQuery(document).scrollTop() || 0;
                e.top - t < 20 ? jQuery(document).scrollTop(t - 20) : (jQuery(window).height() || 0) - (e.bottom - t) < 20 && jQuery(document).scrollTop(t + 20)
            }, e.prototype.checkVerticalScrolling = function () {
                var e = this.treeWidget.dndHandler.hoveredArea;
                e && e.top !== this.previousTop && (this.previousTop = e.top, this.$scrollParent ? this.handleVerticalScrollingWithScrollParent(e) : this.handleVerticalScrollingWithDocument(e))
            }, e.prototype.checkHorizontalScrolling = function () {
                var e = this.treeWidget.dndHandler.positionInfo;
                e && (this.$scrollParent ? this.handleHorizontalScrollingWithParent(e) : this.handleHorizontalScrollingWithDocument(e))
            }, e.prototype.handleHorizontalScrollingWithParent = function (e) {
                if (void 0 !== e.pageX && void 0 !== e.pageY) {
                    var t = this.$scrollParent,
                        o = t && t.offset();
                    if (t && o) {
                        var n = t[0],
                            r = n.scrollLeft + n.clientWidth < n.scrollWidth,
                            i = n.scrollLeft > 0,
                            s = o.left + n.clientWidth,
                            a = o.left,
                            l = e.pageX > s - 20,
                            d = e.pageX < a + 20;
                        l && r ? n.scrollLeft = Math.min(n.scrollLeft + 20, n.scrollWidth) : d && i && (n.scrollLeft = Math.max(n.scrollLeft - 20, 0))
                    }
                }
            }, e.prototype.handleHorizontalScrollingWithDocument = function (e) {
                if (void 0 !== e.pageX && void 0 !== e.pageY) {
                    var t = jQuery(document),
                        o = t.scrollLeft() || 0,
                        n = jQuery(window).width() || 0,
                        r = o > 0,
                        i = e.pageX > n - 20,
                        s = e.pageX - o < 20;
                    i ? t.scrollLeft(o + 20) : s && r && t.scrollLeft(Math.max(o - 20, 0))
                }
            }, e
        }(),
        W = function () {
            function e(e) {
                this.treeWidget = e, this.selectedNodes = new Set, this.clear()
            }
            return e.prototype.getSelectedNode = function () {
                var e = this.getSelectedNodes();
                return !!e.length && e[0]
            }, e.prototype.getSelectedNodes = function () {
                var e = this;
                if (this.selectedSingleNode) return [this.selectedSingleNode];
                var t = [];
                return this.selectedNodes.forEach((function (o) {
                    var n = e.treeWidget.getNodeById(o);
                    n && t.push(n)
                })), t
            }, e.prototype.getSelectedNodesUnder = function (e) {
                if (this.selectedSingleNode) return e.isParentOf(this.selectedSingleNode) ? [this.selectedSingleNode] : [];
                var t = [];
                for (var o in this.selectedNodes)
                    if (Object.prototype.hasOwnProperty.call(this.selectedNodes, o)) {
                        var n = this.treeWidget.getNodeById(o);
                        n && e.isParentOf(n) && t.push(n)
                    } return t
            }, e.prototype.isNodeSelected = function (e) {
                return null != e.id ? this.selectedNodes.has(e.id) : !!this.selectedSingleNode && this.selectedSingleNode.element === e.element
            }, e.prototype.clear = function () {
                this.selectedNodes.clear(), this.selectedSingleNode = null
            }, e.prototype.removeFromSelection = function (e, t) {
                var o = this;
                void 0 === t && (t = !1), null == e.id ? this.selectedSingleNode && e.element === this.selectedSingleNode.element && (this.selectedSingleNode = null) : (this.selectedNodes.delete(e.id), t && e.iterate((function () {
                    return null != e.id && o.selectedNodes.delete(e.id), !0
                })))
            }, e.prototype.addToSelection = function (e) {
                null != e.id ? this.selectedNodes.add(e.id) : this.selectedSingleNode = e
            }, e.prototype.isFocusOnTree = function () {
                var e = document.activeElement;
                return Boolean(e && "SPAN" === e.tagName && this.treeWidget._containsElement(e))
            }, e
        }(),
        b = function () {
            function e(e, t) {
                this.init(e, t)
            }
            return e.prototype.init = function (e, t) {
                this.node = e, this.treeWidget = t, e.element || (e.element = this.treeWidget.element.get(0)), this.$element = jQuery(e.element)
            }, e.prototype.addDropHint = function (e) {
                return this.mustShowBorderDropHint(e) ? new w(this.$element, this.treeWidget._getScrollLeft()) : new L(this.node, this.$element, e)
            }, e.prototype.select = function (e) {
                var t, o = this.getLi();
                o.addClass("jqtree-selected"), o.attr("aria-selected", "true");
                var n = this.getSpan();
                n.attr("tabindex", null !== (t = this.treeWidget.options.tabIndex) && void 0 !== t ? t : null), e && n.trigger("focus")
            }, e.prototype.deselect = function () {
                var e = this.getLi();
                e.removeClass("jqtree-selected"), e.attr("aria-selected", "false");
                var t = this.getSpan();
                t.removeAttr("tabindex"), t.blur()
            }, e.prototype.getUl = function () {
                return this.$element.children("ul:first")
            }, e.prototype.getSpan = function () {
                return this.$element.children(".jqtree-element").find("span.jqtree-title")
            }, e.prototype.getLi = function () {
                return this.$element
            }, e.prototype.mustShowBorderDropHint = function (e) {
                return e === l.Inside
            }, e
        }(),
        T = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return a(t, e), t.prototype.open = function (e, t, o) {
                var n = this;
                if (void 0 === t && (t = !0), void 0 === o && (o = "fast"), !this.node.is_open) {
                    this.node.is_open = !0;
                    var r = this.getButton();
                    r.removeClass("jqtree-closed"), r.html("");
                    var i = r.get(0);
                    if (i) {
                        var s = this.treeWidget.renderer.openedIconElement.cloneNode(!0);
                        i.appendChild(s)
                    }
                    var a = function () {
                        n.getLi().removeClass("jqtree-closed"), n.getSpan().attr("aria-expanded", "true"), e && e(n.node), n.treeWidget._triggerEvent("tree.open", {
                            node: n.node
                        })
                    };
                    t ? this.getUl().slideDown(o, a) : (this.getUl().show(), a())
                }
            }, t.prototype.close = function (e, t) {
                var o = this;
                if (void 0 === e && (e = !0), void 0 === t && (t = "fast"), this.node.is_open) {
                    this.node.is_open = !1;
                    var n = this.getButton();
                    n.addClass("jqtree-closed"), n.html("");
                    var r = n.get(0);
                    if (r) {
                        var i = this.treeWidget.renderer.closedIconElement.cloneNode(!0);
                        r.appendChild(i)
                    }
                    var s = function () {
                        o.getLi().addClass("jqtree-closed"), o.getSpan().attr("aria-expanded", "false"), o.treeWidget._triggerEvent("tree.close", {
                            node: o.node
                        })
                    };
                    e ? this.getUl().slideUp(t, s) : (this.getUl().hide(), s())
                }
            }, t.prototype.mustShowBorderDropHint = function (e) {
                return !this.node.is_open && e === l.Inside
            }, t.prototype.getButton = function () {
                return this.$element.children(".jqtree-element").find("a.jqtree-toggler")
            }, t
        }(b),
        w = function () {
            function e(e, t) {
                var o = e.children(".jqtree-element"),
                    n = e.width() || 0,
                    r = Math.max(n + t - 4, 0),
                    i = o.outerHeight() || 0,
                    s = Math.max(i - 4, 0);
                this.$hint = jQuery('<span class="jqtree-border"></span>'), o.append(this.$hint), this.$hint.css({
                    width: r,
                    height: s
                })
            }
            return e.prototype.remove = function () {
                this.$hint.remove()
            }, e
        }(),
        L = function () {
            function e(e, t, o) {
                this.$element = t, this.node = e, this.$ghost = jQuery('<li class="jqtree_common jqtree-ghost"><span class="jqtree_common jqtree-circle"></span>\n            <span class="jqtree_common jqtree-line"></span></li>'), o === l.After ? this.moveAfter() : o === l.Before ? this.moveBefore() : o === l.Inside && (e.isFolder() && e.is_open ? this.moveInsideOpenFolder() : this.moveInside())
            }
            return e.prototype.remove = function () {
                this.$ghost.remove()
            }, e.prototype.moveAfter = function () {
                this.$element.after(this.$ghost)
            }, e.prototype.moveBefore = function () {
                this.$element.before(this.$ghost)
            }, e.prototype.moveInsideOpenFolder = function () {
                jQuery(this.node.children[0].element).before(this.$ghost)
            }, e.prototype.moveInside = function () {
                this.$element.after(this.$ghost), this.$ghost.addClass("jqtree-inside")
            }, e
        }(),
        H = r.default || i,
        A = "Node parameter is empty",
        M = "Parameter is empty: ",
        P = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.handleClick = function (e) {
                    var o = t.getClickTarget(e.target);
                    if (o)
                        if ("button" === o.type) t.toggle(o.node, t.options.slide), e.preventDefault(), e.stopPropagation();
                        else if ("label" === o.type) {
                        var n = o.node;
                        t._triggerEvent("tree.click", {
                            node: n,
                            click_event: e
                        }).isDefaultPrevented() || t.doSelectNode(n)
                    }
                }, t.handleDblclick = function (e) {
                    var o = t.getClickTarget(e.target);
                    "label" === (null == o ? void 0 : o.type) && t._triggerEvent("tree.dblclick", {
                        node: o.node,
                        click_event: e
                    })
                }, t.handleContextmenu = function (e) {
                    var o = H(e.target).closest("ul.jqtree-tree .jqtree-element");
                    if (o.length) {
                        var n = t.getNode(o);
                        if (n) return e.preventDefault(), e.stopPropagation(), t._triggerEvent("tree.contextmenu", {
                            node: n,
                            click_event: e
                        }), !1
                    }
                    return null
                }, t
            }
            return a(t, e), t.prototype.toggle = function (e, t) {
                if (void 0 === t && (t = null), !e) throw Error(A);
                var o = null != t ? t : this.options.slide;
                return e.is_open ? this.closeNode(e, o) : this.openNode(e, o), this.element
            }, t.prototype.getTree = function () {
                return this.tree
            }, t.prototype.selectNode = function (e, t) {
                return this.doSelectNode(e, t), this.element
            }, t.prototype.getSelectedNode = function () {
                return this.selectNodeHandler.getSelectedNode()
            }, t.prototype.toJson = function () {
                return JSON.stringify(this.tree.getData())
            }, t.prototype.loadData = function (e, t) {
                return this.doLoadData(e, t), this.element
            }, t.prototype.loadDataFromUrl = function (e, t, o) {
                return "string" == typeof e ? this.doLoadDataFromUrl(e, t, null != o ? o : null) : this.doLoadDataFromUrl(null, e, t), this.element
            }, t.prototype.reload = function (e) {
                return this.doLoadDataFromUrl(null, null, e), this.element
            }, t.prototype.getNodeById = function (e) {
                return this.tree.getNodeById(e)
            }, t.prototype.getNodeByName = function (e) {
                return this.tree.getNodeByName(e)
            }, t.prototype.getNodeByNameMustExist = function (e) {
                return this.tree.getNodeByNameMustExist(e)
            }, t.prototype.getNodesByProperty = function (e, t) {
                return this.tree.getNodesByProperty(e, t)
            }, t.prototype.getNodeByHtmlElement = function (e) {
                return this.getNode(H(e))
            }, t.prototype.getNodeByCallback = function (e) {
                return this.tree.getNodeByCallback(e)
            }, t.prototype.openNode = function (e, t, o) {
                var n = this;
                if (!e) throw Error(A);
                var r = function () {
                        var e, r, i;
                        return "function" == typeof t ? (r = t, i = null) : (i = t, r = o), null == i && (i = null !== (e = n.options.slide) && void 0 !== e && e), [i, r]
                    }(),
                    i = r[0],
                    s = r[1];
                return this._openNode(e, i, s), this.element
            }, t.prototype.closeNode = function (e, t) {
                if (!e) throw Error(A);
                var o = null != t ? t : this.options.slide;
                return (e.isFolder() || e.isEmptyFolder) && (new T(e, this).close(o, this.options.animationSpeed), this.saveState()), this.element
            }, t.prototype.isDragging = function () {
                return this.dndHandler.isDragging
            }, t.prototype.refreshHitAreas = function () {
                return this.dndHandler.refresh(), this.element
            }, t.prototype.addNodeAfter = function (e, t) {
                var o = t.addAfter(e);
                return o && this._refreshElements(t.parent), o
            }, t.prototype.addNodeBefore = function (e, t) {
                if (!t) throw Error(M + "existingNode");
                var o = t.addBefore(e);
                return o && this._refreshElements(t.parent), o
            }, t.prototype.addParentNode = function (e, t) {
                if (!t) throw Error(M + "existingNode");
                var o = t.addParent(e);
                return o && this._refreshElements(o.parent), o
            }, t.prototype.removeNode = function (e) {
                if (!e) throw Error(A);
                if (!e.parent) throw Error("Node has no parent");
                this.selectNodeHandler.removeFromSelection(e, !0);
                var t = e.parent;
                return e.remove(), this._refreshElements(t), this.element
            }, t.prototype.appendNode = function (e, t) {
                var o = t || this.tree,
                    n = o.append(e);
                return this._refreshElements(o), n
            }, t.prototype.prependNode = function (e, t) {
                var o = null != t ? t : this.tree,
                    n = o.prepend(e);
                return this._refreshElements(o), n
            }, t.prototype.updateNode = function (e, t) {
                if (!e) throw Error(A);
                var o = "object" == typeof t && t.id && t.id !== e.id;
                o && this.tree.removeNodeFromIndex(e), e.setData(t), o && this.tree.addNodeToIndex(e), "object" == typeof t && t.children && t.children instanceof Array && (e.removeChildren(), t.children.length && e.loadFromData(t.children));
                var n = this.selectNodeHandler.isFocusOnTree(),
                    r = this.isSelectedNodeInSubtree(e);
                return this._refreshElements(e), r && this.selectCurrentNode(n), this.element
            }, t.prototype.isSelectedNodeInSubtree = function (e) {
                var t = this.getSelectedNode();
                return !!t && (e === t || e.isParentOf(t))
            }, t.prototype.moveNode = function (e, t, o) {
                if (!e) throw Error(A);
                if (!t) throw Error(M + "targetNode");
                var n = h[o];
                return void 0 !== n && (this.tree.moveNode(e, t, n), this._refreshElements(null)), this.element
            }, t.prototype.getStateFromStorage = function () {
                return this.saveStateHandler.getStateFromStorage()
            }, t.prototype.addToSelection = function (e, t) {
                if (!e) throw Error(A);
                return this.selectNodeHandler.addToSelection(e), this._getNodeElementForNode(e).select(void 0 === t || t), this.saveState(), this.element
            }, t.prototype.getSelectedNodes = function () {
                return this.selectNodeHandler.getSelectedNodes()
            }, t.prototype.isNodeSelected = function (e) {
                if (!e) throw Error(A);
                return this.selectNodeHandler.isNodeSelected(e)
            }, t.prototype.removeFromSelection = function (e) {
                if (!e) throw Error(A);
                return this.selectNodeHandler.removeFromSelection(e), this._getNodeElementForNode(e).deselect(), this.saveState(), this.element
            }, t.prototype.scrollToNode = function (e) {
                if (!e) throw Error(A);
                var t = H(e.element).offset(),
                    o = t ? t.top : 0,
                    n = this.$el.offset(),
                    r = o - (n ? n.top : 0);
                return this.scrollHandler.scrollToY(r), this.element
            }, t.prototype.getState = function () {
                return this.saveStateHandler.getState()
            }, t.prototype.setState = function (e) {
                return this.saveStateHandler.setInitialState(e), this._refreshElements(null), this.element
            }, t.prototype.setOption = function (e, t) {
                return this.options[e] = t, this.element
            }, t.prototype.moveDown = function () {
                var e = this.getSelectedNode();
                return e && this.keyHandler.moveDown(e), this.element
            }, t.prototype.moveUp = function () {
                var e = this.getSelectedNode();
                return e && this.keyHandler.moveUp(e), this.element
            }, t.prototype.getVersion = function () {
                return "1.6.0"
            }, t.prototype._triggerEvent = function (e, t) {
                var o = H.Event(e, t);
                return this.element.trigger(o), o
            }, t.prototype._openNode = function (e, t, o) {
                var n = this;
                void 0 === t && (t = !0);
                var r = function (e, t, o) {
                    new T(e, n).open(o, t, n.options.animationSpeed)
                };
                if (e.isFolder() || e.isEmptyFolder)
                    if (e.load_on_demand) this.loadFolderOnDemand(e, t, o);
                    else {
                        for (var i = e.parent; i;) i.parent && r(i, !1, null), i = i.parent;
                        r(e, t, o), this.saveState()
                    }
            }, t.prototype._refreshElements = function (e) {
                this.renderer.render(e), this._triggerEvent("tree.refresh")
            }, t.prototype._getNodeElementForNode = function (e) {
                return e.isFolder() ? new T(e, this) : new b(e, this)
            }, t.prototype._getNodeElement = function (e) {
                var t = this.getNode(e);
                return t ? this._getNodeElementForNode(t) : null
            }, t.prototype._containsElement = function (e) {
                var t = this.getNode(H(e));
                return null != t && t.tree === this.tree
            }, t.prototype._getScrollLeft = function () {
                return this.scrollHandler.getScrollLeft()
            }, t.prototype.init = function () {
                e.prototype.init.call(this), this.element = this.$el, this.isInitialized = !1, this.options.rtl = this.getRtlOption(), null == this.options.closedIcon && (this.options.closedIcon = this.getDefaultClosedIcon()), this.renderer = new y(this), this.dataLoader = new N(this), this.saveStateHandler = new j(this), this.selectNodeHandler = new W(this), this.dndHandler = new f(this), this.scrollHandler = new F(this), this.keyHandler = new S(this), this.initData(), this.element.on("click", this.handleClick), this.element.on("dblclick", this.handleDblclick), this.options.useContextMenu && this.element.on("contextmenu", this.handleContextmenu)
            }, t.prototype.deinit = function () {
                this.element.empty(), this.element.off(), this.keyHandler.deinit(), this.tree = new p({}, !0), e.prototype.deinit.call(this)
            }, t.prototype.mouseCapture = function (e) {
                return !!this.options.dragAndDrop && this.dndHandler.mouseCapture(e)
            }, t.prototype.mouseStart = function (e) {
                return !!this.options.dragAndDrop && this.dndHandler.mouseStart(e)
            }, t.prototype.mouseDrag = function (e) {
                if (this.options.dragAndDrop) {
                    var t = this.dndHandler.mouseDrag(e);
                    return this.scrollHandler.checkScrolling(), t
                }
                return !1
            }, t.prototype.mouseStop = function (e) {
                return !!this.options.dragAndDrop && this.dndHandler.mouseStop(e)
            }, t.prototype.getMouseDelay = function () {
                var e;
                return null !== (e = this.options.startDndDelay) && void 0 !== e ? e : 0
            }, t.prototype.initData = function () {
                this.options.data ? this.doLoadData(this.options.data, null) : this.getDataUrlInfo(null) ? this.doLoadDataFromUrl(null, null, null) : this.doLoadData([], null)
            }, t.prototype.getDataUrlInfo = function (e) {
                var t, o = this,
                    n = this.options.dataUrl || this.element.data("url"),
                    r = function (t) {
                        if (null == e ? void 0 : e.id) {
                            var n = {
                                node: e.id
                            };
                            t.data = n
                        } else {
                            var r = o.getNodeIdToBeSelected();
                            if (r) {
                                n = {
                                    selected_node: r
                                };
                                t.data = n
                            }
                        }
                    };
                return "function" == typeof n ? n(e) : "string" == typeof n ? (r(t = {
                    url: n
                }), t) : n && "object" == typeof n ? (r(n), n) : null
            }, t.prototype.getNodeIdToBeSelected = function () {
                return this.options.saveState ? this.saveStateHandler.getNodeIdToBeSelected() : null
            }, t.prototype.initTree = function (e) {
                var t = this,
                    o = function () {
                        t.isInitialized || (t.isInitialized = !0, t._triggerEvent("tree.init"))
                    };
                if (this.options.nodeClass) {
                    this.tree = new this.options.nodeClass(null, !0, this.options.nodeClass), this.selectNodeHandler.clear(), this.tree.loadFromData(e);
                    var n = this.setInitialState();
                    this._refreshElements(null), n ? this.setInitialStateOnDemand(o) : o()
                }
            }, t.prototype.setInitialState = function () {
                var e = this,
                    t = function () {
                        if (e.options.saveState) {
                            var t = e.saveStateHandler.getStateFromStorage();
                            return t ? [!0, e.saveStateHandler.setInitialState(t)] : [!1, !1]
                        }
                        return [!1, !1]
                    }(),
                    o = t[0],
                    n = t[1];
                return o || (n = function () {
                    if (!1 === e.options.autoOpen) return !1;
                    var t = e.getAutoOpenMaxLevel(),
                        o = !1;
                    return e.tree.iterate((function (e, n) {
                        return e.load_on_demand ? (o = !0, !1) : !!e.hasChildren() && (e.is_open = !0, n !== t)
                    })), o
                }()), n
            }, t.prototype.setInitialStateOnDemand = function (e) {
                var t, o, n, r = this;
                (function () {
                    if (r.options.saveState) {
                        var t = r.saveStateHandler.getStateFromStorage();
                        return !!t && (r.saveStateHandler.setInitialStateOnDemand(t, e), !0)
                    }
                    return !1
                })() || (t = r.getAutoOpenMaxLevel(), o = 0, (n = function () {
                    r.tree.iterate((function (e, i) {
                        return e.load_on_demand ? (e.is_loading || function (e) {
                            o += 1, r._openNode(e, !1, (function () {
                                o -= 1, n()
                            }))
                        }(e), !1) : (r._openNode(e, !1, null), i !== t)
                    })), 0 === o && e()
                })())
            }, t.prototype.getAutoOpenMaxLevel = function () {
                return !0 === this.options.autoOpen ? -1 : "number" == typeof this.options.autoOpen ? this.options.autoOpen : "string" == typeof this.options.autoOpen ? parseInt(this.options.autoOpen, 10) : 0
            }, t.prototype.getClickTarget = function (e) {
                var t = H(e),
                    o = t.closest(".jqtree-toggler");
                if (o.length) {
                    if (n = this.getNode(o)) return {
                        type: "button",
                        node: n
                    }
                } else {
                    var n, r = t.closest(".jqtree-element");
                    if (r.length)
                        if (n = this.getNode(r)) return {
                            type: "label",
                            node: n
                        }
                }
                return null
            }, t.prototype.getNode = function (e) {
                var t = e.closest("li.jqtree_common");
                return 0 === t.length ? null : t.data("node")
            }, t.prototype.saveState = function () {
                this.options.saveState && this.saveStateHandler.saveState()
            }, t.prototype.selectCurrentNode = function (e) {
                var t = this.getSelectedNode();
                if (t) {
                    var o = this._getNodeElementForNode(t);
                    o && o.select(e)
                }
            }, t.prototype.deselectCurrentNode = function () {
                var e = this.getSelectedNode();
                e && this.removeFromSelection(e)
            }, t.prototype.getDefaultClosedIcon = function () {
                return this.options.rtl ? "&#x25c0;" : "&#x25ba;"
            }, t.prototype.getRtlOption = function () {
                if (null != this.options.rtl) return this.options.rtl;
                var e = this.element.data("rtl");
                return null !== e && !1 !== e && void 0 !== e
            }, t.prototype.doSelectNode = function (e, t) {
                var o = this,
                    n = function () {
                        o.options.saveState && o.saveStateHandler.saveState()
                    };
                if (!e) return this.deselectCurrentNode(), void n();
                var r = d(d({}, {
                    mustSetFocus: !0,
                    mustToggle: !0
                }), t || {});
                if (o.options.onCanSelectNode ? !0 === o.options.selectable && o.options.onCanSelectNode(e) : !0 === o.options.selectable) {
                    if (this.selectNodeHandler.isNodeSelected(e)) r.mustToggle && (this.deselectCurrentNode(), this._triggerEvent("tree.select", {
                        node: null,
                        previous_node: e
                    }));
                    else {
                        var i = this.getSelectedNode() || null;
                        this.deselectCurrentNode(), this.addToSelection(e, r.mustSetFocus), this._triggerEvent("tree.select", {
                            node: e,
                            deselected_node: i
                        }), (s = e.parent) && s.parent && !s.is_open && o.openNode(s, !1)
                    }
                    var s;
                    n()
                }
            }, t.prototype.doLoadData = function (e, t) {
                e && (this._triggerEvent("tree.load_data", {
                    tree_data: e
                }), t ? (this.deselectNodes(t), this.loadSubtree(e, t)) : this.initTree(e), this.isDragging() && this.dndHandler.refresh())
            }, t.prototype.deselectNodes = function (e) {
                for (var t = 0, o = this.selectNodeHandler.getSelectedNodesUnder(e); t < o.length; t++) {
                    var n = o[t];
                    this.selectNodeHandler.removeFromSelection(n)
                }
            }, t.prototype.loadSubtree = function (e, t) {
                t.loadFromData(e), t.load_on_demand = !1, t.is_loading = !1, this._refreshElements(t)
            }, t.prototype.doLoadDataFromUrl = function (e, t, o) {
                var n = e || this.getDataUrlInfo(t);
                this.dataLoader.loadFromUrl(n, t, o)
            }, t.prototype.loadFolderOnDemand = function (e, t, o) {
                var n = this;
                void 0 === t && (t = !0), e.is_loading = !0, this.doLoadDataFromUrl(null, e, (function () {
                    n._openNode(e, t, o)
                }))
            }, t.defaults = {
                animationSpeed: "fast",
                autoEscape: !0,
                autoOpen: !1,
                buttonLeft: !0,
                closedIcon: void 0,
                data: void 0,
                dataFilter: void 0,
                dataUrl: void 0,
                dragAndDrop: !1,
                keyboardSupport: !0,
                nodeClass: p,
                onCanMove: void 0,
                onCanMoveTo: void 0,
                onCanSelectNode: void 0,
                onCreateLi: void 0,
                onDragMove: void 0,
                onDragStop: void 0,
                onGetStateFromStorage: void 0,
                onIsMoveHandle: void 0,
                onLoadFailed: void 0,
                onLoading: void 0,
                onSetStateFromStorage: void 0,
                openedIcon: "&#x25bc;",
                openFolderDelay: 500,
                rtl: void 0,
                saveState: !1,
                selectable: !0,
                showEmptyFolder: !1,
                slide: !0,
                startDndDelay: 300,
                tabIndex: 0,
                useContextMenu: !0
            }, t
        }(E);
    return D.register(P, "tree"), e.JqTreeWidget = P, Object.defineProperty(e, "__esModule", {
        value: !0
    }), e
}({}, jQuery);
//# sourceMappingURL=tree.jquery.js.map

/*!
 * IE10 viewport hack for Surface/desktop Windows 8 bug
 * Copyright 2014-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

// See the Getting Started docs for more information:
// http://getbootstrap.com/getting-started/#support-ie10-width

(function () {
    'use strict';

    if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
        var msViewportStyle = document.createElement('style')
        msViewportStyle.appendChild(
            document.createTextNode(
                '@-ms-viewport{width:auto!important}'
            )
        )
        document.querySelector('head').appendChild(msViewportStyle)
    }

})();

//Domain Scope: COM
var bxConfDataTablesLangFile = "fileadmin/template/brillux.de/js/add/jquery.dataTables.us.js";
//fallback if submenue is not set
$(document).ready(function () {
    $("#navbar .navbar-nav .dropdown > a").each(function (index) {
        if (!$(this).next().is("ul")) {
            $(this).click(function () {
                document.location.href = $(this).attr("href");
            });
        }
    });
});

if (typeof cookiell == "undefined") {
    cookiell = new Array();
    cookiell["title"] = 'Cookie settings';
    cookiell["message"] = "We use cookies in order to provide the best possible user experience on our website. Our cookies include those that are necessary for the website's proper operation before and after a user's login. They also include those that allow the collection of anonymous data about visits to our website and those that enable the distribution of personalized advertisments. You can decide which cookie categories you want to accept. Be advised that not all of the website's features may be available based on your settings. For more information on this, please refer to our ";
    cookiell["link1"] = '/privacy-policy/';
    cookiell["dataprotection"] = 'privacy policy page';
    cookiell["cookieconfig"] = 'Cookie settings';
    cookiell["acceptall"] = 'Accept all';
    cookiell["cookielisthead"] = 'Select the cookies that you want to enable:';
    cookiell["necessarycookies"] = 'Required';
    cookiell["necessarycookiesdesc"] = 'These cookies are necessary for the page to function. You can set your browser so that all cookies are blocked. In that case some areas of the website may not work properly, though.';
    cookiell["acceptselected"] = 'Save selection';
    cookiell["cookieprefhead"] = 'Comfort';
    cookiell["cookieprefdesc"] = 'These cookies are meant to save page settings that you have applied when surfing websites operated by Brillux. This improves the usage comfort.';
    cookiell["cookieanalyticshead"] = 'Statistics';
    cookiell["cookieanalyticsdesc"] = 'To improve our products and our website we collect anonymous data for statistics and analytics. These cookies help us gather information, e.g. about the number of visitors on specific pages, in order to improve and optimize our content. We use Google Analytics for this purpose.';
    cookiell["cookietargetinghead"] = 'Marketing';
    cookiell["cookietargetingdesc"] = 'Marketing cookies are being used by publishers in order to deliver advertisements that reflect your interests. Via third party cookies, These publishers collect and anonymously process your usage behavior on websites operated by Brillux, as well as those not operated by Brillux. As a user, you benefit by receiving suitable ads, and less random advertising is displayed. All usage data collected is stored using a pseudonym. No personal identification takes place. The IP address which is transmitted by your computer for technical reasons is not stored as part of this process and is not used for the controlled insertion of advertising. On our website we use cookies by Google, LinkedIn, Twitter, Pinterest, Facebook and NE.R.O. Tracking.';
}

//global ui config vars
if (typeof bxpageconf == "undefined") {
    bxpageconf = new Array();
    bxpageconf["showfavlinks"] = false;
}
//global ui text vars
if (typeof bxpageconfll == "undefined") {
    bxpageconfll = new Array();
    bxpageconfll["addtofavorites"] = "Add favorite";
    bxpageconfll["favoritesloginhint"] = "The favorites function from Brillux allows you to save webpages, color shades and products. Please login to use the function.";
    bxpageconfll["pleaselogin"] = "Please login";
    bxpageconfll["addfavsuccess"] = "Added favorite.";
    bxpageconfll["addfaverror"] = "Favorite could not be added.";
    bxpageconfll["removefavsuccess"] = "Deleted favorite.";
    bxpageconfll["removefaverror"] = "Favorite could not be deleted.";
    bxpageconfll["favoritesroot"] = "My favorites";
    bxpageconfll["favoriteslink"] = "/my-brillux/my-favorites/";

    bxpageconfll["fav_tree_newfolder"] = "Add folder"; // MODAL BUTTON 
    bxpageconfll["buttonfavcreate"] = "Next"; // MODAL BUTTON 
    bxpageconfll["labelfavcreate"] = "Name of the favorite"; // POPUP LABEL
}
var $buoop = {
    vs: {
        i: 9,
        f: 20,
        o: 12.1,
        s: 7,
        c: 38
    },
    test: false,
    reminder: 480, // atfer how many hours should the message reappear
    reminderClosed: 960,
    newwindow: false, // open link in new window/tab
    url: "https://" + window.location.host + "/browserupdate"
}; // the url to go to after clicking the notification 

function $buo_f() {
    try {
        var e = document.createElement("script");
        e.src = "https://" + window.location.host + "/fileadmin/template/brillux.de/js/update.min.js";
        document.body.appendChild(e);
    } catch (e) {
        if (console) {
            console.log("browserupdate check failed.");
        }
    }
};
try {
    document.addEventListener("DOMContentLoaded", $buo_f, false)
} catch (e) {
    window.attachEvent("onload", $buo_f)
}! function (e) {
    "use strict";
    var t = {
        i18n: {
            ru: {
                months: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
                dayOfWeek: ["Вск", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"]
            },
            en: {
                months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                dayOfWeek: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
            },
            de: {
                months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
                dayOfWeek: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]
            },
            nl: {
                months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
                dayOfWeek: ["zo", "ma", "di", "wo", "do", "vr", "za"]
            },
            tr: {
                months: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"],
                dayOfWeek: ["Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"]
            },
            fr: {
                months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
                dayOfWeek: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"]
            },
            es: {
                months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
                dayOfWeek: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"]
            },
            th: {
                months: ["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม"],
                dayOfWeek: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."]
            },
            pl: {
                months: ["styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"],
                dayOfWeek: ["nd", "pn", "wt", "śr", "cz", "pt", "sb"]
            },
            pt: {
                months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
                dayOfWeek: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"]
            },
            ch: {
                months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
                dayOfWeek: ["日", "一", "二", "三", "四", "五", "六"]
            },
            se: {
                months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
                dayOfWeek: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"]
            },
            kr: {
                months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
                dayOfWeek: ["일", "월", "화", "수", "목", "금", "토"]
            },
            it: {
                months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
                dayOfWeek: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"]
            },
            da: {
                months: ["January", "Februar", "Marts", "April", "Maj", "Juni", "July", "August", "September", "Oktober", "November", "December"],
                dayOfWeek: ["Søn", "Man", "Tir", "ons", "Tor", "Fre", "lør"]
            },
            ja: {
                months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
                dayOfWeek: ["日", "月", "火", "水", "木", "金", "土"]
            },
            vi: {
                months: ["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"],
                dayOfWeek: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"]
            }
        },
        value: "",
        lang: "en",
        format: "Y/m/d H:i",
        formatTime: "H:i",
        formatDate: "Y/m/d",
        startDate: !1,
        step: 60,
        closeOnDateSelect: !1,
        closeOnWithoutClick: !0,
        timepicker: !0,
        datepicker: !0,
        minDate: !1,
        maxDate: !1,
        minTime: !1,
        maxTime: !1,
        allowTimes: [],
        opened: !1,
        initTime: !0,
        inline: !1,
        onSelectDate: function () {},
        onSelectTime: function () {},
        onChangeMonth: function () {},
        onChangeDateTime: function () {},
        onShow: function () {},
        onClose: function () {},
        onGenerate: function () {},
        withoutCopyright: !0,
        inverseButton: !1,
        hours12: !1,
        next: "xdsoft_next",
        prev: "xdsoft_prev",
        dayOfWeekStart: 0,
        timeHeightInTimePicker: 25,
        timepickerScrollbar: !0,
        todayButton: !0,
        defaultSelect: !0,
        scrollMonth: !0,
        scrollTime: !0,
        scrollInput: !0,
        lazyInit: !1,
        mask: !1,
        validateOnBlur: !0,
        allowBlank: !0,
        yearStart: 1950,
        yearEnd: 2050,
        style: "",
        id: "",
        roundTime: "round",
        className: "",
        weekends: [],
        yearOffset: 0
    };
    Array.prototype.indexOf || (Array.prototype.indexOf = function (e, t) {
        for (var n = t || 0, a = this.length; n < a; n++)
            if (this[n] === e) return n;
        return -1
    }), e.fn.xdsoftScroller = function (t) {
        return this.each(function () {
            var n = e(this);
            if (!e(this).hasClass("xdsoft_scroller_box")) {
                var a = function (e) {
                        var t = {
                            x: 0,
                            y: 0
                        };
                        if ("touchstart" == e.type || "touchmove" == e.type || "touchend" == e.type || "touchcancel" == e.type) {
                            var n = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                            t.x = n.pageX, t.y = n.pageY
                        } else "mousedown" != e.type && "mouseup" != e.type && "mousemove" != e.type && "mouseover" != e.type && "mouseout" != e.type && "mouseenter" != e.type && "mouseleave" != e.type || (t.x = e.pageX, t.y = e.pageY);
                        return t
                    },
                    r = 0,
                    o = n.children().eq(0),
                    s = n[0].clientHeight,
                    i = o[0].offsetHeight,
                    d = e('<div class="xdsoft_scrollbar"></div>'),
                    u = e('<div class="xdsoft_scroller"></div>'),
                    c = 100,
                    l = !1;
                d.append(u), n.addClass("xdsoft_scroller_box").append(d), u.on("mousedown.xdsoft_scroller", function (a) {
                    s || n.trigger("resize_scroll.xdsoft_scroller", [t]);
                    var o = a.pageY,
                        i = parseInt(u.css("margin-top")),
                        l = d[0].offsetHeight;
                    e(document.body).addClass("xdsoft_noselect"), e([document.body, window]).on("mouseup.xdsoft_scroller", function f() {
                        e([document.body, window]).off("mouseup.xdsoft_scroller", f).off("mousemove.xdsoft_scroller", r).removeClass("xdsoft_noselect")
                    }), e(document.body).on("mousemove.xdsoft_scroller", r = function (e) {
                        var t = e.pageY - o + i;
                        t < 0 && (t = 0), t + u[0].offsetHeight > l && (t = l - u[0].offsetHeight), n.trigger("scroll_element.xdsoft_scroller", [c ? t / c : 0])
                    })
                }), n.on("scroll_element.xdsoft_scroller", function (e, t) {
                    s || n.trigger("resize_scroll.xdsoft_scroller", [t, !0]), t = t > 1 ? 1 : t < 0 || isNaN(t) ? 0 : t, u.css("margin-top", c * t), o.css("marginTop", -parseInt((i - s) * t))
                }).on("resize_scroll.xdsoft_scroller", function (e, t, a) {
                    s = n[0].clientHeight, i = o[0].offsetHeight;
                    var r = s / i,
                        l = r * d[0].offsetHeight;
                    r > 1 ? u.hide() : (u.show(), u.css("height", parseInt(l > 10 ? l : 10)), c = d[0].offsetHeight - u[0].offsetHeight, a !== !0 && n.trigger("scroll_element.xdsoft_scroller", [t ? t : Math.abs(parseInt(o.css("marginTop"))) / (i - s)]))
                }), n.mousewheel && n.mousewheel(function (e, t, a, r) {
                    var d = Math.abs(parseInt(o.css("marginTop")));
                    return n.trigger("scroll_element.xdsoft_scroller", [(d - 20 * t) / (i - s)]), e.stopPropagation(), !1
                }), n.on("touchstart", function (e) {
                    l = a(e)
                }), n.on("touchmove", function (e) {
                    if (l) {
                        var t = a(e),
                            r = Math.abs(parseInt(o.css("marginTop")));
                        n.trigger("scroll_element.xdsoft_scroller", [(r - (t.y - l.y)) / (i - s)]), e.stopPropagation(), e.preventDefault()
                    }
                }), n.on("touchend touchcancel", function (e) {
                    l = !1
                })
            }
            n.trigger("resize_scroll.xdsoft_scroller", [t])
        })
    }, e.fn.datetimepicker = function (n) {
        var a = 48,
            r = 57,
            o = 96,
            s = 105,
            i = 17,
            d = 46,
            u = 13,
            c = 27,
            l = 8,
            f = 37,
            m = 38,
            h = 39,
            g = 40,
            p = 9,
            x = 116,
            v = 65,
            y = 67,
            D = 86,
            T = 90,
            w = 89,
            b = !1,
            _ = e.isPlainObject(n) || !n ? e.extend(!0, {}, t, n) : e.extend({}, t),
            M = 0,
            k = function (e) {
                e.on("open.xdsoft focusin.xdsoft mousedown.xdsoft", function t(n) {
                    e.is(":disabled") || e.is(":hidden") || !e.is(":visible") || e.data("xdsoft_datetimepicker") || (clearTimeout(M), M = setTimeout(function () {
                        e.data("xdsoft_datetimepicker") || S(e), e.off("open.xdsoft focusin.xdsoft mousedown.xdsoft", t).trigger("open.xdsoft")
                    }, 100))
                })
            },
            S = function (t) {
                function n() {
                    var e = _.value ? _.value : t && t.val && t.val() ? t.val() : "";
                    return e && W.isValidDate(e = Date.parseDate(e, _.format)) ? M.data("changed", !0) : e = "", e || _.startDate === !1 || (e = W.strToDateTime(_.startDate)), e ? e : 0
                }
                var M = e("<div " + (_.id ? 'id="' + _.id + '"' : "") + " " + (_.style ? 'style="' + _.style + '"' : "") + ' class="xdsoft_datetimepicker xdsoft_noselect ' + _.className + '"></div>'),
                    k = e('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
                    S = e('<div class="xdsoft_datepicker active"></div>'),
                    O = e('<div class="xdsoft_mounthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button><div class="xdsoft_label xdsoft_month"><span></span></div><div class="xdsoft_label xdsoft_year"><span></span></div><button type="button" class="xdsoft_next"></button></div>'),
                    F = e('<div class="xdsoft_calendar"></div>'),
                    I = e('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
                    C = I.find(".xdsoft_time_box").eq(0),
                    H = e('<div class="xdsoft_time_variant"></div>'),
                    Y = e('<div class="xdsoft_scrollbar"></div>'),
                    P = (e('<div class="xdsoft_scroller"></div>'), e('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>')),
                    A = e('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>');
                O.find(".xdsoft_month span").after(P), O.find(".xdsoft_year span").after(A), O.find(".xdsoft_month,.xdsoft_year").on("mousedown.xdsoft", function (t) {
                    O.find(".xdsoft_select").hide();
                    var n = e(this).find(".xdsoft_select").eq(0),
                        a = 0,
                        r = 0;
                    W.currentTime && (a = W.currentTime[e(this).hasClass("xdsoft_month") ? "getMonth" : "getFullYear"]()), n.show();
                    for (var o = n.find("div.xdsoft_option"), s = 0; s < o.length && o.eq(s).data("value") != a; s++) r += o[0].offsetHeight;
                    return n.xdsoftScroller(r / (n.children()[0].offsetHeight - n[0].clientHeight)), t.stopPropagation(), !1
                }), O.find(".xdsoft_select").xdsoftScroller().on("mousedown.xdsoft", function (e) {
                    e.stopPropagation(), e.preventDefault()
                }).on("mousedown.xdsoft", ".xdsoft_option", function (t) {
                    W && W.currentTime && W.currentTime[e(this).parent().parent().hasClass("xdsoft_monthselect") ? "setMonth" : "setFullYear"](e(this).data("value")), e(this).parent().parent().hide(), M.trigger("xchange.xdsoft"), _.onChangeMonth && _.onChangeMonth.call && _.onChangeMonth.call(M, W.currentTime, M.data("input"))
                }), M.setOptions = function (n) {
                    if (_ = e.extend(!0, {}, _, n), n.allowTimes && e.isArray(n.allowTimes) && n.allowTimes.length && (_.allowTimes = e.extend(!0, [], n.allowTimes)), n.weekends && e.isArray(n.weekends) && n.weekends.length && (_.weekends = e.extend(!0, [], n.weekends)), !_.open && !_.opened || _.inline || t.trigger("open.xdsoft"), _.inline && (M.addClass("xdsoft_inline"), t.after(M).hide(), M.trigger("afterOpen.xdsoft")), _.inverseButton && (_.next = "xdsoft_prev", _.prev = "xdsoft_next"), _.datepicker ? S.addClass("active") : S.removeClass("active"), _.timepicker ? I.addClass("active") : I.removeClass("active"), _.value && (t && t.val && t.val(_.value), W.setCurrentTime(_.value)), isNaN(_.dayOfWeekStart) || parseInt(_.dayOfWeekStart) < 0 || parseInt(_.dayOfWeekStart) > 6 ? _.dayOfWeekStart = 0 : _.dayOfWeekStart = parseInt(_.dayOfWeekStart), _.timepickerScrollbar || Y.hide(), _.minDate && /^-(.*)$/.test(_.minDate) && (_.minDate = W.strToDateTime(_.minDate).dateFormat(_.formatDate)), _.maxDate && /^\+(.*)$/.test(_.maxDate) && (_.maxDate = W.strToDateTime(_.maxDate).dateFormat(_.formatDate)), O.find(".xdsoft_today_button").css("visibility", _.todayButton ? "visible" : "hidden"), _.mask) {
                        var k = function (e) {
                                try {
                                    if (document.selection && document.selection.createRange) {
                                        var t = document.selection.createRange();
                                        return t.getBookmark().charCodeAt(2) - 2
                                    }
                                    if (e.setSelectionRange) return e.selectionStart
                                } catch (n) {
                                    return 0
                                }
                            },
                            F = function (e, t) {
                                var e = "string" == typeof e || e instanceof String ? document.getElementById(e) : e;
                                if (!e) return !1;
                                if (e.createTextRange) {
                                    var n = e.createTextRange();
                                    return n.collapse(!0), n.moveEnd(t), n.moveStart(t), n.select(), !0
                                }
                                return !!e.setSelectionRange && (e.setSelectionRange(t, t), !0)
                            },
                            C = function (e, t) {
                                var n = e.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, "\\$1").replace(/_/g, "{digit+}").replace(/([0-9]{1})/g, "{digit$1}").replace(/\{digit([0-9]{1})\}/g, "[0-$1_]{1}").replace(/\{digit[\+]\}/g, "[0-9_]{1}");
                                return RegExp(n).test(t)
                            };
                        switch (t.off("keydown.xdsoft"), !0) {
                            case _.mask === !0:
                                _.mask = _.format.replace(/Y/g, "9999").replace(/F/g, "9999").replace(/m/g, "19").replace(/d/g, "39").replace(/H/g, "29").replace(/i/g, "59").replace(/s/g, "59");
                            case "string" == e.type(_.mask):
                                C(_.mask, t.val()) || t.val(_.mask.replace(/[0-9]/g, "_")), t.on("keydown.xdsoft", function (n) {
                                    var M = this.value,
                                        S = n.which;
                                    switch (!0) {
                                        case S >= a && S <= r || S >= o && S <= s || S == l || S == d:
                                            var O = k(this),
                                                I = S != l && S != d ? String.fromCharCode(o <= S && S <= s ? S - a : S) : "_";
                                            for (S != l && S != d || !O || (O--, I = "_");
                                                /[^0-9_]/.test(_.mask.substr(O, 1)) && O < _.mask.length && O > 0;) O += S == l || S == d ? -1 : 1;
                                            if (M = M.substr(0, O) + I + M.substr(O + 1), "" == e.trim(M)) M = _.mask.replace(/[0-9]/g, "_");
                                            else if (O == _.mask.length) break;
                                            for (O += S == l || S == d ? 0 : 1;
                                                /[^0-9_]/.test(_.mask.substr(O, 1)) && O < _.mask.length && O > 0;) O += S == l || S == d ? -1 : 1;
                                            C(_.mask, M) ? (this.value = M, F(this, O)) : "" == e.trim(M) ? this.value = _.mask.replace(/[0-9]/g, "_") : t.trigger("error_input.xdsoft");
                                            break;
                                        case !!~[v, y, D, T, w].indexOf(S) && b:
                                        case !!~[c, m, g, f, h, x, i, p, u].indexOf(S):
                                            return !0
                                    }
                                    return n.preventDefault(), !1
                                })
                        }
                    }
                    _.validateOnBlur && t.off("blur.xdsoft").on("blur.xdsoft", function () {
                        _.allowBlank && !e.trim(e(this).val()).length ? (e(this).val(null), M.data("xdsoft_datetime").empty()) : Date.parseDate(e(this).val(), _.format) ? M.data("xdsoft_datetime").setCurrentTime(e(this).val()) : (e(this).val(W.now().dateFormat(_.format)), M.data("xdsoft_datetime").setCurrentTime(e(this).val())), M.trigger("changedatetime.xdsoft")
                    }), _.dayOfWeekStartPrev = 0 == _.dayOfWeekStart ? 6 : _.dayOfWeekStart - 1, M.trigger("xchange.xdsoft")
                }, M.data("options", _).on("mousedown.xdsoft", function (e) {
                    return e.stopPropagation(), e.preventDefault(), A.hide(), P.hide(), !1
                });
                var N = I.find(".xdsoft_time_box");
                N.append(H), N.xdsoftScroller(), M.on("afterOpen.xdsoft", function () {
                    N.xdsoftScroller()
                }), M.append(S).append(I), _.withoutCopyright !== !0 && M.append(k), S.append(O).append(F), e("body").append(M);
                var W = new function () {
                    var e = this;
                    e.now = function () {
                        var e = new Date;
                        return _.yearOffset && e.setFullYear(e.getFullYear() + _.yearOffset), e
                    }, e.currentTime = this.now(), e.isValidDate = function (e) {
                        return "[object Date]" === Object.prototype.toString.call(e) && !isNaN(e.getTime())
                    }, e.setCurrentTime = function (t) {
                        e.currentTime = "string" == typeof t ? e.strToDateTime(t) : e.isValidDate(t) ? t : e.now(), M.trigger("xchange.xdsoft")
                    }, e.empty = function () {
                        e.currentTime = null
                    }, e.getCurrentTime = function (t) {
                        return e.currentTime
                    }, e.nextMonth = function () {
                        var t = e.currentTime.getMonth() + 1;
                        return 12 == t && (e.currentTime.setFullYear(e.currentTime.getFullYear() + 1), t = 0), e.currentTime.setDate(Math.min(Date.daysInMonth[t], e.currentTime.getDate())), e.currentTime.setMonth(t), _.onChangeMonth && _.onChangeMonth.call && _.onChangeMonth.call(M, W.currentTime, M.data("input")), M.trigger("xchange.xdsoft"), t
                    }, e.prevMonth = function () {
                        var t = e.currentTime.getMonth() - 1;
                        return t == -1 && (e.currentTime.setFullYear(e.currentTime.getFullYear() - 1), t = 11), e.currentTime.setDate(Math.min(Date.daysInMonth[t], e.currentTime.getDate())), e.currentTime.setMonth(t), _.onChangeMonth && _.onChangeMonth.call && _.onChangeMonth.call(M, W.currentTime, M.data("input")), M.trigger("xchange.xdsoft"), t
                    }, e.strToDateTime = function (t) {
                        var n, a, r = [];
                        return (r = /^(\+|\-)(.*)$/.exec(t)) && (r[2] = Date.parseDate(r[2], _.formatDate)) ? (n = r[2].getTime() - 1 * r[2].getTimezoneOffset() * 6e4, a = new Date(W.now().getTime() + parseInt(r[1] + "1") * n)) : a = t ? Date.parseDate(t, _.format) : e.now(), e.isValidDate(a) || (a = e.now()), a
                    }, e.strtodate = function (t) {
                        var n = t ? Date.parseDate(t, _.formatDate) : e.now();
                        return e.isValidDate(n) || (n = e.now()), n
                    }, e.strtotime = function (t) {
                        var n = t ? Date.parseDate(t, _.formatTime) : e.now();
                        return e.isValidDate(n) || (n = e.now()), n
                    }, e.str = function () {
                        return e.currentTime.dateFormat(_.format)
                    }
                };
                O.find(".xdsoft_today_button").on("mousedown.xdsoft", function () {
                    M.data("changed", !0), W.setCurrentTime(0), M.trigger("afterOpen.xdsoft")
                }).on("dblclick.xdsoft", function () {
                    t.val(W.str()), M.trigger("close.xdsoft")
                }), O.find(".xdsoft_prev,.xdsoft_next").on("mousedown.xdsoft", function () {
                    var t = e(this),
                        n = 0,
                        a = !1;
                    ! function r(e) {
                        W.currentTime.getMonth();
                        t.hasClass(_.next) ? W.nextMonth() : t.hasClass(_.prev) && W.prevMonth(), !a && (n = setTimeout(r, e ? e : 100))
                    }(500), e([document.body, window]).on("mouseup.xdsoft", function o() {
                        clearTimeout(n), a = !0, e([document.body, window]).off("mouseup.xdsoft", o)
                    })
                }), I.find(".xdsoft_prev,.xdsoft_next").on("mousedown.xdsoft", function () {
                    var t = e(this),
                        n = 0,
                        a = !1,
                        r = 110;
                    ! function o(e) {
                        var s = C[0].clientHeight,
                            i = H[0].offsetHeight,
                            d = Math.abs(parseInt(H.css("marginTop")));
                        t.hasClass(_.next) && i - s - _.timeHeightInTimePicker >= d ? H.css("marginTop", "-" + (d + _.timeHeightInTimePicker) + "px") : t.hasClass(_.prev) && d - _.timeHeightInTimePicker >= 0 && H.css("marginTop", "-" + (d - _.timeHeightInTimePicker) + "px"), C.trigger("scroll_element.xdsoft_scroller", [Math.abs(parseInt(H.css("marginTop")) / (i - s))]), r = r > 10 ? 10 : r - 10, !a && (n = setTimeout(o, e ? e : r))
                    }(500), e([document.body, window]).on("mouseup.xdsoft", function s() {
                        clearTimeout(n), a = !0, e([document.body, window]).off("mouseup.xdsoft", s)
                    })
                });
                var z = 0;
                M.on("xchange.xdsoft", function (t) {
                    clearTimeout(z), z = setTimeout(function () {
                        for (var t = "", n = new Date(W.currentTime.getFullYear(), W.currentTime.getMonth(), 1, 12, 0, 0), a = 0, r = W.now(); n.getDay() != _.dayOfWeekStart;) n.setDate(n.getDate() - 1);
                        t += "<table><thead><tr>";
                        for (var o = 0; o < 7; o++) t += "<th>" + _.i18n[_.lang].dayOfWeek[o + _.dayOfWeekStart > 6 ? 0 : o + _.dayOfWeekStart] + "</th>";
                        t += "</tr></thead>", t += "<tbody><tr>";
                        var s = !1,
                            i = !1;
                        _.maxDate !== !1 && (s = W.strtodate(_.maxDate), s = new Date(s.getFullYear(), s.getMonth(), s.getDate(), 23, 59, 59, 999)), _.minDate !== !1 && (i = W.strtodate(_.minDate), i = new Date(i.getFullYear(), i.getMonth(), i.getDate()));
                        for (var d, u, c, l = []; a < W.currentTime.getDaysInMonth() || n.getDay() != _.dayOfWeekStart || W.currentTime.getMonth() == n.getMonth();) l = [], a++, d = n.getDate(), u = n.getFullYear(), c = n.getMonth(), l.push("xdsoft_date"), (s !== !1 && n > s || i !== !1 && n < i) && l.push("xdsoft_disabled"), W.currentTime.getMonth() != c && l.push("xdsoft_other_month"), (_.defaultSelect || M.data("changed")) && W.currentTime.dateFormat("d.m.Y") == n.dateFormat("d.m.Y") && l.push("xdsoft_current"), r.dateFormat("d.m.Y") == n.dateFormat("d.m.Y") && l.push("xdsoft_today"), (0 == n.getDay() || 6 == n.getDay() || ~_.weekends.indexOf(n.dateFormat("d.m.Y"))) && l.push("xdsoft_weekend"), _.beforeShowDay && "function" == typeof _.beforeShowDay && l.push(_.beforeShowDay(n)), t += '<td data-date="' + d + '" data-month="' + c + '" data-year="' + u + '" class="xdsoft_date xdsoft_day_of_week' + n.getDay() + " " + l.join(" ") + '"><div>' + d + "</div></td>", n.getDay() == _.dayOfWeekStartPrev && (t += "</tr>"), n.setDate(d + 1);
                        t += "</tbody></table>", F.html(t), O.find(".xdsoft_label span").eq(0).text(_.i18n[_.lang].months[W.currentTime.getMonth()]), O.find(".xdsoft_label span").eq(1).text(W.currentTime.getFullYear());
                        var f = "",
                            m = "",
                            c = "",
                            h = function (e, t) {
                                var n = W.now();
                                n.setHours(e), e = parseInt(n.getHours()), n.setMinutes(t), t = parseInt(n.getMinutes()), l = [], (_.maxTime !== !1 && W.strtotime(_.maxTime).getTime() < n.getTime() || _.minTime !== !1 && W.strtotime(_.minTime).getTime() > n.getTime()) && l.push("xdsoft_disabled"), (_.initTime || _.defaultSelect || M.data("changed")) && parseInt(W.currentTime.getHours()) == parseInt(e) && (_.step > 59 || Math[_.roundTime](W.currentTime.getMinutes() / _.step) * _.step == parseInt(t)) && (_.defaultSelect || M.data("changed") ? l.push("xdsoft_current") : _.initTime && l.push("xdsoft_init_time")), parseInt(r.getHours()) == parseInt(e) && parseInt(r.getMinutes()) == parseInt(t) && l.push("xdsoft_today"), f += '<div class="xdsoft_time ' + l.join(" ") + '" data-hour="' + e + '" data-minute="' + t + '">' + n.dateFormat(_.formatTime) + "</div>"
                            };
                        if (_.allowTimes && e.isArray(_.allowTimes) && _.allowTimes.length)
                            for (var a = 0; a < _.allowTimes.length; a++) m = W.strtotime(_.allowTimes[a]).getHours(), c = W.strtotime(_.allowTimes[a]).getMinutes(), h(m, c);
                        else
                            for (var a = 0, o = 0; a < (_.hours12 ? 12 : 24); a++)
                                for (o = 0; o < 60; o += _.step) m = (a < 10 ? "0" : "") + a, c = (o < 10 ? "0" : "") + o, h(m, c);
                        H.html(f);
                        var g = "",
                            a = 0;
                        for (a = parseInt(_.yearStart, 10) + _.yearOffset; a <= parseInt(_.yearEnd, 10) + _.yearOffset; a++) g += '<div class="xdsoft_option ' + (W.currentTime.getFullYear() == a ? "xdsoft_current" : "") + '" data-value="' + a + '">' + a + "</div>";
                        for (A.children().eq(0).html(g), a = 0, g = ""; a <= 11; a++) g += '<div class="xdsoft_option ' + (W.currentTime.getMonth() == a ? "xdsoft_current" : "") + '" data-value="' + a + '">' + _.i18n[_.lang].months[a] + "</div>";
                        P.children().eq(0).html(g), e(this).trigger("generate.xdsoft")
                    }, 10), t.stopPropagation()
                }).on("afterOpen.xdsoft", function () {
                    if (_.timepicker) {
                        var e;
                        if (H.find(".xdsoft_current").length ? e = ".xdsoft_current" : H.find(".xdsoft_init_time").length && (e = ".xdsoft_init_time"), e) {
                            var t = C[0].clientHeight,
                                n = H[0].offsetHeight,
                                a = H.find(e).index() * _.timeHeightInTimePicker + 1;
                            n - t < a && (a = n - t), H.css("marginTop", "-" + parseInt(a) + "px"), C.trigger("scroll_element.xdsoft_scroller", [parseInt(a) / (n - t)])
                        }
                    }
                });
                var J = 0;
                F.on("click.xdsoft", "td", function (n) {
                    n.stopPropagation(), J++;
                    var a = e(this),
                        r = W.currentTime;
                    return !a.hasClass("xdsoft_disabled") && (r.setDate(a.data("date")), r.setMonth(a.data("month")), r.setFullYear(a.data("year")), M.trigger("select.xdsoft", [r]), t.val(W.str()), (J > 1 || _.closeOnDateSelect === !0 || 0 === _.closeOnDateSelect && !_.timepicker) && !_.inline && M.trigger("close.xdsoft"), _.onSelectDate && _.onSelectDate.call && _.onSelectDate.call(M, W.currentTime, M.data("input")), M.data("changed", !0), M.trigger("xchange.xdsoft"), M.trigger("changedatetime.xdsoft"), void setTimeout(function () {
                        J = 0
                    }, 200))
                }), H.on("click.xdsoft", "div", function (t) {
                    t.stopPropagation();
                    var n = e(this),
                        a = W.currentTime;
                    return !n.hasClass("xdsoft_disabled") && (a.setHours(n.data("hour")), a.setMinutes(n.data("minute")), M.trigger("select.xdsoft", [a]), M.data("input").val(W.str()), !_.inline && M.trigger("close.xdsoft"), _.onSelectTime && _.onSelectTime.call && _.onSelectTime.call(M, W.currentTime, M.data("input")), M.data("changed", !0), M.trigger("xchange.xdsoft"), void M.trigger("changedatetime.xdsoft"))
                }), M.mousewheel && S.mousewheel(function (e, t, n, a) {
                    return !_.scrollMonth || (t < 0 ? W.nextMonth() : W.prevMonth(), !1)
                }), M.mousewheel && C.unmousewheel().mousewheel(function (e, t, n, a) {
                    if (!_.scrollTime) return !0;
                    var r = C[0].clientHeight,
                        o = H[0].offsetHeight,
                        s = Math.abs(parseInt(H.css("marginTop"))),
                        i = !0;
                    return t < 0 && o - r - _.timeHeightInTimePicker >= s ? (H.css("marginTop", "-" + (s + _.timeHeightInTimePicker) + "px"), i = !1) : t > 0 && s - _.timeHeightInTimePicker >= 0 && (H.css("marginTop", "-" + (s - _.timeHeightInTimePicker) + "px"), i = !1), C.trigger("scroll_element.xdsoft_scroller", [Math.abs(parseInt(H.css("marginTop")) / (o - r))]), e.stopPropagation(), i
                }), M.on("changedatetime.xdsoft", function () {
                    if (_.onChangeDateTime && _.onChangeDateTime.call) {
                        var e = M.data("input");
                        _.onChangeDateTime.call(M, W.currentTime, e), e.trigger("change")
                    }
                }).on("generate.xdsoft", function () {
                    _.onGenerate && _.onGenerate.call && _.onGenerate.call(M, W.currentTime, M.data("input"))
                });
                var j = 0;
                t.mousewheel && t.mousewheel(function (e, n, a, r) {
                    return !_.scrollInput || (!_.datepicker && _.timepicker ? (j = H.find(".xdsoft_current").length ? H.find(".xdsoft_current").eq(0).index() : 0, j + n >= 0 && j + n < H.children().length && (j += n), H.children().eq(j).length && H.children().eq(j).trigger("mousedown"), !1) : _.datepicker && !_.timepicker ? (S.trigger(e, [n, a, r]), t.val && t.val(W.str()), M.trigger("changedatetime.xdsoft"), !1) : void 0)
                });
                var L = function () {
                    var t = M.data("input").offset(),
                        n = t.top + M.data("input")[0].offsetHeight - 1,
                        a = t.left;
                    n + M[0].offsetHeight > e(window).height() + e(window).scrollTop() && (n = t.top - M[0].offsetHeight + 1), n < 0 && (n = 0), a + M[0].offsetWidth > e(window).width() && (a = t.left - M[0].offsetWidth + M.data("input")[0].offsetWidth), M.css({
                        left: a,
                        top: n
                    })
                };
                M.on("open.xdsoft", function () {
                    var t = !0;
                    _.onShow && _.onShow.call && (t = _.onShow.call(M, W.currentTime, M.data("input"))), t !== !1 && (M.show(), M.trigger("afterOpen.xdsoft"), L(), e(window).off("resize.xdsoft", L).on("resize.xdsoft", L), _.closeOnWithoutClick && e([document.body, window]).on("mousedown.xdsoft", function n() {
                        M.trigger("close.xdsoft"), e([document.body, window]).off("mousedown.xdsoft", n)
                    }))
                }).on("close.xdsoft", function (e) {
                    var t = !0;
                    _.onClose && _.onClose.call && (t = _.onClose.call(M, W.currentTime, M.data("input"))), t === !1 || _.opened || _.inline || M.hide(), e.stopPropagation()
                }).data("input", t);
                var E = 0;
                M.data("xdsoft_datetime", W), M.setOptions(_), W.setCurrentTime(n()), M.trigger("afterOpen.xdsoft"), t.data("xdsoft_datetimepicker", M).on("open.xdsoft focusin.xdsoft mousedown.xdsoft", function (e) {
                    t.is(":disabled") || t.is(":hidden") || !t.is(":visible") || (clearTimeout(E), E = setTimeout(function () {
                        t.is(":disabled") || t.is(":hidden") || !t.is(":visible") || (W.setCurrentTime(n()), M.trigger("open.xdsoft"))
                    }, 100))
                }).on("keydown.xdsoft", function (t) {
                    var n = (this.value, t.which);
                    switch (!0) {
                        case !!~[u].indexOf(n):
                            var a = e("input:visible,textarea:visible");
                            return M.trigger("close.xdsoft"), a.eq(a.index(this) + 1).focus(), !1;
                        case !!~[p].indexOf(n):
                            return M.trigger("close.xdsoft"), !0
                    }
                })
            },
            O = function (t) {
                var n = t.data("xdsoft_datetimepicker");
                n && (n.data("xdsoft_datetime", null), n.remove(), t.data("xdsoft_datetimepicker", null).off("open.xdsoft focusin.xdsoft focusout.xdsoft mousedown.xdsoft blur.xdsoft keydown.xdsoft"), e(window).off("resize.xdsoft"), e([window, document.body]).off("mousedown.xdsoft"), t.unmousewheel && t.unmousewheel())
            };
        return e(document).off("keydown.xdsoftctrl keyup.xdsoftctrl").on("keydown.xdsoftctrl", function (e) {
            e.keyCode == i && (b = !0)
        }).on("keyup.xdsoftctrl", function (e) {
            e.keyCode == i && (b = !1)
        }), this.each(function () {
            var t;
            if (t = e(this).data("xdsoft_datetimepicker")) {
                if ("string" === e.type(n)) switch (n) {
                    case "show":
                        e(this).select().focus(), t.trigger("open.xdsoft");
                        break;
                    case "hide":
                        t.trigger("close.xdsoft");
                        break;
                    case "destroy":
                        O(e(this));
                        break;
                    case "reset":
                        this.value = this.defaultValue, this.value && t.data("xdsoft_datetime").isValidDate(Date.parseDate(this.value, _.format)) || t.data("changed", !1), t.data("xdsoft_datetime").setCurrentTime(this.value)
                } else t.setOptions(n);
                return 0
            }
            "string" !== e.type(n) && (!_.lazyInit || _.open || _.inline ? S(e(this)) : k(e(this)))
        })
    }
}(jQuery), Date.parseFunctions = {
        count: 0
    }, Date.parseRegexes = [], Date.formatFunctions = {
        count: 0
    }, Date.prototype.dateFormat = function (e) {
        if ("unixtime" == e) return parseInt(this.getTime() / 1e3);
        null == Date.formatFunctions[e] && Date.createNewFormat(e);
        var t = Date.formatFunctions[e];
        return this[t]()
    }, Date.createNewFormat = function (format) {
        var funcName = "format" + Date.formatFunctions.count++;
        Date.formatFunctions[format] = funcName;
        for (var code = "Date.prototype." + funcName + " = function() {return ", special = !1, ch = "", i = 0; i < format.length; ++i) ch = format.charAt(i), special || "\\" != ch ? special ? (special = !1, code += "'" + String.escape(ch) + "' + ") : code += Date.getFormatCode(ch) : special = !0;
        eval(code.substring(0, code.length - 3) + ";}")
    }, Date.getFormatCode = function (e) {
        switch (e) {
            case "d":
                return "String.leftPad(this.getDate(), 2, '0') + ";
            case "D":
                return "Date.dayNames[this.getDay()].substring(0, 3) + ";
            case "j":
                return "this.getDate() + ";
            case "l":
                return "Date.dayNames[this.getDay()] + ";
            case "S":
                return "this.getSuffix() + ";
            case "w":
                return "this.getDay() + ";
            case "z":
                return "this.getDayOfYear() + ";
            case "W":
                return "this.getWeekOfYear() + ";
            case "F":
                return "Date.monthNames[this.getMonth()] + ";
            case "m":
                return "String.leftPad(this.getMonth() + 1, 2, '0') + ";
            case "M":
                return "Date.monthNames[this.getMonth()].substring(0, 3) + ";
            case "n":
                return "(this.getMonth() + 1) + ";
            case "t":
                return "this.getDaysInMonth() + ";
            case "L":
                return "(this.isLeapYear() ? 1 : 0) + ";
            case "Y":
                return "this.getFullYear() + ";
            case "y":
                return "('' + this.getFullYear()).substring(2, 4) + ";
            case "a":
                return "(this.getHours() < 12 ? 'am' : 'pm') + ";
            case "A":
                return "(this.getHours() < 12 ? 'AM' : 'PM') + ";
            case "g":
                return "((this.getHours() %12) ? this.getHours() % 12 : 12) + ";
            case "G":
                return "this.getHours() + ";
            case "h":
                return "String.leftPad((this.getHours() %12) ? this.getHours() % 12 : 12, 2, '0') + ";
            case "H":
                return "String.leftPad(this.getHours(), 2, '0') + ";
            case "i":
                return "String.leftPad(this.getMinutes(), 2, '0') + ";
            case "s":
                return "String.leftPad(this.getSeconds(), 2, '0') + ";
            case "O":
                return "this.getGMTOffset() + ";
            case "T":
                return "this.getTimezone() + ";
            case "Z":
                return "(this.getTimezoneOffset() * -60) + ";
            default:
                return "'" + String.escape(e) + "' + "
        }
    }, Date.parseDate = function (e, t) {
        if ("unixtime" == t) return new Date(isNaN(parseInt(e)) ? 0 : 1e3 * parseInt(e));
        null == Date.parseFunctions[t] && Date.createParser(t);
        var n = Date.parseFunctions[t];
        return Date[n](e)
    }, Date.createParser = function (format) {
        var funcName = "parse" + Date.parseFunctions.count++,
            regexNum = Date.parseRegexes.length,
            currentGroup = 1;
        Date.parseFunctions[format] = funcName;
        for (var code = "Date." + funcName + " = function(input) {\nvar y = -1, m = -1, d = -1, h = -1, i = -1, s = -1, z = -1;\nvar d = new Date();\ny = d.getFullYear();\nm = d.getMonth();\nd = d.getDate();\nvar results = input.match(Date.parseRegexes[" + regexNum + "]);\nif (results && results.length > 0) {", regex = "", special = !1, ch = "", i = 0; i < format.length; ++i) ch = format.charAt(i), special || "\\" != ch ? special ? (special = !1, regex += String.escape(ch)) : (obj = Date.formatCodeToRegex(ch, currentGroup), currentGroup += obj.g, regex += obj.s, obj.g && obj.c && (code += obj.c)) : special = !0;
        code += "if (y > 0 && z > 0){\nvar doyDate = new Date(y,0);\ndoyDate.setDate(z);\nm = doyDate.getMonth();\nd = doyDate.getDate();\n}", code += "if (y > 0 && m >= 0 && d > 0 && h >= 0 && i >= 0 && s >= 0)\n{return new Date(y, m, d, h, i, s);}\nelse if (y > 0 && m >= 0 && d > 0 && h >= 0 && i >= 0)\n{return new Date(y, m, d, h, i);}\nelse if (y > 0 && m >= 0 && d > 0 && h >= 0)\n{return new Date(y, m, d, h);}\nelse if (y > 0 && m >= 0 && d > 0)\n{return new Date(y, m, d);}\nelse if (y > 0 && m >= 0)\n{return new Date(y, m);}\nelse if (y > 0)\n{return new Date(y);}\n}return null;}", Date.parseRegexes[regexNum] = new RegExp("^" + regex + "$"), eval(code)
    }, Date.formatCodeToRegex = function (e, t) {
        switch (e) {
            case "D":
                return {
                    g: 0, c: null, s: "(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)"
                };
            case "j":
            case "d":
                return {
                    g: 1, c: "d = parseInt(results[" + t + "], 10);\n", s: "(\\d{1,2})"
                };
            case "l":
                return {
                    g: 0, c: null, s: "(?:" + Date.dayNames.join("|") + ")"
                };
            case "S":
                return {
                    g: 0, c: null, s: "(?:st|nd|rd|th)"
                };
            case "w":
                return {
                    g: 0, c: null, s: "\\d"
                };
            case "z":
                return {
                    g: 1, c: "z = parseInt(results[" + t + "], 10);\n", s: "(\\d{1,3})"
                };
            case "W":
                return {
                    g: 0, c: null, s: "(?:\\d{2})"
                };
            case "F":
                return {
                    g: 1, c: "m = parseInt(Date.monthNumbers[results[" + t + "].substring(0, 3)], 10);\n", s: "(" + Date.monthNames.join("|") + ")"
                };
            case "M":
                return {
                    g: 1, c: "m = parseInt(Date.monthNumbers[results[" + t + "]], 10);\n", s: "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)"
                };
            case "n":
            case "m":
                return {
                    g: 1, c: "m = parseInt(results[" + t + "], 10) - 1;\n", s: "(\\d{1,2})"
                };
            case "t":
                return {
                    g: 0, c: null, s: "\\d{1,2}"
                };
            case "L":
                return {
                    g: 0, c: null, s: "(?:1|0)"
                };
            case "Y":
                return {
                    g: 1, c: "y = parseInt(results[" + t + "], 10);\n", s: "(\\d{4})"
                };
            case "y":
                return {
                    g: 1, c: "var ty = parseInt(results[" + t + "], 10);\ny = ty > Date.y2kYear ? 1900 + ty : 2000 + ty;\n", s: "(\\d{1,2})"
                };
            case "a":
                return {
                    g: 1, c: "if (results[" + t + "] == 'am') {\nif (h == 12) { h = 0; }\n} else { if (h < 12) { h += 12; }}", s: "(am|pm)"
                };
            case "A":
                return {
                    g: 1, c: "if (results[" + t + "] == 'AM') {\nif (h == 12) { h = 0; }\n} else { if (h < 12) { h += 12; }}", s: "(AM|PM)"
                };
            case "g":
            case "G":
            case "h":
            case "H":
                return {
                    g: 1, c: "h = parseInt(results[" + t + "], 10);\n", s: "(\\d{1,2})"
                };
            case "i":
                return {
                    g: 1, c: "i = parseInt(results[" + t + "], 10);\n", s: "(\\d{2})"
                };
            case "s":
                return {
                    g: 1, c: "s = parseInt(results[" + t + "], 10);\n", s: "(\\d{2})"
                };
            case "O":
                return {
                    g: 0, c: null, s: "[+-]\\d{4}"
                };
            case "T":
                return {
                    g: 0, c: null, s: "[A-Z]{3}"
                };
            case "Z":
                return {
                    g: 0, c: null, s: "[+-]\\d{1,5}"
                };
            default:
                return {
                    g: 0, c: null, s: String.escape(e)
                }
        }
    }, Date.prototype.getTimezone = function () {
        return this.toString().replace(/^.*? ([A-Z]{3}) [0-9]{4}.*$/, "$1").replace(/^.*?\(([A-Z])[a-z]+ ([A-Z])[a-z]+ ([A-Z])[a-z]+\)$/, "$1$2$3")
    }, Date.prototype.getGMTOffset = function () {
        return (this.getTimezoneOffset() > 0 ? "-" : "+") + String.leftPad(Math.floor(Math.abs(this.getTimezoneOffset()) / 60), 2, "0") + String.leftPad(Math.abs(this.getTimezoneOffset()) % 60, 2, "0")
    }, Date.prototype.getDayOfYear = function () {
        var e = 0;
        Date.daysInMonth[1] = this.isLeapYear() ? 29 : 28;
        for (var t = 0; t < this.getMonth(); ++t) e += Date.daysInMonth[t];
        return e + this.getDate()
    }, Date.prototype.getWeekOfYear = function () {
        var e = this.getDayOfYear() + (4 - this.getDay()),
            t = new Date(this.getFullYear(), 0, 1),
            n = 7 - t.getDay() + 4;
        return String.leftPad(Math.ceil((e - n) / 7) + 1, 2, "0")
    }, Date.prototype.isLeapYear = function () {
        var e = this.getFullYear();
        return 0 == (3 & e) && (e % 100 || e % 400 == 0 && e)
    }, Date.prototype.getFirstDayOfMonth = function () {
        var e = (this.getDay() - (this.getDate() - 1)) % 7;
        return e < 0 ? e + 7 : e
    }, Date.prototype.getLastDayOfMonth = function () {
        var e = (this.getDay() + (Date.daysInMonth[this.getMonth()] - this.getDate())) % 7;
        return e < 0 ? e + 7 : e
    }, Date.prototype.getDaysInMonth = function () {
        return Date.daysInMonth[1] = this.isLeapYear() ? 29 : 28, Date.daysInMonth[this.getMonth()]
    }, Date.prototype.getSuffix = function () {
        switch (this.getDate()) {
            case 1:
            case 21:
            case 31:
                return "st";
            case 2:
            case 22:
                return "nd";
            case 3:
            case 23:
                return "rd";
            default:
                return "th"
        }
    }, String.escape = function (e) {
        return e.replace(/('|\\)/g, "\\$1")
    }, String.leftPad = function (e, t, n) {
        var a = new String(e);
        for (null == n && (n = " "); a.length < t;) a = n + a;
        return a
    }, Date.daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Date.monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], Date.dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], Date.y2kYear = 50, Date.monthNumbers = {
        Jan: 0,
        Feb: 1,
        Mar: 2,
        Apr: 3,
        May: 4,
        Jun: 5,
        Jul: 6,
        Aug: 7,
        Sep: 8,
        Oct: 9,
        Nov: 10,
        Dec: 11
    }, Date.patterns = {
        ISO8601LongPattern: "Y-m-d H:i:s",
        ISO8601ShortPattern: "Y-m-d",
        ShortDatePattern: "n/j/Y",
        LongDatePattern: "l, F d, Y",
        FullDateTimePattern: "l, F d, Y g:i:s A",
        MonthDayPattern: "F d",
        ShortTimePattern: "g:i A",
        LongTimePattern: "g:i:s A",
        SortableDateTimePattern: "Y-m-d\\TH:i:s",
        UniversalSortableDateTimePattern: "Y-m-d H:i:sO",
        YearMonthPattern: "F, Y"
    },
    function (e) {
        "function" == typeof define && define.amd ? define(["jquery.flot.min"], e) : "object" == typeof exports ? module.exports = e : e(jQuery)
    }(function (e) {
        function t(t) {
            var r, o = t || window.event,
                s = [].slice.call(arguments, 1),
                i = 0,
                d = 0,
                u = 0,
                c = 0,
                l = 0;
            return t = e.event.fix(o), t.type = "mousewheel", o.wheelDelta && (i = o.wheelDelta), o.detail && (i = o.detail * -1), o.deltaY && (u = o.deltaY * -1, i = u), o.deltaX && (d = o.deltaX, i = d * -1), void 0 !== o.wheelDeltaY && (u = o.wheelDeltaY), void 0 !== o.wheelDeltaX && (d = o.wheelDeltaX * -1), c = Math.abs(i), (!n || c < n) && (n = c), l = Math.max(Math.abs(u), Math.abs(d)), (!a || l < a) && (a = l), r = i > 0 ? "floor" : "ceil", i = Math[r](i / n), d = Math[r](d / a), u = Math[r](u / a), s.unshift(t, i, d, u), (e.event.dispatch || e.event.handle).apply(this, s)
        }
        var n, a, r = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
            o = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"];
        if (e.event.fixHooks)
            for (var s = r.length; s;) e.event.fixHooks[r[--s]] = e.event.mouseHooks;
        e.event.special.mousewheel = {
            setup: function () {
                if (this.addEventListener)
                    for (var e = o.length; e;) this.addEventListener(o[--e], t, !1);
                else this.onmousewheel = t
            },
            teardown: function () {
                if (this.removeEventListener)
                    for (var e = o.length; e;) this.removeEventListener(o[--e], t, !1);
                else this.onmousewheel = null
            }
        }, e.fn.extend({
            mousewheel: function (e) {
                return e ? this.bind("mousewheel", e) : this.trigger("mousewheel")
            },
            unmousewheel: function (e) {
                return this.unbind("mousewheel", e)
            }
        })
    });

function _toConsumableArray(e) {
    if (Array.isArray(e)) {
        for (var t = 0, i = Array(e.length); t < e.length; t++) i[t] = e[t];
        return i
    }
    return Array.from(e)
}
var _slice = Array.prototype.slice,
    _slicedToArray = function () {
        function e(e, t) {
            var i = [],
                n = !0,
                r = !1,
                s = void 0;
            try {
                for (var a, o = e[Symbol.iterator](); !(n = (a = o.next()).done) && (i.push(a.value), !t || i.length !== t); n = !0);
            } catch (l) {
                r = !0, s = l
            } finally {
                try {
                    !n && o["return"] && o["return"]()
                } finally {
                    if (r) throw s
                }
            }
            return i
        }
        return function (t, i) {
            if (Array.isArray(t)) return t;
            if (Symbol.iterator in Object(t)) return e(t, i);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }(),
    _extends = Object.assign || function (e) {
        for (var t = 1; t < arguments.length; t++) {
            var i = arguments[t];
            for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
        }
        return e
    };
! function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t(require("jquery")) : "function" == typeof define && define.amd ? define(["jquery"], t) : e.parsley = t(e.jQuery)
}(this, function (e) {
    "use strict";

    function t(e, t) {
        return e.parsleyAdaptedCallback || (e.parsleyAdaptedCallback = function () {
            var i = Array.prototype.slice.call(arguments, 0);
            i.unshift(this), e.apply(t || T, i)
        }), e.parsleyAdaptedCallback
    }

    function i(e) {
        return 0 === e.lastIndexOf(D, 0) ? e.substr(D.length) : e
    }

    function n() {
        var t = this,
            i = window || global;
        _extends(this, {
            isNativeEvent: function (e) {
                return e.originalEvent && e.originalEvent.isTrusted !== !1
            },
            fakeInputEvent: function (i) {
                t.isNativeEvent(i) && e(i.target).trigger("input")
            },
            misbehaves: function (i) {
                t.isNativeEvent(i) && (t.behavesOk(i), e(document).on("change.inputevent", i.data.selector, t.fakeInputEvent), t.fakeInputEvent(i))
            },
            behavesOk: function (i) {
                t.isNativeEvent(i) && e(document).off("input.inputevent", i.data.selector, t.behavesOk).off("change.inputevent", i.data.selector, t.misbehaves)
            },
            install: function () {
                if (!i.inputEventPatched) {
                    i.inputEventPatched = "0.0.3";
                    for (var n = ["select", 'input[type="checkbox"]', 'input[type="radio"]', 'input[type="file"]'], r = 0; r < n.length; r++) {
                        var s = n[r];
                        e(document).on("input.inputevent", s, {
                            selector: s
                        }, t.behavesOk).on("change.inputevent", s, {
                            selector: s
                        }, t.misbehaves)
                    }
                }
            },
            uninstall: function () {
                delete i.inputEventPatched, e(document).off(".inputevent")
            }
        })
    }
    var r = 1,
        s = {},
        a = {
            attr: function (e, t, i) {
                var n, r, s, a = new RegExp("^" + t, "i");
                if ("undefined" == typeof i) i = {};
                else
                    for (n in i) i.hasOwnProperty(n) && delete i[n];
                if (!e) return i;
                for (s = e.attributes, n = s.length; n--;) r = s[n], r && r.specified && a.test(r.name) && (i[this.camelize(r.name.slice(t.length))] = this.deserializeValue(r.value));
                return i
            },
            checkAttr: function (e, t, i) {
                return e.hasAttribute(t + i)
            },
            setAttr: function (e, t, i, n) {
                e.setAttribute(this.dasherize(t + i), String(n))
            },
            generateID: function () {
                return "" + r++
            },
            deserializeValue: function (t) {
                var i;
                try {
                    return t ? "true" == t || "false" != t && ("null" == t ? null : isNaN(i = Number(t)) ? /^[\[\{]/.test(t) ? e.parseJSON(t) : t : i) : t
                } catch (n) {
                    return t
                }
            },
            camelize: function (e) {
                return e.replace(/-+(.)?/g, function (e, t) {
                    return t ? t.toUpperCase() : ""
                })
            },
            dasherize: function (e) {
                return e.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase()
            },
            warn: function () {
                var e;
                window.console && "function" == typeof window.console.warn && (e = window.console).warn.apply(e, arguments)
            },
            warnOnce: function (e) {
                s[e] || (s[e] = !0, this.warn.apply(this, arguments))
            },
            _resetWarnings: function () {
                s = {}
            },
            trimString: function (e) {
                return e.replace(/^\s+|\s+$/g, "")
            },
            parse: {
                date: function S(e) {
                    var t = e.match(/^(\d{4,})-(\d\d)-(\d\d)$/);
                    if (!t) return null;
                    var i = t.map(function (e) {
                            return parseInt(e, 10)
                        }),
                        n = _slicedToArray(i, 4),
                        r = (n[0], n[1]),
                        s = n[2],
                        a = n[3],
                        S = new Date(r, s - 1, a);
                    return S.getFullYear() !== r || S.getMonth() + 1 !== s || S.getDate() !== a ? null : S
                },
                string: function (e) {
                    return e
                },
                integer: function (e) {
                    return isNaN(e) ? null : parseInt(e, 10)
                },
                number: function (e) {
                    if (isNaN(e)) throw null;
                    return parseFloat(e)
                },
                "boolean": function (e) {
                    return !/^\s*false\s*$/i.test(e)
                },
                object: function (e) {
                    return a.deserializeValue(e)
                },
                regexp: function (e) {
                    var t = "";
                    return /^\/.*\/(?:[gimy]*)$/.test(e) ? (t = e.replace(/.*\/([gimy]*)$/, "$1"), e = e.replace(new RegExp("^/(.*?)/" + t + "$"), "$1")) : e = "^" + e + "$", new RegExp(e, t)
                }
            },
            parseRequirement: function (e, t) {
                var i = this.parse[e || "string"];
                if (!i) throw 'Unknown requirement specification: "' + e + '"';
                var n = i(t);
                if (null === n) throw "Requirement is not a " + e + ': "' + t + '"';
                return n
            },
            namespaceEvents: function (t, i) {
                return t = this.trimString(t || "").split(/\s+/), t[0] ? e.map(t, function (e) {
                    return e + "." + i
                }).join(" ") : ""
            },
            difference: function (t, i) {
                var n = [];
                return e.each(t, function (e, t) {
                    i.indexOf(t) == -1 && n.push(t)
                }), n
            },
            all: function (t) {
                return e.when.apply(e, _toConsumableArray(t).concat([42, 42]))
            },
            objectCreate: Object.create || function () {
                var e = function () {};
                return function (t) {
                    if (arguments.length > 1) throw Error("Second argument not supported");
                    if ("object" != typeof t) throw TypeError("Argument must be an object");
                    e.prototype = t;
                    var i = new e;
                    return e.prototype = null, i
                }
            }(),
            _SubmitSelector: 'input[type="submit"], button:submit'
        },
        o = {
            namespace: "data-parsley-",
            inputs: "input, textarea, select",
            excluded: "input[type=button], input[type=submit], input[type=reset], input[type=hidden]",
            priorityEnabled: !0,
            multiple: null,
            group: null,
            uiEnabled: !0,
            validationThreshold: 3,
            focus: "first",
            trigger: !1,
            triggerAfterFailure: "input",
            errorClass: "parsley-error",
            successClass: "parsley-success",
            classHandler: function (e) {},
            errorsContainer: function (e) {},
            errorsWrapper: '<ul class="parsley-errors-list"></ul>',
            errorTemplate: "<li></li>"
        },
        l = function () {
            this.__id__ = a.generateID()
        };
    l.prototype = {
        asyncSupport: !0,
        _pipeAccordingToValidationResult: function () {
            var t = this,
                i = function () {
                    var i = e.Deferred();
                    return !0 !== t.validationResult && i.reject(), i.resolve().promise()
                };
            return [i, i]
        },
        actualizeOptions: function () {
            return a.attr(this.element, this.options.namespace, this.domOptions), this.parent && this.parent.actualizeOptions && this.parent.actualizeOptions(), this
        },
        _resetOptions: function (e) {
            this.domOptions = a.objectCreate(this.parent.options), this.options = a.objectCreate(this.domOptions);
            for (var t in e) e.hasOwnProperty(t) && (this.options[t] = e[t]);
            this.actualizeOptions()
        },
        _listeners: null,
        on: function (e, t) {
            this._listeners = this._listeners || {};
            var i = this._listeners[e] = this._listeners[e] || [];
            return i.push(t), this
        },
        subscribe: function (t, i) {
            e.listenTo(this, t.toLowerCase(), i)
        },
        off: function (e, t) {
            var i = this._listeners && this._listeners[e];
            if (i)
                if (t)
                    for (var n = i.length; n--;) i[n] === t && i.splice(n, 1);
                else delete this._listeners[e];
            return this
        },
        unsubscribe: function (t, i) {
            e.unsubscribeTo(this, t.toLowerCase())
        },
        trigger: function (e, t, i) {
            t = t || this;
            var n, r = this._listeners && this._listeners[e];
            if (r)
                for (var s = r.length; s--;)
                    if (n = r[s].call(t, t, i), n === !1) return n;
            return !this.parent || this.parent.trigger(e, t, i)
        },
        asyncIsValid: function (e, t) {
            return a.warnOnce("asyncIsValid is deprecated; please use whenValid instead"), this.whenValid({
                group: e,
                force: t
            })
        },
        _findRelated: function () {
            return this.options.multiple ? e(this.parent.element.querySelectorAll("[" + this.options.namespace + 'multiple="' + this.options.multiple + '"]')) : this.$element
        }
    };
    var u = function (e, t) {
            var i = e.match(/^\s*\[(.*)\]\s*$/);
            if (!i) throw 'Requirement is not an array: "' + e + '"';
            var n = i[1].split(",").map(a.trimString);
            if (n.length !== t) throw "Requirement has " + n.length + " values when " + t + " are needed";
            return n
        },
        d = function (e, t, i) {
            var n = null,
                r = {};
            for (var s in e)
                if (s) {
                    var o = i(s);
                    "string" == typeof o && (o = a.parseRequirement(e[s], o)), r[s] = o
                } else n = a.parseRequirement(e[s], t);
            return [n, r]
        },
        h = function (t) {
            e.extend(!0, this, t)
        };
    h.prototype = {
        validate: function (e, t) {
            if (this.fn) return arguments.length > 3 && (t = [].slice.call(arguments, 1, -1)), this.fn(e, t);
            if (Array.isArray(e)) {
                if (!this.validateMultiple) throw "Validator `" + this.name + "` does not handle multiple values";
                return this.validateMultiple.apply(this, arguments)
            }
            var i = arguments[arguments.length - 1];
            if (this.validateDate && i._isDateInput()) return arguments[0] = a.parse.date(arguments[0]), null !== arguments[0] && this.validateDate.apply(this, arguments);
            if (this.validateNumber) return !isNaN(e) && (arguments[0] = parseFloat(arguments[0]), this.validateNumber.apply(this, arguments));
            if (this.validateString) return this.validateString.apply(this, arguments);
            throw "Validator `" + this.name + "` only handles multiple values"
        },
        parseRequirements: function (t, i) {
            if ("string" != typeof t) return Array.isArray(t) ? t : [t];
            var n = this.requirementType;
            if (Array.isArray(n)) {
                for (var r = u(t, n.length), s = 0; s < r.length; s++) r[s] = a.parseRequirement(n[s], r[s]);
                return r
            }
            return e.isPlainObject(n) ? d(n, t, i) : [a.parseRequirement(n, t)]
        },
        requirementType: "string",
        priority: 2
    };
    var p = function (e, t) {
            this.__class__ = "ValidatorRegistry", this.locale = "en", this.init(e || {}, t || {})
        },
        c = {
            email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,
            number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i,
            integer: /^-?\d+$/,
            digits: /^\d+$/,
            alphanum: /^\w+$/i,
            date: {
                test: function (e) {
                    return null !== a.parse.date(e)
                }
            },
            url: new RegExp("^(?:(?:https?|ftp)://)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:/\\S*)?$", "i")
        };
    c.range = c.number;
    var f = function (e) {
            var t = ("" + e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
            return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0
        },
        m = function (e, t) {
            return t.map(a.parse[e])
        },
        g = function (e, t) {
            return function (i) {
                for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++) r[s - 1] = arguments[s];
                return r.pop(), t.apply(void 0, [i].concat(_toConsumableArray(m(e, r))))
            }
        },
        v = function (e) {
            return {
                validateDate: g("date", e),
                validateNumber: g("number", e),
                requirementType: e.length <= 2 ? "string" : ["string", "string"],
                priority: 30
            }
        };
    p.prototype = {
        init: function (e, t) {
            this.catalog = t, this.validators = _extends({}, this.validators);
            for (var i in e) this.addValidator(i, e[i].fn, e[i].priority);
            window.Parsley.trigger("parsley:validator:init")
        },
        setLocale: function (e) {
            if ("undefined" == typeof this.catalog[e]) throw new Error(e + " is not available in the catalog");
            return this.locale = e, this
        },
        addCatalog: function (e, t, i) {
            return "object" == typeof t && (this.catalog[e] = t), !0 === i ? this.setLocale(e) : this
        },
        addMessage: function (e, t, i) {
            return "undefined" == typeof this.catalog[e] && (this.catalog[e] = {}), this.catalog[e][t] = i, this
        },
        addMessages: function (e, t) {
            for (var i in t) this.addMessage(e, i, t[i]);
            return this
        },
        addValidator: function (e, t, i) {
            if (this.validators[e]) a.warn('Validator "' + e + '" is already defined.');
            else if (o.hasOwnProperty(e)) return void a.warn('"' + e + '" is a restricted keyword and is not a valid validator name.');
            return this._setValidator.apply(this, arguments)
        },
        updateValidator: function (e, t, i) {
            return this.validators[e] ? this._setValidator.apply(this, arguments) : (a.warn('Validator "' + e + '" is not already defined.'), this.addValidator.apply(this, arguments))
        },
        removeValidator: function (e) {
            return this.validators[e] || a.warn('Validator "' + e + '" is not defined.'), delete this.validators[e], this
        },
        _setValidator: function (e, t, i) {
            "object" != typeof t && (t = {
                fn: t,
                priority: i
            }), t.validate || (t = new h(t)), this.validators[e] = t;
            for (var n in t.messages || {}) this.addMessage(n, e, t.messages[n]);
            return this
        },
        getErrorMessage: function (e) {
            var t;
            if ("type" === e.name) {
                var i = this.catalog[this.locale][e.name] || {};
                t = i[e.requirements]
            } else t = this.formatMessage(this.catalog[this.locale][e.name], e.requirements);
            return t || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage
        },
        formatMessage: function (e, t) {
            if ("object" == typeof t) {
                for (var i in t) e = this.formatMessage(e, t[i]);
                return e
            }
            return "string" == typeof e ? e.replace(/%s/i, t) : ""
        },
        validators: {
            notblank: {
                validateString: function (e) {
                    return /\S/.test(e)
                },
                priority: 2
            },
            required: {
                validateMultiple: function (e) {
                    return e.length > 0
                },
                validateString: function (e) {
                    return /\S/.test(e)
                },
                priority: 512
            },
            type: {
                validateString: function (e, t) {
                    var i = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],
                        n = i.step,
                        r = void 0 === n ? "any" : n,
                        s = i.base,
                        a = void 0 === s ? 0 : s,
                        o = c[t];
                    if (!o) throw new Error("validator type `" + t + "` is not supported");
                    if (!o.test(e)) return !1;
                    if ("number" === t && !/^any$/i.test(r || "")) {
                        var l = Number(e),
                            u = Math.max(f(r), f(a));
                        if (f(l) > u) return !1;
                        var d = function (e) {
                            return Math.round(e * Math.pow(10, u))
                        };
                        if ((d(l) - d(a)) % d(r) != 0) return !1
                    }
                    return !0
                },
                requirementType: {
                    "": "string",
                    step: "string",
                    base: "number"
                },
                priority: 256
            },
            pattern: {
                validateString: function (e, t) {
                    return t.test(e)
                },
                requirementType: "regexp",
                priority: 64
            },
            minlength: {
                validateString: function (e, t) {
                    return e.length >= t
                },
                requirementType: "integer",
                priority: 30
            },
            maxlength: {
                validateString: function (e, t) {
                    return e.length <= t
                },
                requirementType: "integer",
                priority: 30
            },
            length: {
                validateString: function (e, t, i) {
                    return e.length >= t && e.length <= i
                },
                requirementType: ["integer", "integer"],
                priority: 30
            },
            mincheck: {
                validateMultiple: function (e, t) {
                    return e.length >= t
                },
                requirementType: "integer",
                priority: 30
            },
            maxcheck: {
                validateMultiple: function (e, t) {
                    return e.length <= t
                },
                requirementType: "integer",
                priority: 30
            },
            check: {
                validateMultiple: function (e, t, i) {
                    return e.length >= t && e.length <= i
                },
                requirementType: ["integer", "integer"],
                priority: 30
            },
            min: v(function (e, t) {
                return e >= t
            }),
            max: v(function (e, t) {
                return e <= t
            }),
            range: v(function (e, t, i) {
                return e >= t && e <= i
            }),
            equalto: {
                validateString: function (t, i) {
                    var n = e(i);
                    return n.length ? t === n.val() : t === i
                },
                priority: 256
            }
        }
    };
    var y = {},
        _ = function k(e, t, i) {
            for (var n = [], r = [], s = 0; s < e.length; s++) {
                for (var a = !1, o = 0; o < t.length; o++)
                    if (e[s].assert.name === t[o].assert.name) {
                        a = !0;
                        break
                    } a ? r.push(e[s]) : n.push(e[s])
            }
            return {
                kept: r,
                added: n,
                removed: i ? [] : k(t, e, !0).added
            }
        };
    y.Form = {
        _actualizeTriggers: function () {
            var e = this;
            this.$element.on("submit.Parsley", function (t) {
                e.onSubmitValidate(t)
            }), this.$element.on("click.Parsley", a._SubmitSelector, function (t) {
                e.onSubmitButton(t)
            }), !1 !== this.options.uiEnabled && this.element.setAttribute("novalidate", "")
        },
        focus: function () {
            if (this._focusedField = null, !0 === this.validationResult || "none" === this.options.focus) return null;
            for (var e = 0; e < this.fields.length; e++) {
                var t = this.fields[e];
                if (!0 !== t.validationResult && t.validationResult.length > 0 && "undefined" == typeof t.options.noFocus && (this._focusedField = t.$element, "first" === this.options.focus)) break
            }
            return null === this._focusedField ? null : this._focusedField.focus()
        },
        _destroyUI: function () {
            this.$element.off(".Parsley")
        }
    }, y.Field = {
        _reflowUI: function () {
            if (this._buildUI(), this._ui) {
                var e = _(this.validationResult, this._ui.lastValidationResult);
                this._ui.lastValidationResult = this.validationResult, this._manageStatusClass(), this._manageErrorsMessages(e), this._actualizeTriggers(), !e.kept.length && !e.added.length || this._failedOnce || (this._failedOnce = !0, this._actualizeTriggers())
            }
        },
        getErrorsMessages: function () {
            if (!0 === this.validationResult) return [];
            for (var e = [], t = 0; t < this.validationResult.length; t++) e.push(this.validationResult[t].errorMessage || this._getErrorMessage(this.validationResult[t].assert));
            return e
        },
        addError: function (e) {
            var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
                i = t.message,
                n = t.assert,
                r = t.updateClass,
                s = void 0 === r || r;
            this._buildUI(), this._addError(e, {
                message: i,
                assert: n
            }), s && this._errorClass()
        },
        updateError: function (e) {
            var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
                i = t.message,
                n = t.assert,
                r = t.updateClass,
                s = void 0 === r || r;
            this._buildUI(), this._updateError(e, {
                message: i,
                assert: n
            }), s && this._errorClass()
        },
        removeError: function (e) {
            var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
                i = t.updateClass,
                n = void 0 === i || i;
            this._buildUI(), this._removeError(e), n && this._manageStatusClass()
        },
        _manageStatusClass: function () {
            this.hasConstraints() && this.needsValidation() && !0 === this.validationResult ? this._successClass() : this.validationResult.length > 0 ? this._errorClass() : this._resetClass()
        },
        _manageErrorsMessages: function (t) {
            if ("undefined" == typeof this.options.errorsMessagesDisabled) {
                if ("undefined" != typeof this.options.errorMessage) return t.added.length || t.kept.length ? (this._insertErrorWrapper(), 0 === this._ui.$errorsWrapper.find(".parsley-custom-error-message").length && this._ui.$errorsWrapper.append(e(this.options.errorTemplate).addClass("parsley-custom-error-message")), this._ui.$errorsWrapper.addClass("filled").find(".parsley-custom-error-message").html(this.options.errorMessage)) : this._ui.$errorsWrapper.removeClass("filled").find(".parsley-custom-error-message").remove();
                for (var i = 0; i < t.removed.length; i++) this._removeError(t.removed[i].assert.name);
                for (i = 0; i < t.added.length; i++) this._addError(t.added[i].assert.name, {
                    message: t.added[i].errorMessage,
                    assert: t.added[i].assert
                });
                for (i = 0; i < t.kept.length; i++) this._updateError(t.kept[i].assert.name, {
                    message: t.kept[i].errorMessage,
                    assert: t.kept[i].assert
                })
            }
        },
        _addError: function (t, i) {
            var n = i.message,
                r = i.assert;
            this._insertErrorWrapper(), this._ui.$errorsWrapper.addClass("filled").append(e(this.options.errorTemplate).addClass("parsley-" + t).html(n || this._getErrorMessage(r)))
        },
        _updateError: function (e, t) {
            var i = t.message,
                n = t.assert;
            this._ui.$errorsWrapper.addClass("filled").find(".parsley-" + e).html(i || this._getErrorMessage(n))
        },
        _removeError: function (e) {
            this._ui.$errorsWrapper.removeClass("filled").find(".parsley-" + e).remove()
        },
        _getErrorMessage: function (e) {
            var t = e.name + "Message";
            return "undefined" != typeof this.options[t] ? window.Parsley.formatMessage(this.options[t], e.requirements) : window.Parsley.getErrorMessage(e)
        },
        _buildUI: function () {
            if (!this._ui && !1 !== this.options.uiEnabled) {
                var t = {};
                this.element.setAttribute(this.options.namespace + "id", this.__id__), t.$errorClassHandler = this._manageClassHandler(), t.errorsWrapperId = "parsley-id-" + (this.options.multiple ? "multiple-" + this.options.multiple : this.__id__), t.$errorsWrapper = e(this.options.errorsWrapper).attr("id", t.errorsWrapperId), t.lastValidationResult = [], t.validationInformationVisible = !1, this._ui = t
            }
        },
        _manageClassHandler: function () {
            if ("string" == typeof this.options.classHandler) return 0 === e(this.options.classHandler).length && ParsleyUtils.warn("No elements found that match the selector `" + this.options.classHandler + "` set in options.classHandler or data-parsley-class-handler"), e(this.options.classHandler);
            if ("function" == typeof this.options.classHandler) var t = this.options.classHandler.call(this, this);
            return "undefined" != typeof t && t.length ? t : this._inputHolder()
        },
        _inputHolder: function () {
            return this.options.multiple && "SELECT" !== this.element.nodeName ? this.$element.parent() : this.$element
        },
        _insertErrorWrapper: function () {
            var t;
            if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();
            if ("string" == typeof this.options.errorsContainer) {
                if (e(this.options.errorsContainer).length) return e(this.options.errorsContainer).append(this._ui.$errorsWrapper);
                a.warn("The errors container `" + this.options.errorsContainer + "` does not exist in DOM")
            } else "function" == typeof this.options.errorsContainer && (t = this.options.errorsContainer.call(this, this));
            return "undefined" != typeof t && t.length ? t.append(this._ui.$errorsWrapper) : this._inputHolder().after(this._ui.$errorsWrapper)
        },
        _actualizeTriggers: function () {
            var e, t = this,
                i = this._findRelated();
            i.off(".Parsley"), this._failedOnce ? i.on(a.namespaceEvents(this.options.triggerAfterFailure, "Parsley"), function () {
                t._validateIfNeeded()
            }) : (e = a.namespaceEvents(this.options.trigger, "Parsley")) && i.on(e, function (e) {
                t._validateIfNeeded(e)
            })
        },
        _validateIfNeeded: function (e) {
            var t = this;
            e && /key|input/.test(e.type) && (!this._ui || !this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold || (this.options.debounce ? (window.clearTimeout(this._debounced), this._debounced = window.setTimeout(function () {
                return t.validate()
            }, this.options.debounce)) : this.validate())
        },
        _resetUI: function () {
            this._failedOnce = !1, this._actualizeTriggers(), "undefined" != typeof this._ui && (this._ui.$errorsWrapper.removeClass("filled").children().remove(), this._resetClass(), this._ui.lastValidationResult = [], this._ui.validationInformationVisible = !1)
        },
        _destroyUI: function () {
            this._resetUI(), "undefined" != typeof this._ui && this._ui.$errorsWrapper.remove(), delete this._ui
        },
        _successClass: function () {
            this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass)
        },
        _errorClass: function () {
            this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass)
        },
        _resetClass: function () {
            this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass)
        }
    };
    var w = function (t, i, n) {
            this.__class__ = "Form", this.element = t, this.$element = e(t), this.domOptions = i, this.options = n, this.parent = window.Parsley, this.fields = [], this.validationResult = null
        },
        b = {
            pending: null,
            resolved: !0,
            rejected: !1
        };
    w.prototype = {
        onSubmitValidate: function (e) {
            var t = this;
            if (!0 !== e.parsley) {
                var i = this._submitSource || this.$element.find(a._SubmitSelector)[0];
                if (this._submitSource = null, this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !0), !i || null === i.getAttribute("formnovalidate")) {
                    window.Parsley._remoteCache = {};
                    var n = this.whenValidate({
                        event: e
                    });
                    "resolved" === n.state() && !1 !== this._trigger("submit") || (e.stopImmediatePropagation(), e.preventDefault(), "pending" === n.state() && n.done(function () {
                        t._submit(i)
                    }))
                }
            }
        },
        onSubmitButton: function (e) {
            this._submitSource = e.currentTarget
        },
        _submit: function (t) {
            if (!1 !== this._trigger("submit")) {
                if (t) {
                    var i = this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !1);
                    0 === i.length && (i = e('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element)), i.attr({
                        name: t.getAttribute("name"),
                        value: t.getAttribute("value")
                    })
                }
                this.$element.trigger(_extends(e.Event("submit"), {
                    parsley: !0
                }))
            }
        },
        validate: function (t) {
            if (arguments.length >= 1 && !e.isPlainObject(t)) {
                a.warnOnce("Calling validate on a parsley form without passing arguments as an object is deprecated.");
                var i = _slice.call(arguments),
                    n = i[0],
                    r = i[1],
                    s = i[2];
                t = {
                    group: n,
                    force: r,
                    event: s
                }
            }
            return b[this.whenValidate(t).state()]
        },
        whenValidate: function () {
            var t, i = this,
                n = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                r = n.group,
                s = n.force,
                o = n.event;
            this.submitEvent = o, o && (this.submitEvent = _extends({}, o, {
                preventDefault: function () {
                    a.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`"), i.validationResult = !1
                }
            })), this.validationResult = !0, this._trigger("validate"), this._refreshFields();
            var l = this._withoutReactualizingFormOptions(function () {
                return e.map(i.fields, function (e) {
                    return e.whenValidate({
                        force: s,
                        group: r
                    })
                })
            });
            return (t = a.all(l).done(function () {
                i._trigger("success")
            }).fail(function () {
                i.validationResult = !1, i.focus(), i._trigger("error")
            }).always(function () {
                i._trigger("validated")
            })).pipe.apply(t, _toConsumableArray(this._pipeAccordingToValidationResult()))
        },
        isValid: function (t) {
            if (arguments.length >= 1 && !e.isPlainObject(t)) {
                a.warnOnce("Calling isValid on a parsley form without passing arguments as an object is deprecated.");
                var i = _slice.call(arguments),
                    n = i[0],
                    r = i[1];
                t = {
                    group: n,
                    force: r
                }
            }
            return b[this.whenValid(t).state()]
        },
        whenValid: function () {
            var t = this,
                i = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                n = i.group,
                r = i.force;
            this._refreshFields();
            var s = this._withoutReactualizingFormOptions(function () {
                return e.map(t.fields, function (e) {
                    return e.whenValid({
                        group: n,
                        force: r
                    })
                })
            });
            return a.all(s)
        },
        reset: function () {
            for (var e = 0; e < this.fields.length; e++) this.fields[e].reset();
            this._trigger("reset")
        },
        destroy: function () {
            this._destroyUI();
            for (var e = 0; e < this.fields.length; e++) this.fields[e].destroy();
            this.$element.removeData("Parsley"), this._trigger("destroy")
        },
        _refreshFields: function () {
            return this.actualizeOptions()._bindFields()
        },
        _bindFields: function () {
            var t = this,
                i = this.fields;
            return this.fields = [], this.fieldsMappedById = {}, this._withoutReactualizingFormOptions(function () {
                t.$element.find(t.options.inputs).not(t.options.excluded).each(function (e, i) {
                    var n = new window.Parsley.Factory(i, {}, t);
                    if (("Field" === n.__class__ || "FieldMultiple" === n.__class__) && !0 !== n.options.excluded) {
                        var r = n.__class__ + "-" + n.__id__;
                        "undefined" == typeof t.fieldsMappedById[r] && (t.fieldsMappedById[r] = n, t.fields.push(n))
                    }
                }), e.each(a.difference(i, t.fields), function (e, t) {
                    t.reset()
                })
            }), this
        },
        _withoutReactualizingFormOptions: function (e) {
            var t = this.actualizeOptions;
            this.actualizeOptions = function () {
                return this
            };
            var i = e();
            return this.actualizeOptions = t, i
        },
        _trigger: function (e) {
            return this.trigger("form:" + e)
        }
    };
    var F = function (e, t, i, n, r) {
            var s = window.Parsley._validatorRegistry.validators[t],
                a = new h(s);
            n = n || e.options[t + "Priority"] || a.priority, r = !0 === r, _extends(this, {
                validator: a,
                name: t,
                requirements: i,
                priority: n,
                isDomConstraint: r
            }), this._parseRequirements(e.options)
        },
        C = function (e) {
            var t = e[0].toUpperCase();
            return t + e.slice(1)
        };
    F.prototype = {
        validate: function (e, t) {
            var i;
            return (i = this.validator).validate.apply(i, [e].concat(_toConsumableArray(this.requirementList), [t]))
        },
        _parseRequirements: function (e) {
            var t = this;
            this.requirementList = this.validator.parseRequirements(this.requirements, function (i) {
                return e[t.name + C(i)]
            })
        }
    };
    var E = function (t, i, n, r) {
            this.__class__ = "Field", this.element = t, this.$element = e(t), "undefined" != typeof r && (this.parent = r), this.options = n, this.domOptions = i, this.constraints = [], this.constraintsByName = {}, this.validationResult = !0, this._bindConstraints()
        },
        A = {
            pending: null,
            resolved: !0,
            rejected: !1
        };
    E.prototype = {
        validate: function (t) {
            arguments.length >= 1 && !e.isPlainObject(t) && (a.warnOnce("Calling validate on a parsley field without passing arguments as an object is deprecated."), t = {
                options: t
            });
            var i = this.whenValidate(t);
            if (!i) return !0;
            switch (i.state()) {
                case "pending":
                    return null;
                case "resolved":
                    return !0;
                case "rejected":
                    return this.validationResult
            }
        },
        whenValidate: function () {
            var e, t = this,
                i = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                n = i.force,
                r = i.group;
            if (this.refreshConstraints(), !r || this._isInGroup(r)) return this.value = this.getValue(), this._trigger("validate"), (e = this.whenValid({
                force: n,
                value: this.value,
                _refreshed: !0
            }).always(function () {
                t._reflowUI()
            }).done(function () {
                t._trigger("success")
            }).fail(function () {
                t._trigger("error")
            }).always(function () {
                t._trigger("validated")
            })).pipe.apply(e, _toConsumableArray(this._pipeAccordingToValidationResult()))
        },
        hasConstraints: function () {
            return 0 !== this.constraints.length
        },
        needsValidation: function (e) {
            return "undefined" == typeof e && (e = this.getValue()), !(!e.length && !this._isRequired() && "undefined" == typeof this.options.validateIfEmpty)
        },
        _isInGroup: function (t) {
            return Array.isArray(this.options.group) ? -1 !== e.inArray(t, this.options.group) : this.options.group === t
        },
        isValid: function (t) {
            if (arguments.length >= 1 && !e.isPlainObject(t)) {
                a.warnOnce("Calling isValid on a parsley field without passing arguments as an object is deprecated.");
                var i = _slice.call(arguments),
                    n = i[0],
                    r = i[1];
                t = {
                    force: n,
                    value: r
                }
            }
            var s = this.whenValid(t);
            return !s || A[s.state()]
        },
        whenValid: function () {
            var t = this,
                i = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
                n = i.force,
                r = void 0 !== n && n,
                s = i.value,
                o = i.group,
                l = i._refreshed;
            if (l || this.refreshConstraints(), !o || this._isInGroup(o)) {
                if (this.validationResult = !0, !this.hasConstraints()) return e.when();
                if ("undefined" != typeof s && null !== s || (s = this.getValue()), !this.needsValidation(s) && !0 !== r) return e.when();
                var u = this._getGroupedConstraints(),
                    d = [];
                return e.each(u, function (i, n) {
                    var r = a.all(e.map(n, function (e) {
                        return t._validateConstraint(s, e)
                    }));
                    if (d.push(r), "rejected" === r.state()) return !1
                }), a.all(d)
            }
        },
        _validateConstraint: function (t, i) {
            var n = this,
                r = i.validate(t, this);
            return !1 === r && (r = e.Deferred().reject()), a.all([r]).fail(function (e) {
                n.validationResult instanceof Array || (n.validationResult = []), n.validationResult.push({
                    assert: i,
                    errorMessage: "string" == typeof e && e
                })
            })
        },
        getValue: function () {
            var e;
            return e = "function" == typeof this.options.value ? this.options.value(this) : "undefined" != typeof this.options.value ? this.options.value : this.$element.val(), "undefined" == typeof e || null === e ? "" : this._handleWhitespace(e)
        },
        reset: function () {
            return this._resetUI(), this._trigger("reset")
        },
        destroy: function () {
            this._destroyUI(), this.$element.removeData("Parsley"), this.$element.removeData("FieldMultiple"), this._trigger("destroy")
        },
        refreshConstraints: function () {
            return this.actualizeOptions()._bindConstraints()
        },
        addConstraint: function (e, t, i, n) {
            if (window.Parsley._validatorRegistry.validators[e]) {
                var r = new F(this, e, t, i, n);
                "undefined" !== this.constraintsByName[r.name] && this.removeConstraint(r.name), this.constraints.push(r), this.constraintsByName[r.name] = r
            }
            return this
        },
        removeConstraint: function (e) {
            for (var t = 0; t < this.constraints.length; t++)
                if (e === this.constraints[t].name) {
                    this.constraints.splice(t, 1);
                    break
                } return delete this.constraintsByName[e], this
        },
        updateConstraint: function (e, t, i) {
            return this.removeConstraint(e).addConstraint(e, t, i)
        },
        _bindConstraints: function () {
            for (var e = [], t = {}, i = 0; i < this.constraints.length; i++) !1 === this.constraints[i].isDomConstraint && (e.push(this.constraints[i]), t[this.constraints[i].name] = this.constraints[i]);
            this.constraints = e, this.constraintsByName = t;
            for (var n in this.options) this.addConstraint(n, this.options[n], void 0, !0);
            return this._bindHtml5Constraints()
        },
        _bindHtml5Constraints: function () {
            null !== this.element.getAttribute("required") && this.addConstraint("required", !0, void 0, !0), null !== this.element.getAttribute("pattern") && this.addConstraint("pattern", this.element.getAttribute("pattern"), void 0, !0);
            var e = this.element.getAttribute("min"),
                t = this.element.getAttribute("max");
            null !== e && null !== t ? this.addConstraint("range", [e, t], void 0, !0) : null !== e ? this.addConstraint("min", e, void 0, !0) : null !== t && this.addConstraint("max", t, void 0, !0), null !== this.element.getAttribute("minlength") && null !== this.element.getAttribute("maxlength") ? this.addConstraint("length", [this.element.getAttribute("minlength"), this.element.getAttribute("maxlength")], void 0, !0) : null !== this.element.getAttribute("minlength") ? this.addConstraint("minlength", this.element.getAttribute("minlength"), void 0, !0) : null !== this.element.getAttribute("maxlength") && this.addConstraint("maxlength", this.element.getAttribute("maxlength"), void 0, !0);
            var i = this.element.type;
            return "number" === i ? this.addConstraint("type", ["number", {
                step: this.element.getAttribute("step") || "1",
                base: e || this.element.getAttribute("value")
            }], void 0, !0) : /^(email|url|range|date)$/i.test(i) ? this.addConstraint("type", i, void 0, !0) : this
        },
        _isRequired: function () {
            return "undefined" != typeof this.constraintsByName.required && !1 !== this.constraintsByName.required.requirements
        },
        _trigger: function (e) {
            return this.trigger("field:" + e)
        },
        _handleWhitespace: function (e) {
            return !0 === this.options.trimValue && a.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"'), "squish" === this.options.whitespace && (e = e.replace(/\s{2,}/g, " ")), "trim" !== this.options.whitespace && "squish" !== this.options.whitespace && !0 !== this.options.trimValue || (e = a.trimString(e)), e
        },
        _isDateInput: function () {
            var e = this.constraintsByName.type;
            return e && "date" === e.requirements
        },
        _getGroupedConstraints: function () {
            if (!1 === this.options.priorityEnabled) return [this.constraints];
            for (var e = [], t = {}, i = 0; i < this.constraints.length; i++) {
                var n = this.constraints[i].priority;
                t[n] || e.push(t[n] = []), t[n].push(this.constraints[i])
            }
            return e.sort(function (e, t) {
                return t[0].priority - e[0].priority
            }), e
        }
    };
    var x = E,
        $ = function () {
            this.__class__ = "FieldMultiple"
        };
    $.prototype = {
        addElement: function (e) {
            return this.$elements.push(e), this
        },
        refreshConstraints: function () {
            var t;
            if (this.constraints = [], "SELECT" === this.element.nodeName) return this.actualizeOptions()._bindConstraints(),
                this;
            for (var i = 0; i < this.$elements.length; i++)
                if (e("html").has(this.$elements[i]).length) {
                    t = this.$elements[i].data("FieldMultiple").refreshConstraints().constraints;
                    for (var n = 0; n < t.length; n++) this.addConstraint(t[n].name, t[n].requirements, t[n].priority, t[n].isDomConstraint)
                } else this.$elements.splice(i, 1);
            return this
        },
        getValue: function () {
            if ("function" == typeof this.options.value) return this.options.value(this);
            if ("undefined" != typeof this.options.value) return this.options.value;
            if ("INPUT" === this.element.nodeName) {
                if ("radio" === this.element.type) return this._findRelated().filter(":checked").val() || "";
                if ("checkbox" === this.element.type) {
                    var t = [];
                    return this._findRelated().filter(":checked").each(function () {
                        t.push(e(this).val())
                    }), t
                }
            }
            return "SELECT" === this.element.nodeName && null === this.$element.val() ? [] : this.$element.val()
        },
        _init: function () {
            return this.$elements = [this.$element], this
        }
    };
    var P = function (t, i, n) {
        this.element = t, this.$element = e(t);
        var r = this.$element.data("Parsley");
        if (r) return "undefined" != typeof n && r.parent === window.Parsley && (r.parent = n, r._resetOptions(r.options)), "object" == typeof i && _extends(r.options, i), r;
        if (!this.$element.length) throw new Error("You must bind Parsley on an existing element.");
        if ("undefined" != typeof n && "Form" !== n.__class__) throw new Error("Parent instance must be a Form instance");
        return this.parent = n || window.Parsley, this.init(i)
    };
    P.prototype = {
        init: function (e) {
            return this.__class__ = "Parsley", this.__version__ = "2.7.2", this.__id__ = a.generateID(), this._resetOptions(e), "FORM" === this.element.nodeName || a.checkAttr(this.element, this.options.namespace, "validate") && !this.$element.is(this.options.inputs) ? this.bind("parsleyForm") : this.isMultiple() ? this.handleMultiple() : this.bind("parsleyField")
        },
        isMultiple: function () {
            return "radio" === this.element.type || "checkbox" === this.element.type || "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple")
        },
        handleMultiple: function () {
            var t, i, n = this;
            if (this.options.multiple = this.options.multiple || (t = this.element.getAttribute("name")) || this.element.getAttribute("id"), "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple")) return this.options.multiple = this.options.multiple || this.__id__, this.bind("parsleyFieldMultiple");
            if (!this.options.multiple) return a.warn("To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.", this.$element), this;
            this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ""), t && e('input[name="' + t + '"]').each(function (e, t) {
                "radio" !== t.type && "checkbox" !== t.type || t.setAttribute(n.options.namespace + "multiple", n.options.multiple)
            });
            for (var r = this._findRelated(), s = 0; s < r.length; s++)
                if (i = e(r.get(s)).data("Parsley"), "undefined" != typeof i) {
                    this.$element.data("FieldMultiple") || i.addElement(this.$element);
                    break
                } return this.bind("parsleyField", !0), i || this.bind("parsleyFieldMultiple")
        },
        bind: function (t, i) {
            var n;
            switch (t) {
                case "parsleyForm":
                    n = e.extend(new w(this.element, this.domOptions, this.options), new l, window.ParsleyExtend)._bindFields();
                    break;
                case "parsleyField":
                    n = e.extend(new x(this.element, this.domOptions, this.options, this.parent), new l, window.ParsleyExtend);
                    break;
                case "parsleyFieldMultiple":
                    n = e.extend(new x(this.element, this.domOptions, this.options, this.parent), new $, new l, window.ParsleyExtend)._init();
                    break;
                default:
                    throw new Error(t + "is not a supported Parsley type")
            }
            return this.options.multiple && a.setAttr(this.element, this.options.namespace, "multiple", this.options.multiple), "undefined" != typeof i ? (this.$element.data("FieldMultiple", n), n) : (this.$element.data("Parsley", n), n._actualizeTriggers(), n._trigger("init"), n)
        }
    };
    var V = e.fn.jquery.split(".");
    if (parseInt(V[0]) <= 1 && parseInt(V[1]) < 8) throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.";
    V.forEach || a.warn("Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim");
    var O = _extends(new l, {
        element: document,
        $element: e(document),
        actualizeOptions: null,
        _resetOptions: null,
        Factory: P,
        version: "2.7.2"
    });
    _extends(x.prototype, y.Field, l.prototype), _extends(w.prototype, y.Form, l.prototype), _extends(P.prototype, l.prototype), e.fn.parsley = e.fn.psly = function (t) {
        if (this.length > 1) {
            var i = [];
            return this.each(function () {
                i.push(e(this).parsley(t))
            }), i
        }
        return e(this).length ? new P(this[0], t) : void a.warn("You must bind Parsley on an existing element.")
    }, "undefined" == typeof window.ParsleyExtend && (window.ParsleyExtend = {}), O.options = _extends(a.objectCreate(o), window.ParsleyConfig), window.ParsleyConfig = O.options, window.Parsley = window.psly = O, O.Utils = a, window.ParsleyUtils = {}, e.each(a, function (e, t) {
        "function" == typeof t && (window.ParsleyUtils[e] = function () {
            return a.warnOnce("Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead."), a[e].apply(a, arguments)
        })
    });
    var M = window.Parsley._validatorRegistry = new p(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);
    window.ParsleyValidator = {}, e.each("setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator".split(" "), function (e, t) {
        window.Parsley[t] = function () {
            return M[t].apply(M, arguments)
        }, window.ParsleyValidator[t] = function () {
            var e;
            return a.warnOnce("Accessing the method '" + t + "' through Validator is deprecated. Simply call 'window.Parsley." + t + "(...)'"), (e = window.Parsley)[t].apply(e, arguments)
        }
    }), window.Parsley.UI = y, window.ParsleyUI = {
        removeError: function (e, t, i) {
            var n = !0 !== i;
            return a.warnOnce("Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method."), e.removeError(t, {
                updateClass: n
            })
        },
        getErrorsMessages: function (e) {
            return a.warnOnce("Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly."), e.getErrorsMessages()
        }
    }, e.each("addError updateError".split(" "), function (e, t) {
        window.ParsleyUI[t] = function (e, i, n, r, s) {
            var o = !0 !== s;
            return a.warnOnce("Accessing UI is deprecated. Call '" + t + "' on the instance directly. Please comment in issue 1073 as to your need to call this method."), e[t](i, {
                message: n,
                assert: r,
                updateClass: o
            })
        }
    }), !1 !== window.ParsleyConfig.autoBind && e(function () {
        e("[data-parsley-validate]").length && e("[data-parsley-validate]").parsley()
    });
    var T = e({}),
        R = function () {
            a.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley")
        },
        D = "parsley:";
    e.listen = function (e, n) {
        var r;
        if (R(), "object" == typeof arguments[1] && "function" == typeof arguments[2] && (r = arguments[1], n = arguments[2]), "function" != typeof n) throw new Error("Wrong parameters");
        window.Parsley.on(i(e), t(n, r))
    }, e.listenTo = function (e, n, r) {
        if (R(), !(e instanceof x || e instanceof w)) throw new Error("Must give Parsley instance");
        if ("string" != typeof n || "function" != typeof r) throw new Error("Wrong parameters");
        e.on(i(n), t(r))
    }, e.unsubscribe = function (e, t) {
        if (R(), "string" != typeof e || "function" != typeof t) throw new Error("Wrong arguments");
        window.Parsley.off(i(e), t.parsleyAdaptedCallback)
    }, e.unsubscribeTo = function (e, t) {
        if (R(), !(e instanceof x || e instanceof w)) throw new Error("Must give Parsley instance");
        e.off(i(t))
    }, e.unsubscribeAll = function (t) {
        R(), window.Parsley.off(i(t)), e("form,input,textarea,select").each(function () {
            var n = e(this).data("Parsley");
            n && n.off(i(t))
        })
    }, e.emit = function (e, t) {
        var n;
        R();
        var r = t instanceof x || t instanceof w,
            s = Array.prototype.slice.call(arguments, r ? 2 : 1);
        s.unshift(i(e)), r || (t = window.Parsley), (n = t).trigger.apply(n, _toConsumableArray(s))
    };
    e.extend(!0, O, {
        asyncValidators: {
            "default": {
                fn: function (e) {
                    return e.status >= 200 && e.status < 300
                },
                url: !1
            },
            reverse: {
                fn: function (e) {
                    return e.status < 200 || e.status >= 300
                },
                url: !1
            }
        },
        addAsyncValidator: function (e, t, i, n) {
            return O.asyncValidators[e] = {
                fn: t,
                url: i || !1,
                options: n || {}
            }, this
        }
    }), O.addValidator("remote", {
        requirementType: {
            "": "string",
            validator: "string",
            reverse: "boolean",
            options: "object"
        },
        validateString: function (t, i, n, r) {
            var s, a, o = {},
                l = n.validator || (!0 === n.reverse ? "reverse" : "default");
            if ("undefined" == typeof O.asyncValidators[l]) throw new Error("Calling an undefined async validator: `" + l + "`");
            i = O.asyncValidators[l].url || i, i.indexOf("{value}") > -1 ? i = i.replace("{value}", encodeURIComponent(t)) : o[r.element.getAttribute("name") || r.element.getAttribute("id")] = t;
            var u = e.extend(!0, n.options || {}, O.asyncValidators[l].options);
            s = e.extend(!0, {}, {
                url: i,
                data: o,
                type: "GET"
            }, u), r.trigger("field:ajaxoptions", r, s), a = e.param(s), "undefined" == typeof O._remoteCache && (O._remoteCache = {});
            var d = O._remoteCache[a] = O._remoteCache[a] || e.ajax(s),
                h = function () {
                    var t = O.asyncValidators[l].fn.call(r, d, i, n);
                    return t || (t = e.Deferred().reject()), e.when(t)
                };
            return d.then(h, h)
        },
        priority: -1
    }), O.on("form:submit", function () {
        O._remoteCache = {}
    }), l.prototype.addAsyncValidator = function () {
        return a.warnOnce("Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`"), O.addAsyncValidator.apply(O, arguments)
    }, O.addMessages("en", {
        defaultMessage: "This value seems to be invalid.",
        type: {
            email: "This value should be a valid email.",
            url: "This value should be a valid url.",
            number: "This value should be a valid number.",
            integer: "This value should be a valid integer.",
            digits: "This value should be digits.",
            alphanum: "This value should be alphanumeric."
        },
        notblank: "This value should not be blank.",
        required: "This value is required.",
        pattern: "This value seems to be invalid.",
        min: "This value should be greater than or equal to %s.",
        max: "This value should be lower than or equal to %s.",
        range: "This value should be between %s and %s.",
        minlength: "This value is too short. It should have %s characters or more.",
        maxlength: "This value is too long. It should have %s characters or fewer.",
        length: "This value length is invalid. It should be between %s and %s characters long.",
        mincheck: "You must select at least %s choices.",
        maxcheck: "You must select %s choices or fewer.",
        check: "You must select between %s and %s choices.",
        equalto: "This value should be the same."
    }), O.setLocale("en");
    var I = new n;
    I.install();
    var q = O;
    return q
});
jQuery(document).ready(function (e) {
    function a(e, a) {
        l(e, a), e.find(a.container).first().show()
    }

    function n(a, n) {
        if (n.tabs) {
            var t = e("<div />", {
                "class": n.tabMenuClassName
            }).insertBefore(a.children(n.container).filter(":first"));
            a.children(n.container).each(function (i, r) {
                var l = e("<button/>").html(e(this).children(n.header).html()).addClass(0 == i ? n.tabMenuItemActiveClassName : "").addClass("item" + i).addClass("btn btn-default").prop("type", "button").on("click keypress", {
                    container: a.children(n.container),
                    fieldset: e(r)
                }, function () {
                    var t = e(this),
                        i = t.parent().children().index(t);
                    s(a, n, t, i)
                });
                n.tabIndex && l.prop("tabindex", i), t.append(l)
            })
        }
    }

    function t(a, n) {
        n.navigation && a.children(n.container).each(function (t) {
            var i = e("<div />").addClass("powermail_fieldwrap").addClass("powermail_tab_navigation").appendTo(e(this));
            t > 0 && i.append(c(a, n)), t < a.children(n.container).length - 1 && i.append(o(a, n))
        })
    }

    function i(a, n) {
        e.fn.parsley && "data-parsley-validate" === a.data("parsley-validate") && a.parsley().subscribe("parsley:field:validated", function () {
            v(a, n), C(a, n)
        })
    }

    function r(a, n) {
        n.openTabOnError && e.fn.parsley && e.listen("parsley:field:error", function () {
            setTimeout(function () {
                a.find("." + n.tabMenuClassName + " > ." + n.tabMenuItemErrorClassName + ":first").click()
            }, 50)
        })
    }

    function s(a, n, t, i) {
        $activeTab = b(a, n), $activeTab.removeClass(n.tabMenuItemActiveClassName), t.addClass(n.tabMenuItemActiveClassName), l(a, n), e(".powermail_fieldset", a).slice(i, i + 1).show()
    }

    function l(e, a) {
        e.children(a.container).hide()
    }

    function c(a, n) {
        return e("<a />").prop("href", "#").addClass("btn btn-warning").html("<").click(function (e) {
            e.preventDefault(), u(a, n)
        })
    }

    function o(a, n) {
        return e("<a />").prop("href", "#").addClass("btn btn-primary pull-right").html(">").click(function (e) {
            e.preventDefault(), d(a, n)
        })
    }

    function d(e, a) {
        var n = m(e, a);
        $activeTab = b(e, a), $activeTab.removeClass(a.tabMenuItemActiveClassName).next().addClass(a.tabMenuItemActiveClassName), f(e, a, n + 1)
    }

    function u(e, a) {
        var n = m(e, a);
        $activeTab = b(e, a), $activeTab.removeClass(a.tabMenuItemActiveClassName).prev().addClass(a.tabMenuItemActiveClassName), f(e, a, n - 1)
    }

    function f(e, a, n) {
        l(e, a), e.find(".powermail_fieldset").slice(n, n + 1).show()
    }

    function m(e, a) {
        var n = p(e, a),
            t = n.index(b(e, a));
        return parseInt(t)
    }

    function p(e, a) {
        return e.find("." + a.tabMenuClassName).children()
    }

    function b(e, a) {
        var n = p(e, a);
        return n.filter("." + a.tabMenuItemActiveClassName)
    }

    function v(e, a) {
        var n = p(e, a);
        n.removeClass(a.tabMenuItemErrorClassName)
    }

    function C(a, n) {
        a.parsley().isValid() || a.find(".parsley-error").each(function () {
            var t = a.find(".powermail_fieldset").index(e(this).closest(".powermail_fieldset")),
                i = p(a, n),
                r = i.slice(t, t + 1);
            r.addClass(n.tabMenuItemErrorClassName)
        })
    }
    e.fn.powermailTabs = function (e) {
        "use strict";
        var s = jQuery(this);
        e = jQuery.extend({
            container: "fieldset",
            header: "legend",
            tabs: !0,
            navigation: !0,
            openTabOnError: !0,
            tabIndex: !0,
            tabMenuClassName: "btn-group",
            tabMenuItemActiveClassName: "btn-primary",
            tabMenuItemErrorClassName: "btn-danger"
        }, e), a(s, e), n(s, e), t(s, e), i(s, e), r(s, e)
    }
});

function PowermailForm(e) {
    "use strict";
    this.initialize = function () {
        t(), a(), i(), r(), o(), n(), f(), l()
    };
    var t = function () {
            e.fn.powermailTabs && e(".powermail_morestep").each(function () {
                e(this).powermailTabs()
            })
        },
        a = function () {
            e("form[data-powermail-ajax]").length && p()
        },
        i = function () {
            if (e('*[data-powermail-location="prefill"]').length && navigator.geolocation) {
                e(this);
                navigator.geolocation.getCurrentPosition(function (t) {
                    var a = t.coords.latitude,
                        i = t.coords.longitude,
                        r = C() + "/index.php?eID=powermailEidGetLocation";
                    jQuery.ajax({
                        url: r,
                        data: "lat=" + a + "&lng=" + i,
                        cache: !1,
                        success: function (t) {
                            t && e('*[data-powermail-location="prefill"]').val(t)
                        }
                    })
                })
            }
        },
        r = function () {
            e.fn.datetimepicker && e(".powermail_date").each(function () {
                var t = e(this);
                if ("date" === t.prop("type") || "datetime-local" === t.prop("type") || "time" === t.prop("type")) {
                    if (!t.data("datepicker-force")) {
                        if (e(this).data("date-value")) {
                            var a = g(e(this).data("date-value"), e(this).data("datepicker-format"), t.prop("type"));
                            null !== a && e(this).val(a)
                        }
                        return
                    }
                    t.prop("type", "text"), t.val(e(this).data("date-value"))
                }
                var i = !0,
                    r = !0;
                "date" === t.data("datepicker-settings") ? r = !1 : "time" === t.data("datepicker-settings") && (i = !1), t.datetimepicker({
                    format: t.data("datepicker-format"),
                    timepicker: r,
                    datepicker: i,
                    lang: "en",
                    i18n: {
                        en: {
                            months: t.data("datepicker-months").split(","),
                            dayOfWeek: t.data("datepicker-days").split(",")
                        }
                    }
                })
            })
        },
        o = function () {
            e(".powermail_all_type_password.powermail_all_value").html("********")
        },
        n = function () {
            e.fn.parsley && e(".powermail_reset").on("click", "", function () {
                e('form[data-parsley-validate="data-parsley-validate"]').parsley().reset()
            })
        },
        l = function () {
            window.Parsley && (x(), b())
        },
        p = function () {
            var t, a = !1;
            e(document).on("submit", "form[data-powermail-ajax]", function (i) {
                var r = e(this),
                    o = r.closest(".tx-powermail");
                r.data("powermail-ajax-uri") && (t = r.data("powermail-ajax-uri"));
                var n = r.data("powermail-form");
                a || (e.ajax({
                    type: "POST",
                    url: r.prop("action"),
                    data: new FormData(r.get(0)),
                    contentType: !1,
                    processData: !1,
                    beforeSend: function () {
                        s(r)
                    },
                    complete: function () {
                        d(r), f(), c(o)
                    },
                    success: function (i) {
                        var o = e('*[data-powermail-form="' + n + '"]:first', i);
                        o.length ? (e('*[data-powermail-form="' + n + '"]:first').closest(".tx-powermail").html(o), e.fn.powermailTabs && e(".powermail_morestep").powermailTabs(), e.fn.parsley && e('form[data-parsley-validate="data-parsley-validate"]').parsley(), w()) : (t ? D(t) : r.submit(), a = !0)
                    }
                }), i.preventDefault())
            })
        },
        s = function (t) {
            d(t), e(".powermail_submit", t).length ? e(".powermail_submit", t).parent().append(y()) : t.closest(".tx-powermail").append(y())
        },
        d = function (e) {
            e.closest(".tx-powermail").find(".powermail_progressbar").remove()
        },
        c = function (t) {
            var a = e.Event("submitted.powermail.form");
            t.trigger(a)
        },
        f = function () {
            e(".powermail_fieldwrap_file").find(".deleteAllFiles").each(function () {
                u(e(this).closest(".powermail_fieldwrap_file").find('input[type="file"]'))
            }), e(".deleteAllFiles").click(function () {
                m(e(this).closest(".powermail_fieldwrap_file").find('input[type="hidden"]')), e(this).closest("ul").fadeOut(function () {
                    e(this).remove()
                })
            })
        },
        u = function (e) {
            e.prop("disabled", "disabled").addClass("hide").prop("type", "hidden")
        },
        m = function (e) {
            e.prop("disabled", !1).removeClass("hide").prop("type", "file")
        },
        w = function () {
            e("img.powermail_captchaimage").each(function () {
                var t = h(e(this).prop("src"));
                e(this).prop("src", t + "?hash=" + v(5))
            })
        },
        h = function (e) {
            var t = e.split("?");
            return t[0]
        },
        v = function (e) {
            for (var t = "", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = 0; i < e; i++) t += a.charAt(Math.floor(Math.random() * a.length));
            return t
        },
        g = function (e, t, a) {
            var i = Date.parseDate(e, t);
            if (null === i) return null;
            var r = new Date(i),
                o = r.getFullYear() + "-";
            o += ("0" + (r.getMonth() + 1)).slice(-2) + "-", o += ("0" + r.getDate()).slice(-2);
            var n = ("0" + r.getHours()).slice(-2) + ":" + ("0" + r.getMinutes()).slice(-2),
                l = o + "T" + n;
            return "date" === a ? o : "datetime-local" === a ? l : "time" === a ? n : null
        },
        y = function () {
            return e("<div />").addClass("powermail_progressbar").html(e("<div />").addClass("powermail_progress").html(e("<div />").addClass("powermail_progress_inner")))
        },
        _ = function (e) {
            for (var t = e.get(0), a = 0, i = 0; i < t.files.length; i++) {
                var r = t.files[i];
                r.size > a && (a = r.size)
            }
            return parseInt(a)
        },
        x = function () {
            window.Parsley.addValidator("powermailfilesize", function (t, a) {
                if (a.indexOf(",") !== -1) {
                    var i = a.split(","),
                        r = parseInt(i[0]),
                        o = e('*[name="tx_powermail_pi1[field][' + i[1] + '][]"]');
                    if (o.length && _(o) > r) return !1
                }
                return !0
            }, 32).addMessage("en", "powermailfilesize", "Error")
        },
        b = function () {
            window.Parsley.addValidator("powermailfileextensions", function (t, a) {
                var i = e('*[name="tx_powermail_pi1[field][' + a + '][]"]');
                return !i.length || k(j(t), i.prop("accept"))
            }, 32).addMessage("en", "powermailfileextensions", "Error")
        },
        k = function (e, t) {
            return t.indexOf("." + e) !== -1
        },
        j = function (e) {
            return e.split(".").pop().toLowerCase()
        },
        D = function (e) {
            e.indexOf("http") !== -1 ? window.location = e : window.location.pathname = e
        },
        C = function () {
            var t;
            return t = e("base").length > 0 ? jQuery("base").prop("href") : "https:" != window.location.protocol ? "http://" + window.location.hostname : "https://" + window.location.hostname
        }
}
jQuery(document).ready(function (e) {
    "use strict";
    var t = new window.PowermailForm(e);
    t.initialize()
});
/*!
 * ihavecookies - jQuery plugin for displaying cookie/privacy message
 * v0.3.2
 *
 * Copyright (c) 2018 Ketan Mistry (https://iamketan.com.au)
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * CHANGED VERSION
 * BX Modifications:   
				new param appendMessage, prepend now possible
 * 				remove click event handler before adding
 *				new options:
 *				wrapperClass, useInnerWrapper, innerWrappperClass, acceptBtnClass, advancedBtnClass, cookieTypeContainerClass
 * 				showTypeDesc, descDivider, onAdvanced
 *				preselect option
 
 */

(function ($) {

    /*
    |--------------------------------------------------------------------------
    | Cookie Message
    |--------------------------------------------------------------------------
    |
    | Displays the cookie message on first visit or 30 days after their
    | last visit.
    |
    | @param event - 'reinit' to reopen the cookie message
    |
    */
    $.fn.ihavecookies = function (options, event) {

        var $element = $(this);

        // Set defaults
        var settings = $.extend({
            cookieTypes: [{
                    type: 'Site Preferences',
                    value: 'preferences',
                    description: 'These are cookies that are related to your site preferences, e.g. remembering your username, site colours, etc.'
                },
                {
                    type: 'Analytics',
                    value: 'analytics',
                    description: 'Cookies related to site visits, browser types, etc.'
                },
                {
                    type: 'Marketing',
                    value: 'marketing',
                    description: 'Cookies related to marketing, e.g. newsletters, social media, etc'
                }
            ],
            appendMessage: 1, //append message or prepend message
            wrapperClass: '', //add a class attribute to the div container
            useInnerWrapper: 0, //add a div container within the wrapping div
            innerWrappperClass: '', //add a class attribute to the inner wrapper
            acceptBtnClass: '', //add class to the accapt cookies button
            advancedBtnClass: '', //add class to the advanced Button
            cookieTypeContainerClass: '', //add class to the container which lists all container types
            showTypeDesc: 0, //add cookie type description not only as title attribute
            descDivider: ' – ', //text to be add between cookie type headline and cookie type description 
            onAdvanced: function () {}, //event trigger when advanced button is pressed



            title: 'Cookies & Privacy',
            message: 'Cookies enable you to use shopping carts and to personalize your experience on our sites, tell us which parts of our websites people have visited, help us measure the effectiveness of ads and web searches, and give us insights into user behavior so we can improve our communications and products.',
            link: '/privacy-policy',
            delay: 2000,
            expires: 30,
            moreInfoLabel: 'More information',
            acceptBtnLabel: 'Accept Cookies',
            advancedBtnLabel: 'Customise Cookies',
            cookieTypesTitle: 'Select cookies to accept',
            fixedCookieTypeLabel: 'Necessary',
            fixedCookieTypeDesc: 'These are cookies that are essential for the website to work correctly.',
            onAccept: function () {},

            uncheckBoxes: false
        }, options);

        var myCookie = getCookie('cookieControl');
        var myCookiePrefs = getCookie('cookieControlPrefs');
        if (!myCookie || !myCookiePrefs || event == 'reinit') {
            // Remove all instances of the cookie message so it's not duplicated
            $('#gdpr-cookie-message').remove();

            // Set the 'necessary' cookie type checkbox which can not be unchecked
            var cookieTypes = '<li><input type="checkbox" name="gdpr[]" value="necessary" checked="checked" disabled="disabled"> <label title="' + settings.fixedCookieTypeDesc + '">' + settings.fixedCookieTypeLabel + '</label>' + ((settings.showTypeDesc == 1) ? settings.descDivider + settings.fixedCookieTypeDesc : '') + '</li>';

            // Generate list of cookie type checkboxes
            preferences = JSON.parse(myCookiePrefs);
            $.each(settings.cookieTypes, function (index, field) {
                if (field.type !== '' && field.value !== '') {
                    //console.log(field.value+" "+field.preselect);
                    cookieTypes += '<li><input ' + ((!myCookiePrefs && field.preselect == 1) ? 'checked="checked"' : '') + ' class="gdpr-cookie-cb" type="checkbox" id="gdpr-cookietype-' + field.value + '" name="gdpr[]" value="' + field.value + '" data-auto="on"> <label for="gdpr-cookietype-' + field.value + '"' + ((field.description !== false) ? ' title="' + field.description + '"' : '') + '>' + field.type + '</label> ' + ((settings.showTypeDesc == 1 && field.description != '') ? settings.descDivider + field.description : '') + '</li>';
                }



            });

            // Display cookie message on page
            var cookieMessage = '<div id="gdpr-cookie-message" ' + ((settings.wrapperClass != "") ? 'class="' + settings.wrapperClass + '"' : '') + '>';
            if (settings.useInnerWrapper == 1) {
                cookieMessage += '<div class="' + settings.innerWrappperClass + '">';
            }
            cookieMessage += '<h4>' + settings.title + '</h4>';
            cookieMessage += '<p>' + settings.message + ' ';
            cookieMessage += '<a href="' + settings.link + '">' + settings.moreInfoLabel + '</a>';
            cookieMessage += '<div id="gdpr-cookie-types" style="display:none;"' + ((settings.cookieTypeContainerClass != "") ? ' class="' + settings.cookieTypeContainerClass + '"' : '') + '><h5>' + settings.cookieTypesTitle + '</h5><ul>' + cookieTypes + '</ul></div>';
            cookieMessage += '<p>';
            cookieMessage += '<button ' + ((settings.acceptBtnClass != "") ? 'class="' + settings.acceptBtnClass + '"' : '') + ' id="gdpr-cookie-accept" type="button">' + settings.acceptBtnLabel + '</button>';
            cookieMessage += '<button ' + ((settings.advancedBtnClass != "") ? 'class="' + settings.advancedBtnClass + '"' : '') + ' id="gdpr-cookie-advanced" type="button">' + settings.advancedBtnLabel + '</button>';
            cookieMessage += '</p>';



            cookieMessage += '</div>';

            if (settings.useInnerWrapper == 1) {
                cookieMessage += '</div>';
            }

            setTimeout(function () {
                if (settings.appendMessage == 1) {
                    $($element).append(cookieMessage);
                } else {
                    $($element).prepend(cookieMessage);
                }
                $('#gdpr-cookie-message').hide().fadeIn('slow', function () {
                    // If reinit'ing, open the advanced section of message
                    // and re-check all previously selected options.
                    if (event == 'reinit') {
                        $('#gdpr-cookie-advanced').trigger('click');
                        if (preferences) {
                            $('#gdpr-cookie-message .gdpr-cookie-cb').prop('checked', false);
                            $.each(preferences, function (index, field) {
                                $('input#gdpr-cookietype-' + field).prop('checked', true);

                            });
                        }
                    }
                });
            }, settings.delay);

            // When accept button is clicked drop cookie
            $('body').off('click', '#gdpr-cookie-accept'); //remove, multiple reinits possible
            $('body').on('click', '#gdpr-cookie-accept', function () {
                // Set cookie
                dropCookie(true, settings.expires);

                // If 'data-auto' is set to ON, tick all checkboxes because
                // the user hasn't clicked the customise cookies button
                $('input[name="gdpr[]"][data-auto="on"]').prop('checked', true);
                // Save users cookie preferences (in a cookie!)
                var prefs = [];
                $.each($('input[name="gdpr[]"]').serializeArray(), function (i, field) {
                    prefs.push(field.value);
                });
                //console.log(JSON.stringify(prefs));
                setCookie('cookieControlPrefs', JSON.stringify(prefs), 365);

                // Run callback function
                settings.onAccept.call(this);
                return false;
            });

            // Toggle advanced cookie options
            $('body').off('click', '#gdpr-cookie-advanced'); //remove, multiple reinits possible
            $('body').on('click', '#gdpr-cookie-advanced', function () {
                // Uncheck all checkboxes except for the disabled 'necessary'
                // one and set 'data-auto' to OFF for all. The user can now
                // select the cookies they want to accept.
                // CHANGE: Dont change check property, check status now preselectable
                $('input[name="gdpr[]"]:not(:disabled)').attr('data-auto', 'off');
                //$('input[name="gdpr[]"]:not(:disabled)').attr('data-auto', 'off').prop('checked', false);


                $('#gdpr-cookie-types').slideDown('fast', function () {
                    $('#gdpr-cookie-advanced').prop('disabled', true);
                });
                settings.onAdvanced.call(this);
            });

        } else {
            var cookieVal = true;
            if (myCookie == 'false') {
                cookieVal = false;
            }
            dropCookie(cookieVal, settings.expires);
        }

        // Uncheck any checkboxes on page load
        if (settings.uncheckBoxes === true) {
            $('input[type="checkbox"].ihavecookies').prop('checked', false);
        }

    };

    // Method to get cookie value
    $.fn.ihavecookies.cookie = function () {
        var preferences = getCookie('cookieControlPrefs');
        return JSON.parse(preferences);
    };

    // Method to check if user cookie preference exists
    $.fn.ihavecookies.preference = function (cookieTypeValue) {
        var control = getCookie('cookieControl');
        var preferences = getCookie('cookieControlPrefs');
        preferences = JSON.parse(preferences);
        if (control === false) {
            return false;
        }
        if (preferences === false || preferences.indexOf(cookieTypeValue) === -1) {
            return false;
        }
        return true;
    };

    /*
    |--------------------------------------------------------------------------
    | Drop Cookie
    |--------------------------------------------------------------------------
    |
    | Function to drop the cookie with a boolean value of true.
    |
    */
    var dropCookie = function (value, expiryDays) {
        setCookie('cookieControl', value, expiryDays);
        $('#gdpr-cookie-message').fadeOut('fast', function () {
            $(this).remove();
        });
    };

    /*
    |--------------------------------------------------------------------------
    | Set Cookie
    |--------------------------------------------------------------------------
    |
    | Sets cookie with 'name' and value of 'value' for 'expiry_days'.
    |
    */
    var setCookie = function (name, value, expiry_days) {
        var d = new Date();
        d.setTime(d.getTime() + (expiry_days * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toUTCString();
        document.cookie = name + "=" + value + ";" + expires + ";path=/";
        return getCookie(name);
    };

    /*
    |--------------------------------------------------------------------------
    | Get Cookie
    |--------------------------------------------------------------------------
    |
    | Gets cookie called 'name'.
    |
    */
    var getCookie = function (name) {
        var cookie_name = name + "=";
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(cookie_name) === 0) {
                return c.substring(cookie_name.length, c.length);
            }
        }
        return false;
    };

}(jQuery));


if (typeof cookiell == "undefined") {
    cookiell = new Array();
    cookiell["title"] = 'Cookie-Einstellungen';
    cookiell["message"] = 'Wir verwenden Cookies, um Ihnen ein optimales Website-Erlebnis zu bieten. Dazu zählen Cookies, die für den Betrieb der Seite und die Bedienung durch den Nutzer nach dessen Login notwendig sind sowie solche, die lediglich zu anonymen Statistikzwecken oder zur Ausspielung auf Ihren Interessen beruhender Werbung genutzt werden. Sie können selbst entscheiden, welche Kategorien Sie zulassen möchten. Bitte beachten Sie, dass auf Basis Ihrer Einstellungen womöglich nicht mehr alle Funktionalitäten der Seite zur Verfügung stehen. Weitere Informationen finden Sie in unserer ';
    cookiell["link1"] = '/datenschutz/';
    cookiell["dataprotection"] = 'Datenschutzerklärung';
    cookiell["cookieconfig"] = 'Cookie-Einstellungen';
    cookiell["acceptall"] = 'Alle Cookies akzeptieren';
    cookiell["cookielisthead"] = 'Wählen Sie die Cookies aus, die Sie zulassen möchten.';
    cookiell["necessarycookies"] = 'Notwendig';
    cookiell["necessarycookiesdesc"] = 'Diese Cookies sind notwendig, damit die Seite funktionieren kann. Sie können Ihren Browser so einstellen, dass alle Cookies blockiert werden. Einige Bereiche der Website funktionieren dann aber möglicherweise nicht.';
    cookiell["acceptselected"] = 'Auswahl speichern';
    cookiell["cookieprefhead"] = 'Komfort';
    cookiell["cookieprefdesc"] = 'Diese Cookies sind dazu gedacht Seiteneinstellungen, die Sie beim Surfen auf von Brillux betriebenen Websites gemacht haben, für Sie zu speichern. Dies soll Ihrem Bedienkomfort dienen.';
    cookiell["cookieanalyticshead"] = 'Statistik';
    cookiell["cookieanalyticsdesc"] = 'Um unser Angebot und unsere Website weiter zu verbessern, erfassen wir anonymisierte Daten für Statistiken und Analysen. Mithilfe dieser Cookies können wir beispielsweise die Besucherzahlen und die Nutzung bestimmter Seiten ermitteln und unsere Inhalte optimieren. Auf unserer Seite haben wir zu diesem Zweck Google Analytics im Einsatz.';
    cookiell["cookietargetinghead"] = 'Personalisierung';
    cookiell["cookietargetingdesc"] = 'Marketing-Cookies werden von Drittanbietern oder Publishern verwendet, um Ihnen Werbung anzuzeigen, die Ihren Interessen entspricht. NE.R.O. Tracking und die ADITION technologies AG erheben und verarbeiten anonym über Third Party Cookies Ihr Nutzungsverhalten auf von Brillux betriebenen Webseiten sowie auf nicht von Brillux betriebenen Webseiten. Dadurch profitieren Sie als Nutzer, indem Sie Werbung erhalten, die eher Ihren Interessen entspricht, und dadurch, dass Ihnen insgesamt weniger zufällig gestreute Werbung angezeigt wird. Sämtliche erhobenen Nutzungsdaten werden unter Verwendung eines Pseudonyms gespeichert. Eine persönliche Identifikation findet dabei nicht statt. Die aus technischen Gründen übermittelte IP Adresse Ihres Rechners wird dabei nicht gespeichert und nicht zur gesteuerten Einblendung von Werbung verwendet. Auf unserer Webseite verwenden wir Cookies von Google, LinkedIn, Twitter, Pinterest, Facebook, NE.R.O. Tracking und der ADITION technologies AG.';
}
if (typeof bxCookieRemindPref == "undefined") {
    bxCookieRemindPref = new Array();
    bxCookieRemindPref["simpleclub"] = new Array();
    bxCookieRemindPref["simpleclub"]["title"] = "simpleclub Gutschein";
    bxCookieRemindPref["simpleclub"]["desc"] = "Sie möchten Ihren simpleclub Gutschein-einlösen? Hier geht es zur Einlösung.";
    bxCookieRemindPref["simpleclub"]["link"] = "/simpleclub-eintritt/";
    bxCookieRemindPref["simpleclub"]["img"] = "simpleclub.jpg";
    bxCookieRemindPref["wertscheckheftwdvs"] = new Array();
    bxCookieRemindPref["wertscheckheftwdvs"]["title"] = "Wertscheckheft WDVS aktivieren";
    bxCookieRemindPref["wertscheckheftwdvs"]["desc"] = "Haben Sie ein Wertscheckheft und möchten es aktivieren? Hier gehts weiter.";
    bxCookieRemindPref["wertscheckheftwdvs"]["link"] = "/wertscheckheft-wdvs/";
    bxCookieRemindPref["wertscheckheftwdvs"]["img"] = "wertscheckheftwdvs.jpg";

}


function bxGaOptout(cookiedisableStr) {
    if (cookiedisableStr !== 'undefined' && typeof cookiedisableStr !== 'undefined' && cookiedisableStr != null) {
        document.cookie = cookiedisableStr + "=true; expires=Thu, 31 Dec 2099 23:59:59 UTC; path=/";
        window[cookiedisableStr] = true;
    }
}

function bxGaDeleteOptOut(cookiedisableStr) {
    if (cookiedisableStr !== 'undefined' && typeof cookiedisableStr !== 'undefined' && cookiedisableStr != null) {
        bxDeleteCookieByName(cookiedisableStr);
        window[cookiedisableStr] = false;
    }
}


function bxGetCookieByName(name) {
    var cookie_name = name + "=";
    var decodedCookie = decodeURIComponent(document.cookie);
    var ca = decodedCookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(cookie_name) === 0) {
            return c.substring(cookie_name.length, c.length);
        }
    }
    return false;
}

function bxDeleteCookieByName(name) {
    if (bxGetCookieByName(name)) {
        document.cookie = name + "=false; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
    }

}

function bxDeleteCookieByNameAndDomain(name, domain) {
    if (bxGetCookieByName(name)) {
        document.cookie = name + "=false; domain=" + domain + "; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
    }

}

function bxGetPureCDomainName() {
    var hostName1 = window.location.hostname;
    return hostName1.substring(hostName1.lastIndexOf(".", hostName1.lastIndexOf(".") - 1) + 1);
}

function bxSetCookie(name, value, expiry, sameSite) {
    var d = new Date();
    d.setTime(d.getTime() + (expiry * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/" + ";SameSite=" + sameSite;
    return bxGetCookieByName(name);
}

function bxRenderCookieCRem(addDeleteBtns) {
    var cookieReminder = bxGetCookieCRem();
    var rhtml = "";
    if (cookieReminder.length > 0) {
        var cookieReminderSet = cookieReminder.split(",");
        var telem = null;
        var tlopen, tlclose;
        var ttextclass = "";

        if (bxCookieRemindPref) {

            for (var i = 0; i < cookieReminderSet.length; i++) {

                if (typeof bxCookieRemindPref[cookieReminderSet[i]] !== "undefined") {
                    telem = bxCookieRemindPref[cookieReminderSet[i]];
                    rhtml += "<div class='col-sm-6 bxcookieremelem '><div class='bxcookieremeleminner'>";
                    if (true || addDeleteBtns) {

                        rhtml += "<a class='bxcookieremremove' href='#' onclick=\"bxRemoveCookieCElem('" + cookieReminderSet[i] + "');$(this).parent().parent().hide();return false;\"><i class='fa fa-times'></i></a>";
                    }
                    if (telem["link"]) {
                        tlopen = "<a href='" + telem["link"] + "'>";
                        tlclose = "</a>";
                    } else {
                        tlopen = "";
                        tlclose = "";
                    }
                    if (telem["img"]) {
                        rhtml += "<div class='col-sm-4 center'>" + tlopen + "<img src='fileadmin/template/global/img/cookiereminder/" + telem["img"] + "' alt='" + telem["title"] + "'>" + tlclose + "</div>";
                        ttextclass = "col-sm-8"
                    } else {
                        ttextclass = "col-sm-12"
                    }
                    rhtml += "<div class='" + ttextclass + " bxcookieremtext'><p class='bxcookieremtitle'>" + tlopen + "<strong><i class='fa fa-chevron-right'></i> " + telem["title"] + tlclose + "</strong></p>";
                    rhtml += "<p class='bxcookieremdesc'>" + tlopen + telem["desc"] + tlclose + "</p></div>";

                    rhtml += "<div class='clearfix'></div></div></div>";
                }
            }
        }
    }
    return rhtml;
}

function bxSetCookieCRem(reminderid) {
    var cookiepref = bxGetCookieByName("cookieControlPrefs");
    if (cookiepref.indexOf('preferences') > 0) {
        if (bxCookieRemindPref && typeof bxCookieRemindPref[reminderid] !== 'undefined') {
            var cookieReminder = bxGetCookieCRem();
            var cookieReminderSet = new Array();
            var cookieReminderValAlreadySet = false;
            if (cookieReminder && cookieReminder.length > 0) {
                cookieReminderSet = cookieReminder.split(",");
            }
            if (cookieReminderSet) {
                for (var i = 0; i < cookieReminderSet.length; i++) {
                    //Todo check valid value
                    if (cookieReminderSet[i] == reminderid) {
                        cookieReminderValAlreadySet = true;
                        return;
                    }
                }
            }
            if (!cookieReminderValAlreadySet) {
                cookieReminderSet.push(reminderid);
            }
            cookieReminder = "";
            for (var i = 0; i < cookieReminderSet.length; i++) {
                cookieReminder += ((i > 0) ? "," : "") + cookieReminderSet[i];
            }
            bxWriteCookieCRem(cookieReminder);
        } else {
            //console.log("ERROR: Could not add reminderid, its unknown");				
        }
    } else {
        //console.log("ERROR: cannot write cookie, user did not allow preference cookies");
    }
    return true;
}

function bxRemoveCookieCElem(reminderid) {
    var cookieReminder = bxGetCookieCRem();
    if (cookieReminder && cookieReminder.length > 0) {
        var cookieReminderSet = cookieReminder.split(",");
        var cookieIdFound = false;
        cookieReminder = "";
        for (var i = 0; i < cookieReminderSet.length; i++) {
            //Todo check valid value
            if (cookieReminderSet[i] != reminderid) {
                cookieReminder += ((cookieReminder != "" && i > 0) ? "," : "") + cookieReminderSet[i];
            } else {
                cookieIdFound = true;
            }
        }
        if (cookieIdFound) {
            bxWriteCookieCRem(cookieReminder);
        }
    }
}

function bxGetCookieCRem() {
    return bxGetCookieByName("cookieReminder");
}

function bxWriteCookieCRem(content) {
    if (content && content != "") {
        bxSetCookie("cookieReminder", content, 30, "Lax");
    } else {
        bxDeleteCookieByName("cookieReminder");
    }

}


$(document).ready(function () {
    gadisableStr = null;
    if (typeof _gaq !== 'undefined' && typeof _gaq[0] !== 'undefined' && typeof _gaq[0][1] !== 'undefined') {
        gadisableStr = 'ga-disable-' + _gaq[0][1];
    }

    bxcookieoptions = {
        onAccept: function () {
            var cookiepref = bxGetCookieByName("cookieControlPrefs");
            if (cookiepref.indexOf('analytics') > 0) {
                //console.log("analytics set");
                //unset disable cookie, if it was set before
                if (gadisableStr != null && bxGetCookieByName(gadisableStr) != false) {
                    bxGaDeleteOptOut(gadisableStr);
                }

            } else {
                //console.log("analytics not set");
                try {
                    bxGaOptout(gadisableStr);
                    var hostName1 = "." + bxGetPureCDomainName();
                    bxDeleteCookieByNameAndDomain("_ga", hostName1);
                    bxDeleteCookieByNameAndDomain("_gid", hostName1);
                } catch (e) {
                    //  Block of code to handle errors
                    //console.log(e);
                }

            }
            document.location.reload();
        },
        appendMessage: 0,
        wrapperClass: 'cc_banner-wrapper',
        useInnerWrapper: 1,
        innerWrappperClass: 'cc_banner cc_container ',
        acceptBtnClass: 'btn btn-default',
        advancedBtnClass: 'btn-cookie-configure',
        cookieTypeContainerClass: 'cookie-type-list',
        showTypeDesc: 1,
        expires: 365,

        title: cookiell["title"],
        message: cookiell["message"],
        link: cookiell["link1"],
        moreInfoLabel: cookiell["dataprotection"],
        advancedBtnLabel: cookiell["cookieconfig"],
        acceptBtnLabel: cookiell["acceptall"],
        cookieTypesTitle: cookiell["cookielisthead"],
        fixedCookieTypeLabel: cookiell["necessarycookies"],
        fixedCookieTypeDesc: cookiell["necessarycookiesdesc"],
        onAdvanced: function () {
            $('#gdpr-cookie-accept').text(cookiell["acceptselected"]);
        },
        delay: 500,
        // Array of cookie types for which to show checkboxes.
        // - type: Type of cookie. This is also the label that is displayed.
        // - value: Value of the checkbox so it can be easily identified in
        //          your application.
        // - description: Description for this cookie type. Displayed in
        //                title attribute.
        cookieTypes: [{
                type: cookiell["cookieprefhead"],
                value: 'preferences',
                description: cookiell["cookieprefdesc"],
                preselect: 1,
            },
            {
                type: cookiell["cookieanalyticshead"],
                value: 'analytics',
                description: cookiell["cookieanalyticsdesc"],
                preselect: 0,
            },
            {
                type: cookiell["cookietargetinghead"],
                value: 'targeting',
                description: cookiell["cookietargetingdesc"],
                preselect: 0,
            },
        ],
    };

    if (typeof flagCCGDPRMessagetHide !== 'undefined' && flagCCGDPRMessagetHide == 1) {
        $('#gdpr-cookie-message').hide();
    } else {

        $('body').ihavecookies(bxcookieoptions);
    }
    $('#btncookiefooter').click(function (e) {
        $('body').ihavecookies(bxcookieoptions, 'reinit');
        $('html, body').animate({
            scrollTop: 0
        }, '300');
        e.preventDefault();
        return false;
    });

});




